<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sosuke</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vevlins.github.io/"/>
  <updated>2018-03-31T14:23:19.000Z</updated>
  <id>https://vevlins.github.io/</id>
  
  <author>
    <name>Vevlins</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试失败总结</title>
    <link href="https://vevlins.github.io/2018/03/31/%E9%9D%A2%E8%AF%95%E5%A4%B1%E8%B4%A5%E6%80%BB%E7%BB%93/"/>
    <id>https://vevlins.github.io/2018/03/31/面试失败总结/</id>
    <published>2018-03-31T13:02:11.000Z</published>
    <updated>2018-03-31T14:23:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>痛定思痛。我认为自己一个最大的优点就是能从每一次失败当中学习到东西，让失败变成一个有价值的事情，这样虽然失败其实也没有失败，因为从自身成长的角度而言，反而是收获了很多。能够和一线大佬进行两三个小时的’面试一对一辅导’,第一次面试在A家面到总监，这个成绩也还不算差。</p><p>不要靠天赋成功，也不要靠运气成功，要让每一次成功都是一个必然，要让每一个方面的成功都能成为可能。事情的成功，应该是合理的方法下的必然。<br><a id="more"></a></p><p>周四得知自己的手机出了毛病，电话一直打不进来，导致之前投的提前批面试基本上gg，幸运地在刚解决完问题的晚上接到了腾讯TEG的电话一面，之后赴约前往深圳腾讯大厦现场面试。</p><p>现场面试的套路和原本自己想的完全不一样，并不是说一个答一个的模式。二面考察的是项目能力，先是做了几道常规的前端编程，然后讲解自己的项目，并且在这个过程中问题逐渐偏向了http和权限控制。最后设计一个手机扫码实现网页登陆的解决方案。应该说最后这个问题还是很好的，考察的流程比较完整，自我感觉这个题目回答地还比较ok，面完之后面试官便告知已经通过，顺利进入了三面。</p><p>三面是总监面，这一面本来觉得自己发挥的很好，没有被明显地卡住，现场氛围也还算一直轻松，没想到最后挂掉了。</p><p>现在心情归于冷静，我开始仔细想了想原因。主要还是因为做的项目偏向css的过多，导致面试官认为js的能力太弱。</p><p>技术方面主要问了移动端响应式如何实现和浏览器兼容性还有web安全，关于这几个问题，回答得应该还算可以，至少没有卡壳，应该不是被直接否决的原因。但是浏览器兼容性这个问题因为自己平时做css项目多所以自己讲的也主要是css方面的兼容性，很可能加深了面试官对我js弱的印象。</p><p>这个看法，我既觉得冤也不觉得冤，虽然我对js的项目做的少，但是我自认为对js的理解还算深入一点，并不是遇到js问题一窍不通，只是平时做的js都是在业务项目里，由于业务本身的限制，导致js本身就没有太多的需求，也无法体现出太多能力。但是说冤枉似乎也是不合适，毕竟自己在js方面的实践确实是少了，无论如何，还是应该马上着手做一些稍微体现js能力的项目。</p><p>另外针对今天面试流程中出现的问题作出以下全面整理：</p><ul><li>正则表达式继续学习</li><li>鉴权和https</li><li>移动端响应再深入</li><li>浏览器兼容问题再深入</li></ul><p>另外自我总结还是比较弱的方面有：</p><ul><li>数据结构和算法</li><li>webpack原理和配置</li><li>promise和async/await内在机制</li><li>dom操作和对应的api</li><li>nodejs/koa</li></ul><p>针对性地作出以下计划：</p><ul><li>做一个gulp插件</li><li>手写包括promise在内的ES6的polyfills解决方案</li><li>通读jq/underscore源码，掌握浏览器兼容的js方面，并自己进行实现</li><li>实现OAuth2协议</li><li>造一个移动端扫码登陆的封装较好的轮子</li><li>对vue达到一定程度地理解，并做一个微型mvvm的实践</li><li>vue技术栈的小红书项目不断完善</li><li>深入学习正则</li><li>用js实现常见算法问题</li><li>实现js各种dom操作练习</li><li>完整地配置一遍webpack</li><li>学习nodejs/koa，在小红书项目中应用</li><li>js封装一个轮播图+瀑布流</li><li>在web前端安全问题进行实践</li><li>坚持写技术向深度向博客</li><li>使用node原生http实现一个简单后端框架</li></ul><p>前一段时间已经有了一点在前端突破的感觉，希望制定下的计划顺利完成，谋求再度突破。css在面试中基本没遇到什么太困难的问题，暂时先放缓。</p><p>不忘初心，砥砺前行！<br>我还是一样的天才少年!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;痛定思痛。我认为自己一个最大的优点就是能从每一次失败当中学习到东西，让失败变成一个有价值的事情，这样虽然失败其实也没有失败，因为从自身成长的角度而言，反而是收获了很多。能够和一线大佬进行两三个小时的’面试一对一辅导’,第一次面试在A家面到总监，这个成绩也还不算差。&lt;/p&gt;
&lt;p&gt;不要靠天赋成功，也不要靠运气成功，要让每一次成功都是一个必然，要让每一个方面的成功都能成为可能。事情的成功，应该是合理的方法下的必然。&lt;br&gt;
    
    </summary>
    
      <category term="感想" scheme="https://vevlins.github.io/categories/%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="面试" scheme="https://vevlins.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="腾讯" scheme="https://vevlins.github.io/tags/%E8%85%BE%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>看似简单的js题目引出的词法分析</title>
    <link href="https://vevlins.github.io/2018/03/30/%E7%9C%8B%E4%BC%BC%E7%AE%80%E5%8D%95%E7%9A%84js%E9%A2%98%E7%9B%AE%E5%BC%95%E5%87%BA%E7%9A%84%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>https://vevlins.github.io/2018/03/30/看似简单的js题目引出的词法分析/</id>
    <published>2018-03-30T03:50:10.000Z</published>
    <updated>2018-03-30T03:59:13.298Z</updated>
    
    <content type="html"><![CDATA[<p>今天在牛客网做练习题遇到了一个很简单的问题，疏忽大意做错了。本来做错也不值得写博文，但是看了下评论，还是觉得有很多人的看法并不正确。</p><pre><code class="javascript">var bb = 1;function fn(bb){    bb=2;    alert(bb);}fn(bb);alert(bb);</code></pre><p>弹出的结果是什么？多数人做的错误答案是2；2。认为这个题考察的是在函数内部如果不使用var声明的话实际上是创建了一个全局变量。</p><p>评论中出现了两种主要的原因分析，一是占70%的函数传递参数是按值传递派，二是20%的作用域链派。其余还有少许的各种各样看法。</p><p>当我反应过来的时候，很自然想到的是词法分析/AO分析。</p><p>第一步对参数相当于执行了<code>var bb=undefined;bb=1</code>，第二步是<code>bb=2</code>这一条，所以这个bb实际上还是局部变量！对于作用域链这个说法我想也是可以的，只是没有解释明白为什么局部有bb变量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在牛客网做练习题遇到了一个很简单的问题，疏忽大意做错了。本来做错也不值得写博文，但是看了下评论，还是觉得有很多人的看法并不正确。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;var bb = 1;
function fn(bb){
    bb=
      
    
    </summary>
    
    
      <category term="词法分析" scheme="https://vevlins.github.io/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
      <category term="作用域" scheme="https://vevlins.github.io/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>Eventloop机制和大量dom操作分时</title>
    <link href="https://vevlins.github.io/2018/03/30/setTimeout%E5%92%8Cjs%E7%9A%84eventloop%E6%9C%BA%E5%88%B6/"/>
    <id>https://vevlins.github.io/2018/03/30/setTimeout和js的eventloop机制/</id>
    <published>2018-03-30T03:24:32.000Z</published>
    <updated>2018-03-30T03:48:17.790Z</updated>
    
    <content type="html"><![CDATA[<p>本着多深入一点点的原则，今天看到了一个问题，是关于js如何实现精确计时，这个暂且不在这篇文章中讨论，想说的是在查阅资料的时候看到了一篇文章讨论了浏览器的运行机制。</p><p>文章提及了事件监听和setTimeout的定时器实际上是两个独立于js主线程的线程。这跟我之前看阮一峰的eventloop机制讲解的文章自己理解的内容有一点偏差。经过自己的思考，我认为阮一峰的博文有一定的问题，这个问题是出于其本身的错误还是没有明确细节使人产生了误解并不重要，重要的还是要确认自己的理解是否正确。</p><p>按照我目前的理解，这两个独立线程的说法是正确的，也就是说实际上setTimeout和事件监听机制确实可以说是实时根据判断条件捕获到了，真正出现延迟的是其回调函数！<br><a id="more"></a><br>eventloop的待办事件队列中存放的并非是setTimout函数，而是其回调函数！当时间条件判断成功后，这个队列就加入了其回调函数，但是由于js是单线程的，所以要等到执行栈中的同步任务处理完毕才能从队列中读取异步任务。</p><p>而我之前看完阮一峰的文章得出的结论是队列中存放的时setTimout，当执行栈空闲再去进行判断，虽然也能自圆其说，但实际上却是完全错误的！</p><p>温故而知新，确实如此。</p><p>基于以上理解和js主线程与gui线程互斥，我想在前端常见的一个大量数据加载并操作dom显示如何防止页面失去响应的问题也很好理解了。</p><p>之所以失去响应，原因是js引擎主线程和gui线程是互斥的。凡是互斥，应当都是他们之间存在可能同时改变的状态，因为js会进行dom操作，所以这跟页面渲染可能是出现冲突的。当大量dom操作发生时，gui需要等待js更新dom，所以此时页面失去了响应。</p><p>为了解决这个问题，我们还是需要回到js运行机制上。如何使js中dom操作的语句和gui线程不同时进行，那么也就不会出现冲突。核心思想是借助setTimeout进行分时操作，把插入dom的语句分开执行，这样运行栈中没有其他同步任务，而待办队列由于事件条件所以没有加入回调函数，整个js主线程是空闲的，gui线程就可以进行及时更新了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本着多深入一点点的原则，今天看到了一个问题，是关于js如何实现精确计时，这个暂且不在这篇文章中讨论，想说的是在查阅资料的时候看到了一篇文章讨论了浏览器的运行机制。&lt;/p&gt;
&lt;p&gt;文章提及了事件监听和setTimeout的定时器实际上是两个独立于js主线程的线程。这跟我之前看阮一峰的eventloop机制讲解的文章自己理解的内容有一点偏差。经过自己的思考，我认为阮一峰的博文有一定的问题，这个问题是出于其本身的错误还是没有明确细节使人产生了误解并不重要，重要的还是要确认自己的理解是否正确。&lt;/p&gt;
&lt;p&gt;按照我目前的理解，这两个独立线程的说法是正确的，也就是说实际上setTimeout和事件监听机制确实可以说是实时根据判断条件捕获到了，真正出现延迟的是其回调函数！&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="https://vevlins.github.io/categories/js/"/>
    
    
      <category term="setiTimeout" scheme="https://vevlins.github.io/tags/setiTimeout/"/>
    
      <category term="eventloop" scheme="https://vevlins.github.io/tags/eventloop/"/>
    
  </entry>
  
  <entry>
    <title>由一道奇奇怪怪的js加法引发的</title>
    <link href="https://vevlins.github.io/2018/03/29/%E7%94%B1%E4%B8%80%E9%81%93%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84js%E5%8A%A0%E6%B3%95%E5%BC%95%E5%8F%91%E7%9A%84/"/>
    <id>https://vevlins.github.io/2018/03/29/由一道奇奇怪怪的js加法引发的/</id>
    <published>2018-03-29T15:35:31.000Z</published>
    <updated>2018-03-30T12:09:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>当当～当当！</p><p><code>{}+[]和[]+{}</code>这个问题眼熟吗？</p><p>说实话第一眼看起来就像是什么老油条搜肠刮肚然后狡黠一笑写出来坑人的，仿佛是茴香豆的茴字有几种写法属于同一类的问题。</p><p>然而，本着通过奇奇怪怪问题学一点底层知识的想法，我还是看了下去。其中的原理还是有一定营养，从这一道题可以牵扯出js基本类型、valueOf、toString、通过Object.toString.call判断类型、包装类型、类型转换、原型链等一干知识，堪称大串联了。<br><a id="more"></a><br>我最初是在百度百家号(我也不知道这算什么鬼)看到了这个问题，在查阅资料的过程中有csdn、博客园一票博客网站，也有知乎、stackoverflow等问答社区。越发觉得社区质量高低对于知识的新鲜度和正确性有很大的影响。如何保证自己的知识始终新鲜，始终尽量正确，我认为这需要通过一套系统科学的学习方案，至于这个方案到底应该如何，我也在不停思考，目前所使用的最重要的三个技巧是多方查证+亲手实践+往里深入一点点。</p><p>这个问题，使我想到了之前一个遇到了同样的情况但最终没有在收藏夹找出来之前的历史，也从而使我意识到了这种碎片知识记录组织的重要性。</p><p>闲话不多说，我们来直接看。</p><h2 id=""><a href="#" class="headerlink" title="{}+[]"></a>{}+[]</h2><p>这种情况比较简单，对于{}块，js的解释器是倾向于认为这是一个block而非一个字面量的对象，所以前边的{}直接被忽略掉了，剩下的是+[],这里的加法相当于一个正负的正号，相当于把[]转换为一个数字，这里Number([])===0，最终结果是0。</p><blockquote><p>这里贺师俊的解释是对一个空数组执行正号运算，实际上就是把数组转型为数字。首先调用 [].valueOf() 。返回数组自身，不是primitive value，因此继续调用 [].toString() ，返回空字符串。空字符串转型为数字，返回0，即最后的结果。</p></blockquote><p><del>我目前并不理解把数组转型为数字为什么要经过这样的流程</del>，这个空字符串转型为数字0我认为才是这个问题的核心。因为对于非空数字如[1,2].valueOf()返回的是[1,2],接着toString()返回”1,2”，最后转型为数字的结果是NaN，从这个分析过程和空数组的对比可以发现实际上最根本的区别是Number(字符串)返回的过程。</p><p>至于通过Number进行强制类型转换，我找到了以下规则：</p><ul><li>如果是布尔值，true和false分别被转换为1和0。</li><li>如果是数字值，返回本身。</li><li>如果是null，返回0。</li><li>如果是undefined，返回NaN。</li><li>如果是字符串，遵循以下规则：<ul><li>如果字符串中只包含数字，则将其转换为十进制（忽略前导0）</li><li>如果字符串中包含有效的浮点格式，将其转换为浮点数值（忽略前导0）</li><li>如果是空字符串，将其转换为0</li><li>如果字符串中包含非以上格式，则将其转换为NaN</li></ul></li><li>如果是对象，则调用对象的valueOf()方法，然后依据前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，再次依照前面的规则转换返回的字符串值。</li></ul><p>现在再回头看看贺老的说法，是不是完全没毛病了？</p><p>再加一点补充，Boolean转换规则：</p><ul><li>String：非空字符串为true</li><li>Number：除0和NaN都为true</li><li>Object：除null外任何对象都为true</li></ul><p>再补充一点点，<code>==</code>判断时会进行类型转换，而<code>===</code>不会。</p><p>对于<code>==</code>而言，undefined和null相等。字符串和数值比较时需把字符串转换成数值。</p><p>对于<code>===</code>而言，值得注意的是NaN和谁包括其自身都不相等。</p><h2 id="-1"><a href="#-1" class="headerlink" title="[]+{}"></a>[]+{}</h2><p>上面提到了valueOf和toString，这里再来介绍下他们。</p><p>先看问题本身，实际上这个问题和上个问题还是有一定的区别的。这个问题考察js的加法怎么运行，而上个问题虽然出现了加法符号但是实际作为正号用途，所以我说实际上他们还是有一定区别。</p><p>想一想，加法对于数字类型和字符串类型似乎还比较好理解，其他类型比如对象和数组他们的加法似乎很难定义，js的内部在做加法的时候实际上是执行了一个隐式的类型转换的，它会把两边都转换成字符串或者数字，如果转换的结果两边有至少一个是字符串，结果为字符串，否则是数字相加。</p><p>这个转换过程靠的是valueOf和toString。</p><p>有文章提到内部有一个这样的运算方法ToPrimitive能够把复杂类型转换为基本类型。<br>当它的参数PreferredType为number时，先进行valueOf再进行toString；如果参数为string时，先进行toString再进行valueOf。如果没有指定这个参数，出了Date外，其他都按照number处理，也就是先valueOf。很简单的原则对不对，但是valueOf和toString都是什么样的规则呢？</p><p>网上有的地方对于这两者的返回值出现了一些冲突，于是我自行进行了验证。</p><h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h3><ul><li>Array，返回本身</li><li>Boolean，返回本身</li><li>Date，返回毫秒数</li><li>Function，返回本身</li><li>Number，返回本身。注意了，这里如果是直接1.valueOf是会报错的：SyntaxError: No identifiers allowed directly after numeric literal，这种语法不被支持，通过var a=1;a.valueOf()或者Number构造是可以的</li><li>Object，返回本身</li><li>String，返回本身</li></ul><p>在网上对于valueOf普遍的认为其返回了包装类型的原始值，当然，对于非包装类型的话它们返回本身，特别地是Date。从上述结果来看，这个结论是可信的。至于包装类型，又是另外一个话题了，在这里不多赘述，我曾在对包装类型进行类型判断时产生了很大困惑，最终查阅资料得以解决。以我之所见，掌握包装类型只需要两个重要的点，一是它的生存期，二时经验性得出的一个结论，凡是通过<code>.</code>进行访问的都是会调用包装类型，这点至少在类型判断上有奇效。</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><ul><li>Array，相当于执行了join(‘,’)操作</li><li>Boolean，返回”true”或者”false”</li><li>Date，返回日期的字符串表示，比如”Fri Mar 30 2018 00:33:31 GMT+0800 (CST)”</li><li>Function，返回函数定义的字符串</li><li>Number，返回数值的字符串，可以通过传递参数进行进制的转换</li><li>String，返回其值</li><li>Object，返回形如”[object ObjectName]”这样的字符串</li></ul><p>从toString的直观翻译来看，它就应该是把数据类型转换为字符串的方法，这跟实验结果确实契合。看到这个方法我想大多数人都会想到通过<code>Object.prototype.toString.call()</code>进行类型判断的操作，为什么会有这种方案，并且为什么要使用Object的而非使用自身的toString？</p><p>对于问题一，这种解决方案可以返回一个”[object ObjectName]”字符串，而ObjectName就是对象类型的名称。</p><p>对于问题二，通过上述例子，也可以猜得出来，这个toString应当是各个对象自己写的了，如果没有自己写，他会继承Object直接返回”[object Object]”。而对于Array这种，虽然自己定义了，但并不能表现自己的类型，所以也不能使用。</p><p>再回到问题本身，两边分别变成了””+”[object Object]”。结果不必多说了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当当～当当！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{}+[]和[]+{}&lt;/code&gt;这个问题眼熟吗？&lt;/p&gt;
&lt;p&gt;说实话第一眼看起来就像是什么老油条搜肠刮肚然后狡黠一笑写出来坑人的，仿佛是茴香豆的茴字有几种写法属于同一类的问题。&lt;/p&gt;
&lt;p&gt;然而，本着通过奇奇怪怪问题学一点底层知识的想法，我还是看了下去。其中的原理还是有一定营养，从这一道题可以牵扯出js基本类型、valueOf、toString、通过Object.toString.call判断类型、包装类型、类型转换、原型链等一干知识，堪称大串联了。&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="https://vevlins.github.io/categories/js/"/>
    
    
      <category term="valueof" scheme="https://vevlins.github.io/tags/valueof/"/>
    
      <category term="toString" scheme="https://vevlins.github.io/tags/toString/"/>
    
      <category term="原始类型" scheme="https://vevlins.github.io/tags/%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>文本溢出处理的正确姿势</title>
    <link href="https://vevlins.github.io/2018/03/29/%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"/>
    <id>https://vevlins.github.io/2018/03/29/文本溢出处理的正确姿势/</id>
    <published>2018-03-29T06:25:19.000Z</published>
    <updated>2018-03-29T07:55:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>在移动端自适应上，文本的溢出处理没出问题时不容易察觉，一旦出了问题却表现地很明显。当然，移动端对于文本的控制也要结合rem来达到各个平台统一的效果。</p><p>最近发现<code>text-overflow</code>的表现非常不可控(实际上是根本没学会)，有时生效有时无效，为了彻底解决这个问题，查阅了一番资料，最终整理如下。<br><a id="more"></a></p><h2 id="单行文本"><a href="#单行文本" class="headerlink" title="单行文本"></a>单行文本</h2><pre><code class="css">text-overflow:ellipsis;overflow: hidden;white-space:nowrap;//神之white-space有啥用呢？去掉之后你就会发现它可以竖向扩展，不过奇妙的是对于单独的一行溢出还是会显示出省略号，分析在下边</code></pre><p>这是最普遍的用法，但是在实际应用时很多人会发现并不起效果。这是因为如果想要生效，必须设置width，否则无法判断到底满不满足溢出的条件。需要使用block(相当于隐式设置了宽度)或者inline-block加width，另外absolute会使display隐式变为block，也可以收到同样的奇效。</p><h2 id="多行文本-webkit"><a href="#多行文本-webkit" class="headerlink" title="多行文本-webkit"></a>多行文本-webkit</h2><p>以上的方案只能适用于单行文本，如果想要指定多行溢出，需要借助于<code>-webkit-line-clamp</code>,完整的css如下。</p><pre><code class="css">text-overflow:ellipsis;overflow: hidden;display: -webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;</code></pre><h2 id="非webkit多行文本？"><a href="#非webkit多行文本？" class="headerlink" title="非webkit多行文本？"></a>非webkit多行文本？</h2><p>可是除去webkit和blink(需要注意blink目前与webkit使用同样的前缀-webkit)，其他的浏览器怎么实现呢？</p><p>张鑫旭提出了一个float+负margin的方案，我认为最根本的思路跟下面的基本一致。<br>我们可以通过一种比较笨的方案，具体的思路是通过after在文本的父元素上添加一个伪元素，absolute定位定到右下角，可是这样出现了三个问题：</p><p>一、怎么防止出现最后一行被横向拦腰截断<br>由于webkit私有属性，可以通过line-clamp控制行数我们不必担心这个问题，在其他浏览器中可以通过将height设置为line-height的整数倍避免这种情况。</p><p>二、怎样防止溢出区域字体被竖向截断<br>逃过了懒腰还没有逃过劈断，有一种方案是跟一类似的，我们只要控制好这块区域正好盖住整数倍的字宽就好了，不过还有一个问题就是单词的换行可能引起右侧不对齐，虽然我们的方案从盒子的角度来讲是真的在右下角判断溢出，但是给人的观感可能是稍微偏向右侧，为了防止这种行为，最好还是使用<code>word-break</code>强制地进行换行。</p><p>除此之外，还有常见的方案是把这个块的background-image设置为一个linear的渐变，达到左边缘模糊的效果，实现平稳过渡。</p><hr><p>延伸一下，关于word-break、word-wrap、hyphens实现换行。</p><p>简单说来，word-break:break-all可以控制是否单词内部拦腰截断，而word-wrap: break-word可以机智地实现根据单个单词断行。hyphens有点陌生，浏览器的支持仍然比较差，它可以像我们在书写英文一样加上一个连字符号。<br>另外white-space可能给人感觉也是用来实现同样的效果的，但是实际上他是控制原来的换行符如何工作的，是一种被动换行，而上述是一个主动换行。</p><p>三、最最重要的，怎么判断加不加这个溢出呢？</p><p>我们似乎没有任何可以判断是否溢出的方法（啪啪啪打脸了！）</p><p>来自segmentfault的方案，确实是没想到scrollWidth</p><pre><code class="javascript">$(selector).map(function() {    if (this.offsetWidth &lt; this.scrollWidth) {        // do whatever you want        //scrollWidth是原始的宽度，而offsetWidth是overflow：hidden之后的宽度    }});</code></pre><p>除了这种机智的方案，也可以通过计算字数和字体大小来判断，不过相比上面的方案，这种方法似乎没什么优势。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在移动端自适应上，文本的溢出处理没出问题时不容易察觉，一旦出了问题却表现地很明显。当然，移动端对于文本的控制也要结合rem来达到各个平台统一的效果。&lt;/p&gt;
&lt;p&gt;最近发现&lt;code&gt;text-overflow&lt;/code&gt;的表现非常不可控(实际上是根本没学会)，有时生效有时无效，为了彻底解决这个问题，查阅了一番资料，最终整理如下。&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="https://vevlins.github.io/categories/css/"/>
    
    
      <category term="文本溢出" scheme="https://vevlins.github.io/tags/%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>图片自适应的五种可能</title>
    <link href="https://vevlins.github.io/2018/03/29/%E5%9B%BE%E7%89%87%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E4%BA%94%E7%A7%8D%E5%8F%AF%E8%83%BD/"/>
    <id>https://vevlins.github.io/2018/03/29/图片自适应的五种可能/</id>
    <published>2018-03-28T18:58:31.000Z</published>
    <updated>2018-03-28T19:24:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在自适应问题上，图片的自适应可以说是最关键了。</p><p>在仿做小红书的过程中，我也遇到了这个问题，小红书作为一个商品展示性的社区，商品图片的自适应是很重要的。在放眼望去都是图片的页面里，一两个变形可能会极大地影响用户的感受。</p><p>我在两个地方遇到了图片适应的问题，一个是品牌精选的卡片，对于宽固定，图片高度不规则并且比容器本身要大的情况；还有一个是在做九宫格要求图片宽高一致。<br><a id="more"></a></p><h2 id="transform实现居中"><a href="#transform实现居中" class="headerlink" title="transform实现居中"></a>transform实现居中</h2><p>这是小红书官方采用的方案，设置外层<code>overflow:hidden</code>，然后将内部图片设置居中，多余的部分直接被隐藏。这种方案对于不能明确容器和待展示图片大小关系的情况时并不使用。</p><h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><p>主要应用到的是一个<code>background-size:cover</code>属性，这个属性可以使图片适应填满，多余的部分会被裁剪掉。</p><pre><code class="css">background-image:url();background-size: cover;background-posiiton:center;</code></pre><p>这种方案是目前使用范围最广泛，并且认为最理想的解决方案，但是张鑫旭的博客中对于这种方案提了一点问题：由于cover存在剪裁，所以在大小发生变化时展示出来的背景图区域也是不同的。这主要是因为视窗宽度变化时，高度没有等比例变化。对此他提出了本文最后的两种解决方案。</p><hr><p>一点延伸，在复习background属性时碰到了一个知识点。</p><p>background-clip和background-origin的可选值都是一样的，border-box、padding-box、content-box。那么他们的区别是什么？</p><p>简单来说，clip是规定了定位的区域，而origin只是定义了原点，也就是左上角。</p><p>另外对于border-box，如果填充的是图片，左边和上边实际上并不会填充进去。</p><h2 id="object-fit"><a href="#object-fit" class="headerlink" title="object-fit"></a>object-fit</h2><p><code>object-fit</code>基本上算是<code>background-size</code>的姐妹篇，不同的是，这个属性是对于置换元素而言而非背景图像。</p><h2 id="height使用vw单位"><a href="#height使用vw单位" class="headerlink" title="height使用vw单位"></a>height使用vw单位</h2><p>一言以蔽之：这主要是因为视窗宽度变化时，高度没有等比例变化。</p><h2 id="活用padding"><a href="#活用padding" class="headerlink" title="活用padding"></a>活用padding</h2><p>padding使用百分比单位时，是根据父级元素的宽度来确定的，所以通过设定padding，可以实现自适应，他们的宽高是同时变化的。</p><p>接下来是偷css大招。</p><pre><code class="css">.banner {    padding: 15.15% 0 0;    position: relative;}.banner &gt; img {    position: absolute;    width: 100%; height: 100%;    left: 0; top: 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在自适应问题上，图片的自适应可以说是最关键了。&lt;/p&gt;
&lt;p&gt;在仿做小红书的过程中，我也遇到了这个问题，小红书作为一个商品展示性的社区，商品图片的自适应是很重要的。在放眼望去都是图片的页面里，一两个变形可能会极大地影响用户的感受。&lt;/p&gt;
&lt;p&gt;我在两个地方遇到了图片适应的问题，一个是品牌精选的卡片，对于宽固定，图片高度不规则并且比容器本身要大的情况；还有一个是在做九宫格要求图片宽高一致。&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="https://vevlins.github.io/categories/css/"/>
    
    
      <category term="自适应" scheme="https://vevlins.github.io/tags/%E8%87%AA%E9%80%82%E5%BA%94/"/>
    
  </entry>
  
  <entry>
    <title>瀑布流实现方案探讨</title>
    <link href="https://vevlins.github.io/2018/03/28/%E7%80%91%E5%B8%83%E6%B5%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E6%8E%A2%E8%AE%A8/"/>
    <id>https://vevlins.github.io/2018/03/28/瀑布流实现方案探讨/</id>
    <published>2018-03-28T14:46:09.000Z</published>
    <updated>2018-03-30T11:58:53.248Z</updated>
    
    <content type="html"><![CDATA[<p>最近在仿小红书时又遇到了一个问题，就是笔记的瀑布流展示。</p><p>我采用的是张鑫旭在博客中提到的一种基于css3新的<code>column-count</code>特性的方案，这种方案本来是我最喜欢的，因为不需要额外的标签嵌套，也没有js参与布局，css写起来也是简洁又优雅。但是在使用safari调试页面时发现了一个奇怪的问题，使我最终决定放弃这种方案。<br><a id="more"></a></p><p>需要清楚的是safari和几乎全部的手机浏览器都是webkit内核，chrome原来使用的是webkit，但是后来脱离出来在webkit基础上研发了blink，所以这两种浏览器的表现是不完全一致的，由于chrome的调试工具比较合理，所以我习惯于在chrome下调试，没想到build出来发现在移动端出现了问题。</p><p>上文提到的<code>column-count</code>实现瀑布流的问题是在webkit下除第一竖栏之外其他栏的顶部会<strong><em>莫名其妙</em></strong>地掉下来一块。经过尝试，最终确定在webkit下的其它栏头顶会把上一栏最末尾自<code>border-bottom</code>以外的<code>padding-bottom</code>、<code>margin-bottom</code>乃至<code>box-shadow</code>全都显示出来，而原本应该包含这些的上一栏末尾都不会包含。</p><p>webkit对于<code>column-count</code>的渲染方式在我看来几乎等于是从第一栏底部腰斩。不仅如此，除第一竖栏之外的其他栏甚至在safari调试下根本无法被选中。</p><p>通过caniuse网站查询<code>column-count</code>的支持情况是很乐观的，但是事实还是给了我<strong><em>沉重一击</em></strong>。另外如果从瀑布流的角度来说，这种方案还有一个缺点就是它是竖向排列的，而用户观察是需要一横排一横排地获取新消息，所以这样的方案对于屏幕滚动实现懒加载和对于展示顺序有权重要求的情况并不适合，虽然可以额外通过js实现分块和重排序，但是<code>column-count</code>本来的优势-纯css代码简洁就已经不存在了。</p><p>除此之外，还有什么瀑布流的解决方案呢？</p><p>一、absolute定位打天下</p><p>始自鼻祖pinterest。pinterest的css让我神奇地想到了发牌。因为它的方式实在很像发牌的动作。原理很简单，通过绝对定位先将所有瀑布流中的元素归到左上角，然后根据屏幕宽度除以分栏数计算每一栏宽度，再计算每个图片的高度，通过transformX和transformY来指定其展示位置(向外发牌)。 </p><p>这样做的好处是原理清晰，理解上没什么难度，不会像<code>column-count</code>这样碰到奇奇怪怪的bug了。而且它的计算方式也是基于每一横排，对于控制显示权限和懒加载也很友好。缺点是需要大量的计算，不出所料，pinterest很鸡贼地没有根据页面宽度实现响应，因为窗口的宽度一变，不仅每一栏的宽度变化，为了防止图片变形，高度也要随之变化，所有元素都要重新计算一番。由于窗口变化触发重绘重排而在性能上造成的问题暂且不说，缩小后原本看到的内容也都滑倒上面去了。这对于客户而言很不友好，我记得曾经在使用某个网站时由于没有外接屏幕不得不缩放而遇到这样的问题，一变化就要重新<code>command+f</code>一番。虽然实现响应很酷，可是我们还是要明白窗口resize的情况下，进行响应是否真的有意义？</p><p>二、flexbox竖向布局</p><p>这是大漠在文章中提出的一种解决方案，思路也很清晰。所有的分栏通过一个flexbox控制横向排列，每个分栏里通过一个<code>flex-direction:column</code>控制分栏内部的竖向排列。这种方案我认为还是比较不错的，即避免了太复杂的计算，又没有太混乱的结构，懒加载向里填充新内容也不难。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在仿小红书时又遇到了一个问题，就是笔记的瀑布流展示。&lt;/p&gt;
&lt;p&gt;我采用的是张鑫旭在博客中提到的一种基于css3新的&lt;code&gt;column-count&lt;/code&gt;特性的方案，这种方案本来是我最喜欢的，因为不需要额外的标签嵌套，也没有js参与布局，css写起来也是简洁又优雅。但是在使用safari调试页面时发现了一个奇怪的问题，使我最终决定放弃这种方案。&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="https://vevlins.github.io/categories/css/"/>
    
    
      <category term="瀑布流" scheme="https://vevlins.github.io/tags/%E7%80%91%E5%B8%83%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>图集错落九宫格实现方案</title>
    <link href="https://vevlins.github.io/2018/03/27/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E5%9B%BE%E9%9B%86%E9%94%99%E8%90%BD%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    <id>https://vevlins.github.io/2018/03/27/小红书图集错落九宫格实现方案/</id>
    <published>2018-03-27T08:59:41.000Z</published>
    <updated>2018-03-29T07:52:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在用vue仿小红书的h5版，在界面上唯一比较让人头大的就是这个伪九宫格(不知道有没有专业的称呼，我就这样叫了)的图集了。</p><p>难点分析如下：</p><ul><li>实现图片宽高一致</li><li>尽量减少html标签</li><li>尽量不使用js</li><li>6n和12n情况下大图的左右位置不同</li><li>最后一部分凑不齐9块的排布方案</li></ul><a id="more"></a><p>小红书的效果如下：</p><p><img src="http://ozc9m7ly1.bkt.clouddn.com/www.xiaohongshu.com_page_brands_5a4384888000862471d1493d%28iPhone%206_7_8%20Plus%29.png" alt="小红书图集"></p><p>小红书自己的方案是把每一个伪九宫格区域分为竖向左右两块，通过js判断数量动态决定添加的顺序为大小还是小大。<br>这样做的缺点有二：</p><ul><li>增加了很多无关内容的标签嵌套</li><li>通过js进行计算导致逻辑繁琐</li></ul><p>尝试过标签嵌套和绝对定位加js，最终通过vw和float实现了效果。</p><pre><code class="css">.imgs div {  box-sizing: border-box;  background-size: cover;  width: 33.3vw;  height: 33.3vw;  padding: 1px;  background-clip:content-box;  background-position: center center;  float: left;}.imgs div:nth-of-type(6n-5){    width: 66.6vw;    float: right;    height: 66.6vw;}.imgs div:nth-of-type(12n-5){    float: left;}</code></pre><pre><code class="html">    &lt;div class=&quot;imgs&quot;&gt;        &lt;div v-for=&quot;img in imgs&quot; :style=&#39;`background-image: url(${img})`&#39;&gt;&lt;/div&gt;    &lt;/div&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在用vue仿小红书的h5版，在界面上唯一比较让人头大的就是这个伪九宫格(不知道有没有专业的称呼，我就这样叫了)的图集了。&lt;/p&gt;
&lt;p&gt;难点分析如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现图片宽高一致&lt;/li&gt;
&lt;li&gt;尽量减少html标签&lt;/li&gt;
&lt;li&gt;尽量不使用js&lt;/li&gt;
&lt;li&gt;6n和12n情况下大图的左右位置不同&lt;/li&gt;
&lt;li&gt;最后一部分凑不齐9块的排布方案&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="css" scheme="https://vevlins.github.io/categories/css/"/>
    
    
      <category term="九宫格" scheme="https://vevlins.github.io/tags/%E4%B9%9D%E5%AE%AB%E6%A0%BC/"/>
    
      <category term="图片" scheme="https://vevlins.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>ES6笔记</title>
    <link href="https://vevlins.github.io/2018/03/15/ES6%E7%AC%94%E8%AE%B0/"/>
    <id>https://vevlins.github.io/2018/03/15/ES6笔记/</id>
    <published>2018-03-15T14:54:40.000Z</published>
    <updated>2018-03-16T06:53:18.121Z</updated>
    
    <content type="html"><![CDATA[<p>根据阮一峰《ECMAScript 6 入门》整理。</p><h2 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><p>let是块级作用域变量，声明的变量只在<code>{}</code>内有效。<br>其适用于for循环内，特别需要注意的是：for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><pre><code class="javascript">for (let i = 0; i &lt; 3; i++) {  let i = &#39;abc&#39;;  console.log(i);}</code></pre><h4 id="没有变量提升"><a href="#没有变量提升" class="headerlink" title="没有变量提升"></a>没有变量提升</h4><pre><code class="javascript">// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2;</code></pre><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p><pre><code class="javascript">var tmp = 123;if (true) {  tmp = &#39;abc&#39;; // ReferenceError  let tmp;}</code></pre><a id="more"></a><h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><p>let在一个作用域内只能声明一次，对于函数形参，也不能在函数内部再次声明。</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>只读的常量。一旦声明，常量的值就不能改变。let所拥有的特性：块级作用域、没有变量提升、暂时性死区、不允许重复声明在const中也都适用。</p><h4 id="立即初始化"><a href="#立即初始化" class="headerlink" title="立即初始化"></a>立即初始化</h4><p>不允许<code>const foo</code>这种情况，否则会报错<code>// SyntaxError: Missing initializer in const declaration</code>.</p><h2 id="变量解构赋值"><a href="#变量解构赋值" class="headerlink" title="变量解构赋值"></a>变量解构赋值</h2><p>这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。如果解构不成功，变量的值就等于undefined。如果等号的右边不是可遍历的结构，那么将会报错。</p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>可以指定默认值。当本应该取到的值为undefind时候默认值生效。</p><pre><code class="javascript">let [foo = true] = [];foo // truelet [x, y = &#39;b&#39;] = [&#39;a&#39;]; // x=&#39;a&#39;, y=&#39;b&#39;let [x, y = &#39;b&#39;] = [&#39;a&#39;, undefined]; // x=&#39;a&#39;, y=&#39;b&#39;</code></pre><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>对象的属性是无序的，所以必须指定变量和属性同名，否则写成<code>foo:baz</code>用baz取出对象中foo的值。</p><pre><code class="javascript">let { foo: baz } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; };baz // &quot;aaa&quot;let obj = { first: &#39;hello&#39;, last: &#39;world&#39; };let { first: f, last: l } = obj;f // &#39;hello&#39;l // &#39;world&#39;</code></pre><h3 id="函数参数、字符串解构"><a href="#函数参数、字符串解构" class="headerlink" title="函数参数、字符串解构"></a>函数参数、字符串解构</h3><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="遍历接口"><a href="#遍历接口" class="headerlink" title="遍历接口"></a>遍历接口</h3><pre><code class="javascript">for (let codePoint of &#39;foo&#39;) {  console.log(codePoint)}</code></pre><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量，通过<code>${}</code>。</p><h4 id="保留换行和空格"><a href="#保留换行和空格" class="headerlink" title="保留换行和空格"></a>保留换行和空格</h4><p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p><h4 id="支持嵌入表达式和调用函数"><a href="#支持嵌入表达式和调用函数" class="headerlink" title="{}支持嵌入表达式和调用函数"></a>{}支持嵌入表达式和调用函数</h4><p>调用函数的情况：如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。</p><pre><code class="javascript">let x = 1;let y = 2;`${x} + ${y} = ${x + y}`// &quot;1 + 2 = 3&quot;`${x} + ${y * 2} = ${x + y * 2}`// &quot;1 + 4 = 5&quot;let obj = {x: 1, y: 2};`${obj.x + obj.y}`// &quot;3&quot;</code></pre><h4 id="支持多层嵌套"><a href="#支持多层嵌套" class="headerlink" title="支持多层嵌套"></a>支持多层嵌套</h4><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h3><p>常规方法：</p><pre><code class="javascript">if (typeof y === &#39;undefined&#39;) {  y = &#39;World&#39;;}</code></pre><pre><code class="javascript">function Point(x = 0, y = 0) {  this.x = x;  this.y = y;}const p = new Point();p // { x: 0, y: 0 }</code></pre><p>使用参数默认值时，函数不能有同名参数。</p><pre><code class="javascript">// 报错function foo(x, x, y = 1) {  // ...}</code></pre><p>每次都重新计算默认值表达式的值。</p><pre><code class="javascript">let x = 99;function foo(p = x + 1) {  console.log(p);}foo() // 100x = 100;foo() // 101</code></pre><h3 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h3><p>rest参数是真正的数组，而arguments虽然有length属性，可以用来遍历，但是并非真正的数组。rest参数之后不能再有其他参数。</p><pre><code class="javascript">// arguments变量的写法function sortNumbers() {  return Array.prototype.slice.call(arguments).sort();}// rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort();</code></pre><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ul><li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li><li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li><li>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li><li>不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</li></ul><h3 id="双冒号运算符"><a href="#双冒号运算符" class="headerlink" title="双冒号运算符"></a>双冒号运算符</h3><p>函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p><pre><code class="javascript">foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments);const hasOwnProperty = Object.prototype.hasOwnProperty;function hasOwn(obj, key) {  return obj::hasOwnProperty(key);}</code></pre><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>Object.assign方法实行的是浅拷贝，而不是深拷贝。</p><h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>Promise 是异步编程的一种解决方案。<br>Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p><pre><code class="javascript">let promise = new Promise(function(resolve, reject) {  console.log(&#39;Promise&#39;);  resolve();});promise.then(function() {  console.log(&#39;resolved.&#39;);});console.log(&#39;Hi!&#39;);// Promise// Hi!// resolved</code></pre><p>上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。</p><h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><p>Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p><h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><pre><code class="javascript">getJSON(&#39;/posts.json&#39;).then(function(posts) {  // ...}).catch(function(error) {  // 处理 getJSON 和 前一个回调函数运行时发生的错误  console.log(&#39;发生错误！&#39;, error);});</code></pre><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。</p><p>async 函数会返回一个Promise对象。按照我的理解，他可以把Promise的then链式调用写成同步代码的样式。</p><pre><code class="javascript">function takeLongTime(n) {    return new Promise(resolve =&gt; {        setTimeout(() =&gt; resolve(n + 200), n);    });}//基本函数function step1(n) {    console.log(`step1 with ${n}`);    return takeLongTime(n);}function step2(m, n) {    console.log(`step2 with ${m} and ${n}`);    return takeLongTime(m + n);}function step3(k, m, n) {    console.log(`step3 with ${k}, ${m} and ${n}`);    return takeLongTime(k + m + n);}//通过async实现async function doIt() {    console.time(&quot;doIt&quot;);    const time1 = 300;    const time2 = await step1(time1);    const time3 = await step2(time1, time2);    const result = await step3(time1, time2, time3);    console.log(`result is ${result}`);    console.timeEnd(&quot;doIt&quot;);}doIt();// 通过promise实现function doIt() {    console.time(&quot;doIt&quot;);    const time1 = 300;    step1(time1)        .then(time2 =&gt; {            return step2(time1, time2)                .then(time3 =&gt; [time1, time2, time3]);        })        .then(times =&gt; {            const [time1, time2, time3] = times;            return step3(time1, time2, time3);        })        .then(result =&gt; {            console.log(`result is ${result}`);            console.timeEnd(&quot;doIt&quot;);        });}doIt();</code></pre><pre><code class="javascript">async function timeout(ms) {  await new Promise((resolve) =&gt; {    setTimeout(resolve, ms);  });}async function asyncPrint(value, ms) {  await timeout(ms);  console.log(value);}asyncPrint(&#39;hello world&#39;, 50);</code></pre><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><pre><code class="javascript">//定义类class Point {  constructor(x, y) {    this.x = x;    this.y = y;  }  toString() {    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;  }}</code></pre><pre><code class="javascript">class ColorPoint extends Point {  constructor(x, y, color) {    super(x, y); // 调用父类的constructor(x, y)    this.color = color;  }  toString() {    return this.color + &#39; &#39; + super.toString(); // 调用父类的toString()  }}</code></pre><h2 id="model"><a href="#model" class="headerlink" title="model"></a>model</h2><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><pre><code class="javascript">import { stat, exists, readFile } from &#39;fs&#39;;</code></pre><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><pre><code class="javascript">// profile.jsvar firstName = &#39;Michael&#39;;var lastName = &#39;Jackson&#39;;var year = 1958;export {firstName, lastName, year};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据阮一峰《ECMAScript 6 入门》整理。&lt;/p&gt;
&lt;h2 id=&quot;let和const命令&quot;&gt;&lt;a href=&quot;#let和const命令&quot; class=&quot;headerlink&quot; title=&quot;let和const命令&quot;&gt;&lt;/a&gt;let和const命令&lt;/h2&gt;&lt;h3 id=&quot;let&quot;&gt;&lt;a href=&quot;#let&quot; class=&quot;headerlink&quot; title=&quot;let&quot;&gt;&lt;/a&gt;let&lt;/h3&gt;&lt;h4 id=&quot;块级作用域&quot;&gt;&lt;a href=&quot;#块级作用域&quot; class=&quot;headerlink&quot; title=&quot;块级作用域&quot;&gt;&lt;/a&gt;块级作用域&lt;/h4&gt;&lt;p&gt;let是块级作用域变量，声明的变量只在&lt;code&gt;{}&lt;/code&gt;内有效。&lt;br&gt;其适用于for循环内，特别需要注意的是：for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;for (let i = 0; i &amp;lt; 3; i++) {
  let i = &amp;#39;abc&amp;#39;;
  console.log(i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;没有变量提升&quot;&gt;&lt;a href=&quot;#没有变量提升&quot; class=&quot;headerlink&quot; title=&quot;没有变量提升&quot;&gt;&lt;/a&gt;没有变量提升&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;暂时性死区&quot;&gt;&lt;a href=&quot;#暂时性死区&quot; class=&quot;headerlink&quot; title=&quot;暂时性死区&quot;&gt;&lt;/a&gt;暂时性死区&lt;/h3&gt;&lt;p&gt;只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;var tmp = 123;

if (true) {
  tmp = &amp;#39;abc&amp;#39;; // ReferenceError
  let tmp;
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://vevlins.github.io/categories/javascript/"/>
    
    
      <category term="es6" scheme="https://vevlins.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>面试要点整理</title>
    <link href="https://vevlins.github.io/2018/03/14/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>https://vevlins.github.io/2018/03/14/面试要点整理/</id>
    <published>2018-03-14T05:49:45.000Z</published>
    <updated>2018-03-16T18:35:57.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="http相关"><a href="#http相关" class="headerlink" title="http相关"></a>http相关</h2><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>Https可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，即HTTP-SSL-TCP-IP,HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输.目前使用最广泛的是TLS 1.1、TLS 1.2。<br>HTTP面临的风险有：</p><ul><li>窃听风险</li><li>篡改风险</li><li>冒充风险</li></ul><p><img src="https://pic2.zhimg.com/80/v2-5e2241fae8b593ff7f3b3a308ef81c10_hd.jpg" alt=""><br><a id="more"></a></p><h3 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h3><p>当前使用的协议是http1.1,http2.0(RFC 7540)需要现代浏览器和web服务器的支持，其发展于SPDY。<br>其特点有：</p><ul><li>二进制分帧</li><li>压缩头部</li><li>多路复用（请求优先级）</li><li>服务器推送</li></ul><h3 id="http三次握手和四次挥手"><a href="#http三次握手和四次挥手" class="headerlink" title="http三次握手和四次挥手"></a>http三次握手和四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>第一次握手：主机A发送位码为syn＝1,随机产生seq number=x的数据包到服务器，客户端进入SYN_SEND状态，等待服务器的确认；主机B由SYN=1知道，A要求建立联机；</p><p>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number(主机A的seq+1),syn=1,ack=1,随机产生seq=y的包,此时服务器进入SYN_RECV状态;</p><p>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p><p>第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我也没有数据要发送了，可以进行关闭连接了；</p><p>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入CLOSE_WAIT状态；</p><p>第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><h3 id="常见的http头"><a href="#常见的http头" class="headerlink" title="常见的http头"></a>常见的http头</h3><h4 id="请求头："><a href="#请求头：" class="headerlink" title="请求头："></a>请求头：</h4><ul><li>Accept：接受的响应内容类型： text/plain</li><li>Cache-Control：是否使用缓存机制：no-cache</li><li>Origin：用于cors判断请求来源</li><li>Referer：访问的前一个页面</li><li>User-Agent：浏览器标识字符串</li></ul><h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><ul><li>Allow：允许的http方法</li><li>Content-Encoding：响应资源所使用的编码类型</li><li>ETag：资源版本的标识符</li><li>Expires：过期时间</li><li>Set-Cookie：设定cookie值</li></ul><h3 id="常见的http代码"><a href="#常见的http代码" class="headerlink" title="常见的http代码"></a>常见的http代码</h3><ul><li>1xx：临时响应</li><li>2xx：成功</li><li>3xx：重定向</li><li>4xx：客户端错误</li><li>5xx：服务器错误</li></ul><p>常见代码：</p><ul><li>301:永久移动</li><li>302：临时移动</li><li>304:未修改</li><li>400:不理解请求的语法</li><li>401:未授权</li><li>403:拒绝请求</li><li>405:不支持http方法</li><li>503:现在无法提供服务</li></ul><h3 id="http方法"><a href="#http方法" class="headerlink" title="http方法"></a>http方法</h3><ul><li>GET：获取资源</li><li>HEAD：获取报头</li><li>PUT：更新资源</li><li>POST：提交数据、新建资源</li><li>TRACE：检查http在过程中的变更</li><li>OPTIONS：返回支持的http方法</li><li>DELETE：删除页面</li><li>拓展方法如MOVE、COPY等</li></ul><h3 id="浏览器输入url到最终显示过程"><a href="#浏览器输入url到最终显示过程" class="headerlink" title="浏览器输入url到最终显示过程"></a>浏览器输入url到最终显示过程</h3><ul><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ul><h3 id="get请求和post请求的区别"><a href="#get请求和post请求的区别" class="headerlink" title="get请求和post请求的区别"></a>get请求和post请求的区别</h3><ul><li>get请求url长度受限制：url最大长度是2048个字符</li><li>get请求只能传输ascii字符</li><li>get请求可以显示在url中，所以安全性较差</li></ul><h3 id="服务器主动推送"><a href="#服务器主动推送" class="headerlink" title="服务器主动推送"></a>服务器主动推送</h3><ul><li>ajax轮询</li><li>Comet</li><li>Server-Sent</li><li>WebSocket</li></ul><h2 id="ajax相关"><a href="#ajax相关" class="headerlink" title="ajax相关"></a>ajax相关</h2><h3 id="ajax的优点"><a href="#ajax的优点" class="headerlink" title="ajax的优点"></a>ajax的优点</h3><ul><li>异步加载，优化用户体验</li><li>减少了与服务器之间不必要的传输</li><li>实现局部刷新</li><li>把服务器的负担转移到客户端</li></ul><h3 id="ajax的缺点"><a href="#ajax的缺点" class="headerlink" title="ajax的缺点"></a>ajax的缺点</h3><ul><li>不支持浏览器的历史记录</li><li>对搜索引擎的支持差</li></ul><h3 id="xml和json的比较"><a href="#xml和json的比较" class="headerlink" title="xml和json的比较"></a>xml和json的比较</h3><ul><li>xml解码难度大，json是js的子集，解析容易</li><li>xml占据了较早的市场</li><li>xml数据描述性更好</li><li>json体积小，传输速度快</li></ul><h3 id="js解析json的方法"><a href="#js解析json的方法" class="headerlink" title="js解析json的方法"></a>js解析json的方法</h3><ul><li>eval</li><li>new Function</li><li>JSON.parse</li></ul><h3 id="xmlhttprequest的readystate取值"><a href="#xmlhttprequest的readystate取值" class="headerlink" title="xmlhttprequest的readystate取值"></a>xmlhttprequest的readystate取值</h3><p>readyState属性 请求的状态 有5个可取值0=未初始化 ，1=正在加载，2=已加载，3=交互中，4=完成</p><h2 id="web安全相关"><a href="#web安全相关" class="headerlink" title="web安全相关"></a>web安全相关</h2><h3 id="csrf"><a href="#csrf" class="headerlink" title="csrf"></a>csrf</h3><p>csrf：跨站请求伪造。借助用户本地存储的cookie进行恶意的请求伪造。解决方案是检查其http-refer和制作token在请求中一并发送。</p><h3 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h3><p>xss：跨站脚本攻击。攻击者将恶意的js代码插入到页面中。分为基于反射的，基于存储的，基于dom的。解决方案是通过检查过滤用户输入的数据。</p><h3 id="clickjacking"><a href="#clickjacking" class="headerlink" title="clickjacking"></a>clickjacking</h3><p>clickjacking：设置iframe指向其他网站并且将其设置为透明，诱骗用户填入信息并触发请求。解决方案为在响应头中设置X-Frame-Options，可选为3个DENY、SAMEORIGIN、ALLOW-FROM。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="内容优化"><a href="#内容优化" class="headerlink" title="内容优化"></a>内容优化</h3><ul><li>减少http请求</li><li>dns预解析</li><li>减少iframe</li></ul><h3 id="服务器优化"><a href="#服务器优化" class="headerlink" title="服务器优化"></a>服务器优化</h3><ul><li>静态资源cookie隔离</li><li>cdn</li><li>gzip压缩</li><li>etag</li><li>避免空的图像src</li><li>开启缓存</li></ul><h3 id="js优化"><a href="#js优化" class="headerlink" title="js优化"></a>js优化</h3><ul><li>减少dom操作</li><li>减少长作用域链查找</li><li>在底部加载</li></ul><h3 id="css优化"><a href="#css优化" class="headerlink" title="css优化"></a>css优化</h3><ul><li>采用link而不是import</li><li>css放在顶部</li><li>尽量避免使用css表达式</li><li>减少选择器嵌套</li><li>减少css动画</li></ul><h3 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h3><ul><li>压缩图片</li><li>sprites</li><li>使用图标字体</li><li>懒加载</li></ul><h2 id="vue相关"><a href="#vue相关" class="headerlink" title="vue相关"></a>vue相关</h2><h3 id="mvvm和mvc"><a href="#mvvm和mvc" class="headerlink" title="mvvm和mvc"></a>mvvm和mvc</h3><ul><li>mvc：view-controller-model-view 单向传递</li><li>mvvm：view-viewmodel-model 双向传递</li></ul><h3 id="vue双向数据绑定"><a href="#vue双向数据绑定" class="headerlink" title="vue双向数据绑定"></a>vue双向数据绑定</h3><p>通过Object.defineProperty()实现数据劫持，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><ul><li>实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者。defineProperty</li><li>实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。createDocumentFragment</li><li>实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图。 订阅发布模式定义了一种一对多的关系，让多个观察者同时监听某一个主题对象，这个主题对象的状态发生改变时就会通知所有观察者对象</li><li>mvvm入口函数，整合以上三者</li></ul><h3 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h3><p>beforeCreate（创建前）,created（创建后），beforeMount(载入前),mounted（载入后）,beforeUpdate（更新前）,updated（更新后）,beforeDestroy（销毁前）,destroyed（销毁后）</p><h3 id="vue组件通信"><a href="#vue组件通信" class="headerlink" title="vue组件通信"></a>vue组件通信</h3><ul><li>父组件向子组件传递：父组件写在标签内，子组件通过通过props获取</li><li>子组件向父组件传递：<code>$emit</code>发送事件</li><li>兄弟组件传递：实例化一个第三方vue实例，<code>$emit</code>触发事件,<code>$on</code>接收事件</li></ul><h3 id="vuex的作用"><a href="#vuex的作用" class="headerlink" title="vuex的作用"></a>vuex的作用</h3><p>VueX 是一个专门为 Vue.js 应用设计的状态管理架构，统一管理和维护各个vue组件的可变化状态。当单独使用Vue.js,我们常常倾向于存储状态我们的组件内。也就是说,每个组件属于我们的应用程序状态,因此结果状态乱扔的到处都是。然而,有时一块状态需要由多个组件共享。常见的做法是让一个组件“发送”一些使用自定义事件系统其他组件。这种模式的问题是内部的事件流大组件树很快就变得复杂,通常很难原因时出现错误。</p><h3 id="vue1-0和vue2-0的区别是什么"><a href="#vue1-0和vue2-0的区别是什么" class="headerlink" title="vue1.0和vue2.0的区别是什么"></a>vue1.0和vue2.0的区别是什么</h3><ul><li>vue2.0代码必须包裹在一个根元素</li><li>vue2.0的生命周期发生了很大的变化</li></ul><h2 id="js相关"><a href="#js相关" class="headerlink" title="js相关"></a>js相关</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>基本数据类型：String、Number、Boolean、Undefined、Null、Symbol</li><li>引用类型：object、array、function</li></ul><h3 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h3><ul><li>typeof：对null返回object、无法判断array、date等类型</li><li>instanceof：检测两个对象是否实例关系</li><li>constructor：无法判断null和undefined，重写prototype之后constructor丢失默认为Object</li><li>Object.prototype.toString.call</li></ul><h3 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h3><p>惰性函数、柯里化、</p><h4 id="惰性载入函数"><a href="#惰性载入函数" class="headerlink" title="惰性载入函数"></a>惰性载入函数</h4><p>在浏览器功能检测中，函数的分支当第一次确定时就将分支内的函数作为返回值，这样就改变了这个函数。在以后加载中避免了每次都判断。</p><pre><code class="javascript">function addEvent (type, element, fun) {    if (element.addEventListener) {        addEvent = function (type, element, fun) {            element.addEventListener(type, fun, false);        }    }    else if(element.attachEvent){        addEvent = function (type, element, fun) {            element.attachEvent(&#39;on&#39; + type, fun);        }    }    else{        addEvent = function (type, element, fun) {            element[&#39;on&#39; + type] = fun;        }    }    return addEvent(type, element, fun);}</code></pre><h4 id="安全的类型检测"><a href="#安全的类型检测" class="headerlink" title="安全的类型检测"></a>安全的类型检测</h4><p>通过toString方法来检测传入参数的类型，以判断是否进行下一步操作。</p><pre><code class="javascript">  Object.prototype.toString.call(value)</code></pre><h4 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" class="headerlink" title="作用域安全的构造函数"></a>作用域安全的构造函数</h4><p>构造函数如果没有new，那么构造函数内部的this指向全局也就是window对象。先用instance判断一下this指向，如果不是指向构造函数，那么返回一个new实例化的对象。</p><pre><code class="javascript">function Person(name){    if(this instanceof Person){        this.name = name;    }else{        return new Person(name)    }}</code></pre><h4 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h4><p>它用于创建已经设置好了一个或者多个参数的函数，函数柯里化的基本方法和函数绑定是一样的，使用一个闭包返回一个函数。</p><pre><code class="javascript"> //普通的add版本function add(num1, num2){    return num1 + num2;}//第一个参数为5的add版本function curriedAdd5(num2){    return add(5, num2)}function curry(fn, context){//截取调用curry时候，除了fn,context,之后的所有参数    var args =[].slice.call(arguments,2);    return function(){//获取调用fn的所有参数        var totalArgs = args.concat([].slice.call(arguments));        return fn.apply(context, totalArgs);    }}var curriedAdd5 = curry(add, null, 5)</code></pre><h3 id="判断数组"><a href="#判断数组" class="headerlink" title="判断数组"></a>判断数组</h3><ul><li>instanceof</li><li>toString</li><li>constructor</li></ul><h3 id="箭头函数和this"><a href="#箭头函数和this" class="headerlink" title="箭头函数和this"></a>箭头函数和this</h3><p>箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。箭头函数的this其实就是在定义的时候就确定好的，以后不管怎么调用这个箭头函数，箭头函数的this始终为定义时的this。箭头函数没有arguments，可以用剩余参数代替。箭头函数不要再对象的方法中、作为构造函数、定义原型方法时使用。</p><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><ul><li>函数调用模式-全局调用：指向全局对象也就是window，包括在函数方法中嵌套的</li><li>方法调用模式：指向上层对象</li><li>构造器调用模式：通过new构造的this指向新的对象</li><li>apply、call、bind等调用模式：指向传入的对象</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>只有函数可以限定一个变量的作用范围，即函数才是变量的作用域。在ES6之前，JavaScript没有块级作用域(一对花括号{}即为一个块级作用域)，只有全局作用域和函数作用域。</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>函数在运行的瞬间，生成一个活动对象（Active Object），简称AO</p><ul><li>第一步：分析参数：函数接收形式参数，添加到AO的属性，并且这个时候值为undefine,即AO.age=undefined，接收实参，添加到AO的属性，覆盖之前的undefined</li><li>第二步：分析变量声明：如var age;或var age=18;如果上一步分析参数中AO还没有age属性，则添加AO属性为undefined，即AO.age=undefine，如果AO上面已经有age属性了，则不作任何修改</li><li>第三步：分析函数的声明：如果有function age(){}把函数赋给AO.age ,覆盖上一步分析的值</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>首字母大写，内部用this的函数，最后通过new来进行实例化。<br>构造函数的返回值有以下几种情况：</p><ul><li>没有返回值时返回实例化的对象。</li><li>返回值为基本数据类型时返回实例化的对象，用来两用函数。</li><li>返回值为引用类型时，返回该引用类型。</li></ul><h3 id="new的操作"><a href="#new的操作" class="headerlink" title="new的操作"></a>new的操作</h3><p>相当于以下步骤：</p><pre><code class="javascript">var obj = {}obj._proto_ = Co.prototyoeCo.call(obj)return obj</code></pre><h3 id="promise和async-await"><a href="#promise和async-await" class="headerlink" title="promise和async/await"></a>promise和async/await</h3><p>promise的三种状态pending（进行中）、fulfilled（已成功）和rejected（已失败）。两个参数resolve和reject。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。(MDN)用来访问另一个函数作用域链上的变量的函数。由于该变量被其他函数饮用所以内存回收机制导致其不会立即清除，也就是其定义时的上下文被记住，起到了记忆功能。</p><h3 id="js对象私有变量"><a href="#js对象私有变量" class="headerlink" title="js对象私有变量"></a>js对象私有变量</h3><ul><li>_开头的编码约定</li><li>基于闭包构造特权函数，缺点是无法挂载在prototype上，无法实现共享</li><li>强引用散列表</li><li>基于ES6的WeakMap</li></ul><h3 id="js垃圾回收机制"><a href="#js垃圾回收机制" class="headerlink" title="js垃圾回收机制"></a>js垃圾回收机制</h3><p>JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数。优化垃圾回收的主要思想是避免新建对象，而是尽量复用。比如delete obj的属性，而非new Object()。设置arr.length = 0而非 arr = []。</p><p>可能会导致内存泄漏的操作有：</p><ul><li>意外的全局变量</li><li>被遗忘的定时器或回调</li><li>没有清理的DOM元素引用</li><li>不恰当的闭包</li></ul><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><img src="https://pic1.zhimg.com/80/e83bca5f1d1e6bf359d1f75727968c11_hd.jpg" alt=""></p><h3 id="rhs和lhs"><a href="#rhs和lhs" class="headerlink" title="rhs和lhs"></a>rhs和lhs</h3><p>rhs为取值，lhs为赋值。<br>如果在rhs的所有嵌套的作用域查询中都无法找到该变量,js引擎就会抛出一个ReferenceError异常. ReferenceError是一个重要的异常.<br>相较之下， 当引擎执行 LHS 查询时， 如果在顶层（ 全局作用域） 中也无法找到目标变量，<br>全局作用域中就会创建一个具有该名称的变量， 并将其返还给引擎， 前提是程序运行在非 “ 严格模式” 下。</p><h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p>函数调用形成了一个栈帧。对象被分配在一个堆中，即用以表示一个大部分非结构化的内存区域。一个待处理的消息队列。当栈拥有足够内存时并且满足触发条件(如setTimeout)从队列中取出一个消息进行处理。一个 web worker 或者一个跨域的iframe都有自己的栈，堆和消息队列。两个不同的运行时只能通过 postMessage方法进行通信。如果后者侦听到message事件，则此方法会向其他运行时添加消息。</p><p>js所谓的单线程，是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个。不妨叫它主线程。实际上还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外，在此我们不做区分。不妨叫它们工作线程。</p><p>一个异步过程：主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定的动作(调用回调函数)。</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>HTTP 协议有一个缺陷：通信只能由客户端发起。HTTP 协议做不到服务器主动向客户端推送信息。WebSocket最大的特点就是服务器可以主动向服务器发送信息，客户端也可以向服务器端主动发送信息。SSE是单向推送，利用EventSource，content-type设置为text/event-stream。</p><p>特点有以下：</p><ul><li>建立在TCP之上</li><li>默认端口也是ws80和wss443，握手阶段采用http协议。</li><li>数据格式轻，性能开销小</li><li>可以发送文本和二进制文件</li><li>没有同源策略的限制</li></ul><p>客户端API：</p><ul><li>var ws = new WebSocket(‘ws://localhost:8080’);</li><li>webSocket.readyState 0=正在连接 1=连接成功 2=连接正在关闭 3=连接已经关闭</li><li>ws.onopen= function(){} 连接成功后的回调函数</li><li>ws.onclose = function(){} 连接关闭后的回调函数</li><li>onmessage 收到信息后 event.data instanceof ArrayBuffer || String</li><li>ws.send(‘your message’);</li><li>ws.bufferedAmount 还有多少字节没有发送完 判断是否发送完毕</li><li>ws.onerror </li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>原型链</li><li>构造函数</li><li>组合继承</li><li>原型式继承</li><li>寄生式继承</li><li>寄生组合式继承</li></ul><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ul><li>工厂模式</li><li>构造函数模式</li><li>原型模式</li><li>组合模式</li><li>动态原型模式</li><li>寄生构造模式</li><li>稳妥构造模式</li></ul><h3 id="js跨域"><a href="#js跨域" class="headerlink" title="js跨域"></a>js跨域</h3><p>同源策略要求三个相同：协议相同、域名相同、端口相同</p><ul><li>cors</li><li>图像ping</li><li>jsonp</li><li>iframe+document.domain：适用于主域相同而子域不同的情况，设置相同的domain，然后在a页面中创建b页面的iframe，获取ifr.contentDocument就可以操作b</li><li>iframe+location.hash:src指向目标，hash中带参数，目标页面处理之后设置一个src指向代理文件，代理文件通过parent.parent.location.hash向源文件传递参数，源文件通过hashchange事件获取hash</li><li>iframe+window.name:window.name2MB而且在页面切换后不会变，先iframe.src指向跨域地址，在onload时转向当前域下一空文件，之前取到的window.name依然不变</li><li>代理服务器</li><li>postmessage</li></ul><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><ul><li>comet</li><li>sse</li><li>websocket</li></ul><h3 id="多页面传参数"><a href="#多页面传参数" class="headerlink" title="多页面传参数"></a>多页面传参数</h3><ul><li>cookie轮询</li><li>localStorage和storage事件</li><li>websocket</li></ul><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝分两种情况，拷贝直接拷贝源对象的引用 和 源对象拷贝实例.对于第二种情况，常用方法为<code>Array.prototype.slice(), Array.prototype.concat(), jQury的$.extend({},obj)</code></p><pre><code>function shallowCopy(src) {  var dst = {};  for (var prop in src) {    if (src.hasOwnProperty(prop)) {      dst[prop] = src[prop];    }  }  return dst;}</code></pre><p>深拷贝后，两个对象，包括其内部的元素互不干扰。常见方法有JSON.parse(),JSON.stringify()，jQury的<code>$.extend(true,{},obj)</code>，lodash的<code>_.cloneDeep和_.clone(value, true)。</code>有两种解决方案：</p><pre><code>JSON.parse(JSON.stringify(test))</code></pre><pre><code>function clone(p,s){　　var s=s||{};　　for(var prop in p){　　　　if(typeof p[prop]==&#39;object&#39;){　　　　　　　　s[prop]=(p[prop].constructor===Array)?[]:{};//三元运算，将s[prop]初始化为数组或者对象　　　　　　　　clone(p[prop],s[prop])　　　　}　　　　else{　　　　　　s[prop]=p[prop];　　　　}};　　　　return s;};</code></pre><h3 id="js事件模型"><a href="#js事件模型" class="headerlink" title="js事件模型"></a>js事件模型</h3><h4 id="DOM0级模型"><a href="#DOM0级模型" class="headerlink" title="DOM0级模型"></a>DOM0级模型</h4><p>又称原始事件模型，事件不会传播，没有事件流的概念。事件绑定通过在html代码中直接写<code>onclick</code> 或者在js中通过<code>.onclick=xxx</code>实现，如果取消可以将其指向<code>null</code>。</p><h4 id="DOM2级模型"><a href="#DOM2级模型" class="headerlink" title="DOM2级模型"></a>DOM2级模型</h4><p>分为事件捕获阶段，事件处理阶段，事件冒泡阶段。通过    <code>addEventListener</code>和<code>removeEventListener</code>。<br>参数有三个：</p><ul><li>eventType指定事件类型(不要加on)</li><li>handler是事件处理函数</li><li>useCapture是一个boolean用于指定是否在捕获阶段进行处理，一般设置为false与IE浏览器保持一致。</li></ul><h4 id="IE事件模型"><a href="#IE事件模型" class="headerlink" title="IE事件模型"></a>IE事件模型</h4><p>事件处理和事件冒泡阶段。<br><code>attachEvent</code>和<code>detachEvent</code></p><h4 id="DOM事件模型和IE事件模型的区别"><a href="#DOM事件模型和IE事件模型的区别" class="headerlink" title="DOM事件模型和IE事件模型的区别"></a>DOM事件模型和IE事件模型的区别</h4><ul><li>event和window.event</li><li>target和srcElement</li><li>stopPropagation和cancelBubble</li><li>preventDefault和returnValue</li></ul><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>可以在全局最顶端声明，也可以在某个函数顶端声明。</p><ul><li>全局变量必须显式声明</li><li>禁止使用with语句</li><li>eval自己存在独立的作用域</li><li>禁止this指向全局对象</li><li>禁止删除变量</li><li>禁止重名</li></ul><h3 id="js模块化"><a href="#js模块化" class="headerlink" title="js模块化"></a>js模块化</h3><ul><li>无模块化：分js文件写script。缺点是污染全局作用域和依赖关系不明显。</li><li>CommonJS：CommonJS的核心思想就是通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口。用于node端，同步加载模块，不适用于浏览器端。</li><li>AMD：require.js。通过define来定义一个模块，然后使用require来加载一个模块。前置加载依赖。</li><li>CMD：sea.js，按需加载，依赖就近。</li><li>ES6模块化：import导入，export导出。</li></ul><h2 id="缓存和离线存储"><a href="#缓存和离线存储" class="headerlink" title="缓存和离线存储"></a>缓存和离线存储</h2><h3 id="http缓存"><a href="#http缓存" class="headerlink" title="http缓存"></a>http缓存</h3><ul><li>判断Cache-Control或者expires，如果未过期，直接读取http缓存文件，不发送http请求。</li><li>判断是否有etag，有则带上if-none-mathch发送请求，未修改返回304，修改返回200。</li><li>判断是否有last-modified，有则带上if-modified-since，有效返回200，无效返回304。</li></ul><p><img src="https://images2017.cnblogs.com/blog/621603/201709/621603-20170925162600417-90375901.png" alt=""><br><code>crtl+f5</code>可以强制刷新。</p><h3 id="session-cookie-localStorage-sessionStorage"><a href="#session-cookie-localStorage-sessionStorage" class="headerlink" title="session cookie localStorage sessionStorage"></a>session cookie localStorage sessionStorage</h3><ul><li><p>session和cookie<br>session存在服务器端，cookie存在浏览器端。cookie只能保存字符串类型，session通过类似于hashtable的数据结构存储任何类型的对象。cookie4kb，session无限制。session更安全。</p></li><li><p>localStorage sessionStorage<br>localStorage永久，sessionStorage仅在当前会话下有效，关闭浏览器窗口失效。存储都是5MB。都存在客户端，只能存文本类型。lcoalStorage的接口有getItem、setItem、removeItem、clear，另外存储时还会触发storage事件。</p></li></ul><h3 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h3><p><code>&lt;html manifest=&quot;demo_html.appcache&quot;&gt;</code></p><p>其分为三个部分：</p><ul><li>CACHE MANIFEST 缓存</li><li>NETWORK 不缓存</li><li>FALLBACK 无法访问时的回退</li></ul><p>window.applicationCache.status可以访问缓存状态，分别为：UNCACHED、IDLE、CHECKING、DOWNLOADING、UPDATEREADY、IDLE</p><p>离线缓存与传统浏览器缓存区别：</p><ul><li>离线缓存是针对整个应用，浏览器缓存是单个文件</li><li>离线缓存断网了还是可以打开页面，浏览器缓存不行</li><li>离线缓存可以主动通知浏览器更新资源</li></ul><h3 id="http缓存机制"><a href="#http缓存机制" class="headerlink" title="http缓存机制"></a>http缓存机制</h3><ul><li>Cache-Control：响应头表示了资源是否可以被缓存，以及缓存的有效期。</li><li>Etag：响应头标识了资源的版本，此后浏览器可据此进行缓存以及询问服务器。</li><li>Last-Modified：响应头标识了资源的修改时间，此后浏览器可据此进行缓存以及询问服务器。</li></ul><p>缓存策略三要素：</p><ul><li>缓存存储策略</li><li>缓存过期策略</li><li>缓存对比策略</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;http相关&quot;&gt;&lt;a href=&quot;#http相关&quot; class=&quot;headerlink&quot; title=&quot;http相关&quot;&gt;&lt;/a&gt;http相关&lt;/h2&gt;&lt;h3 id=&quot;https&quot;&gt;&lt;a href=&quot;#https&quot; class=&quot;headerlink&quot; title=&quot;https&quot;&gt;&lt;/a&gt;https&lt;/h3&gt;&lt;p&gt;Https可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，即HTTP-SSL-TCP-IP,HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输.目前使用最广泛的是TLS 1.1、TLS 1.2。&lt;br&gt;HTTP面临的风险有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;窃听风险&lt;/li&gt;
&lt;li&gt;篡改风险&lt;/li&gt;
&lt;li&gt;冒充风险&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-5e2241fae8b593ff7f3b3a308ef81c10_hd.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="面试" scheme="https://vevlins.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="前端" scheme="https://vevlins.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>从零制作网页样式库</title>
    <link href="https://vevlins.github.io/2018/03/07/%E4%BB%8E%E9%9B%B6%E5%88%B6%E4%BD%9C%E7%BD%91%E9%A1%B5%E6%A0%B7%E5%BC%8F%E5%BA%93/"/>
    <id>https://vevlins.github.io/2018/03/07/从零制作网页样式库/</id>
    <published>2018-03-07T00:45:22.000Z</published>
    <updated>2018-03-07T00:49:34.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="广告-amp-教材"><a href="#广告-amp-教材" class="headerlink" title="广告&amp;教材"></a>广告&amp;教材</h2><p><a href="https://github.com/Vevlins/ponyo" target="_blank" rel="noopener">GitHub - Vevlins/ponyo: 一个puputongtong的前端样式库</a></p><p>这是我自己做的练习，包含若干基本元素和组件的样式控制，压缩后的体积只有25kb，项目结构和代码都比较清晰，加上这一系列的文章，应该很好理解。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>不说废话，先来看看项目结构。最主要的部分是<code>src</code>/<code>dist</code>/<code>gulpfile.js</code>。</p><ul><li>src 是dist中的sass和pug编译之后的文件，为常规的css和html文件。</li><li>dist是sass文件和pug文件，sass是用来编写样式的工具，pug是为了编写实例网页，方便我们在开发中实时看到效果。</li><li>gulpfile.js是前端工程自动化的文件，通过gulp这个工具控制sass和pug的编译、css的压缩、浏览器自动刷新等。通过它，我们对源文件进行更改后按下<code>crtl+s</code>就可以在浏览器中看到更改后的样式，而不需要在命令行下手工编译，再在浏览器中刷新。</li></ul><a id="more"></a><p>至于src中sass文件的组成，在以下目录树中有相关注释说明。</p><pre><code>├── LICENSE├── README.md├── dist //pug和sass输出到dist目录│   ├── css│   │   ├── ponyo.css│   │   └── ponyo.min.css│   └── example│      └── index.html├── docs //托管在github pages的文档│   ├── index.html│   └── ponyo.min.css├── gulpfile.js //！重要，前端工程自动化文件├── package-lock.json├── package.json└── src    ├── css    │   ├── base//全局的基础样式控制    │   │   ├── base.scss    │   │   ├── normalize.scss    │   │   ├── print.scss    │   │   └── typography.scss    │   ├── component//由多个标签或者标签加脚本组成的组件    │   │   ├── alert.scss    │   │   ├── annimation.scss    │   │   ├── article.scss    │   │   ├── modal.scss    │   │   ├── navbar.scss    │   │   ├── notice.scss    │   │   ├── pagination.scss    │   │   ├── panel.scss    │   │   ├── progress.scss    │   │   ├── tab.scss    │   │   └── tip.scss    │   ├── element//单一标签    │   │   ├── badge.scss    │   │   ├── button.scss    │   │   ├── form.scss    │   │   ├── icon.scss    │   │   ├── img.scss    │   │   ├── list.scss    │   │   └── table.scss    │   ├── layout//布局上的样式    │   │   ├── grid.scss//栅格系统    │   │   └── util.scss    │   ├── ponyo.scss    │   └── variable.scss    ├── example    │   └── index.pug    └── js        ├── component        │   ├── alert.js        │   ├── collapse.js        │   ├── modal.js        │   ├── progress.js        │   └── tip.js        └── ponyo.js</code></pre><h2 id="gulp文件"><a href="#gulp文件" class="headerlink" title="gulp文件"></a>gulp文件</h2><p>越是庞大的工程，越要从头开始认真搭建骨架。</p><pre><code>gulp.task(&#39;build:scss&#39;, function () {    return gulp.src(&#39;./src/css/ponyo.scss&#39;)        .pipe(sourcemaps.init())//sourcemap,调试时用来定位压缩后的文件        .pipe(header(banner, { pkg : pkg } ))        .pipe(autoprefixer({//浏览器兼容问题，自动加私有前缀            browsers: [&#39;since 2010&#39;],            cascade: false        }))        .pipe(sass().on(&#39;error&#39;, sass.logError))        .pipe(sourcemaps.write())        .pipe(gulp.dest(&#39;./dist/css/&#39;));});gulp.task(&#39;compress:scss&#39;,function(){    return gulp.src(&#39;./src/css/ponyo.scss&#39;)    .pipe(header(banner, { pkg : pkg } ))    .pipe(autoprefixer({        browsers: [&#39;since 2010&#39;],        cascade: false    }))    .pipe(sass({outputStyle: &#39;compressed&#39;}).on(&#39;error&#39;, sass.logError))    .pipe(cleanCSS())//压缩css    .pipe(rename(&quot;ponyo.min.css&quot;))    .pipe(gulp.dest(&#39;./dist/css/&#39;));})gulp.task(&#39;build:pug&#39;,function(){    return gulp.src(&#39;./src/example/index.pug&#39;)        .pipe(pug().on(&#39;error&#39;,function(){}))        .pipe(gulp.dest(&#39;./dist/example/&#39;));})gulp.task(&#39;connect&#39;,function() {//在dist目录下创建一个本地服务器    connect.server({        root: &#39;dist/&#39;,        livereload: true    });})gulp.task(&#39;reload:html&#39;,[&#39;build:pug&#39;],function(){    return gulp.src(&#39;./dist/example/**/*.html&#39;)    .pipe(connect.reload());})gulp.task(&#39;reload:css&#39;,[&#39;build:scss&#39;,&#39;compress:scss&#39;],function(){    return gulp.src(&#39;./src/**/*.scss&#39;)    .pipe(connect.reload());})gulp.task(&#39;watch&#39;,[&#39;connect&#39;],function(){    gulp.watch(&#39;./src/**/*.scss&#39;,[&#39;reload:css&#39;]);//当css文件变化时服务器刷新    gulp.watch(&#39;./src/example/index.pug&#39;,[&#39;reload:html&#39;]);//当html文件变化时服务器刷新})gulp.task(&#39;default&#39;,[&#39;connect&#39;,&#39;watch&#39;])</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;广告-amp-教材&quot;&gt;&lt;a href=&quot;#广告-amp-教材&quot; class=&quot;headerlink&quot; title=&quot;广告&amp;amp;教材&quot;&gt;&lt;/a&gt;广告&amp;amp;教材&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Vevlins/ponyo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub - Vevlins/ponyo: 一个puputongtong的前端样式库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是我自己做的练习，包含若干基本元素和组件的样式控制，压缩后的体积只有25kb，项目结构和代码都比较清晰，加上这一系列的文章，应该很好理解。&lt;/p&gt;
&lt;h2 id=&quot;项目结构&quot;&gt;&lt;a href=&quot;#项目结构&quot; class=&quot;headerlink&quot; title=&quot;项目结构&quot;&gt;&lt;/a&gt;项目结构&lt;/h2&gt;&lt;p&gt;不说废话，先来看看项目结构。最主要的部分是&lt;code&gt;src&lt;/code&gt;/&lt;code&gt;dist&lt;/code&gt;/&lt;code&gt;gulpfile.js&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;src 是dist中的sass和pug编译之后的文件，为常规的css和html文件。&lt;/li&gt;
&lt;li&gt;dist是sass文件和pug文件，sass是用来编写样式的工具，pug是为了编写实例网页，方便我们在开发中实时看到效果。&lt;/li&gt;
&lt;li&gt;gulpfile.js是前端工程自动化的文件，通过gulp这个工具控制sass和pug的编译、css的压缩、浏览器自动刷新等。通过它，我们对源文件进行更改后按下&lt;code&gt;crtl+s&lt;/code&gt;就可以在浏览器中看到更改后的样式，而不需要在命令行下手工编译，再在浏览器中刷新。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="css" scheme="https://vevlins.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://vevlins.github.io/tags/css/"/>
    
      <category term="web" scheme="https://vevlins.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>见微知著,还是新式连坐?</title>
    <link href="https://vevlins.github.io/2018/03/05/%E8%A7%81%E5%BE%AE%E7%9F%A5%E8%91%97-%E8%BF%98%E6%98%AF%E6%96%B0%E5%BC%8F%E8%BF%9E%E5%9D%90/"/>
    <id>https://vevlins.github.io/2018/03/05/见微知著-还是新式连坐/</id>
    <published>2018-03-05T02:41:14.000Z</published>
    <updated>2018-03-05T02:48:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>合肥女教师阻拦高铁发车一事不断发酵，社会舆论也是甚嚣尘上。该教师的单位对其进行停职处分，央视专门进入地方教育局调查。而后《新京报》则发文表示应该保护该女子。（澎湃新闻，1月12号）</p></blockquote><p>对于此事，笔者关注了一个点，即该女子的教师身份和舆论因其身份而导致的师德缺失，不配做老师的观点。</p><p>据永红路小学官方网站信息显示，2009年罗海丽所带班级荣获区级优秀中队，2010年她又被评为区级德育先进个人，2011年被评委区级优秀班主任。她连续3年荣获辅导学生作文比赛金奖，2011年8月教授的阅读录像课获得安徽省录像课一等奖，2011年12月荣获区级语文教学能手。</p><p>对于这些荣誉，有好事者问大家如何看待，也有网友慷慨激昂，批评该女子完全没有师德，不配教育学生，应当彻底开除。还有部分人恶意揣测这些荣誉都是凭着心机争抢来的。<br><a id="more"></a><br>孙中山抛弃原配妻子，仍被称作国父；郭沫若圆滑世故，不失为一代大师；小鲜肉私生活不检，还有脑残粉吹捧。为何教师身份一出，就要被全体抨击，并且“见微知著”，判定其师德缺失，之前的荣誉也都不是正常途径获得的呢？这种有罪的推定与文革时期的全民狂热是否有些许相似？</p><p>各种成功学书籍都极力吹捧以小事识人。然后这种极端情况下情绪处理不当所做的行动当真就可以作为罪证，判人“死刑”吗？单从理性的角度思考，这件事情的发生是有特定条件的，即丈夫晚点但是列车还未离站，情急之下有不明智的举动当然仍是违法行为，但是这种情况下的表现难道就是单位生活中的她吗？先是从小见大批判这个人道德有问题，接着又是从大到小，质疑一切取得的身份、荣誉。这也能算是有理有据吗？这不是规则，这是暴力。</p><p>“师德”这两个字一出，好似千斤大鼎，压的人喘不过气来。不错，教师这种特殊职业需要有更严格的行为准则规范，但是凡事要讲求规则，上车晚点不应该蛮横无理阻拦列车，媒体和司法也不能因为一件事引起舆论关注就越权行使权力，迎合公众。</p><p>道德和职业是两部分，私德和职业道德也是两部分。教师行业特殊，但是也是对于其职业道德的要求，不应该收红包、歧视学生等。假如因为一个教师身份便要求是道德上的圣人，那身为政治家的孙中山，是不是因为抛弃原配也要被怀疑以后便会抛弃国家？身为文学家的郭沫若，是不是因为圆滑世故也要被怀疑令后代文人没有骨气？身为演员的小鲜肉，是不是因为私生活不检点也要被怀疑粉丝也会有样学样？</p><p>因为一件事，便定罪整个人，这不是新式连坐吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;合肥女教师阻拦高铁发车一事不断发酵，社会舆论也是甚嚣尘上。该教师的单位对其进行停职处分，央视专门进入地方教育局调查。而后《新京报》则发文表示应该保护该女子。（澎湃新闻，1月12号）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于此事，笔者关注了一个点，即该女子的教师身份和舆论因其身份而导致的师德缺失，不配做老师的观点。&lt;/p&gt;
&lt;p&gt;据永红路小学官方网站信息显示，2009年罗海丽所带班级荣获区级优秀中队，2010年她又被评为区级德育先进个人，2011年被评委区级优秀班主任。她连续3年荣获辅导学生作文比赛金奖，2011年8月教授的阅读录像课获得安徽省录像课一等奖，2011年12月荣获区级语文教学能手。&lt;/p&gt;
&lt;p&gt;对于这些荣誉，有好事者问大家如何看待，也有网友慷慨激昂，批评该女子完全没有师德，不配教育学生，应当彻底开除。还有部分人恶意揣测这些荣誉都是凭着心机争抢来的。&lt;br&gt;
    
    </summary>
    
      <category term="杂感" scheme="https://vevlins.github.io/categories/%E6%9D%82%E6%84%9F/"/>
    
    
      <category term="连坐" scheme="https://vevlins.github.io/tags/%E8%BF%9E%E5%9D%90/"/>
    
      <category term="师德" scheme="https://vevlins.github.io/tags/%E5%B8%88%E5%BE%B7/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础</title>
    <link href="https://vevlins.github.io/2018/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>https://vevlins.github.io/2018/01/11/计算机网络基础/</id>
    <published>2018-01-11T13:20:41.000Z</published>
    <updated>2018-01-11T13:21:43.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1><p>以谢希仁《计算机网络》第五版教学课件为参考整理.</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h1><ul><li>分组交换和电路交换的比较.</li><li>有关码元、信道、香农定律、奈式准则、信噪比的计算.</li><li>码分复用的计算</li><li>CRC</li><li>0比特填充</li><li>CSMA/CD 协议</li><li>网桥自学习转发表</li><li>VLAN</li><li>虚电路和数据报</li><li>ARQ、滑动窗口、停止等待</li><li>RIP和OSPF</li><li>IP分类、子网掩码计</li><li>TCP的握手和挥手</li><li>路由表更新</li><li>局域网组网配置</li></ul><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>计算机网络的定义:计算机网络是一些互相连接的、自治的计算机的集合</li><li>我们平时说的网络包含三个:电信网络、有线电视网络、计算机网络.</li><li>internet指多个计算机网络互联形成的网络.Internet是专有名词,指的是全球最大的计算机网络,前身是ARPANET.</li><li>计算机网络发展的三个阶段:第一个阶段是从单个网络 ARPANET 向互联网发展、第二个阶段是建成了三级结构的因特网(主干网、地区网、企业网)、第三阶段是多层次ISP结构的因特网.</li><li>万维网 WWW 在20世纪九十年代被CERN开发.</li><li>网络边缘端系统的通信方式有客户服务器方式(C/S)和对等方式(P2P).</li><li>路由器的作用是实现分组交换,这是网络核心部分最重要的功能.处理分组的方案是:先收入缓存,查找转发表找到下一跳,在适当的端口转发出去,.</li><li>电路交换的特点:面向连接.三个阶段:建立连接、通信、释放连接.由于计算机数据具有突发性导致通信线路利用率很低</li><li>分组交换的特点:在发送端将较长的豹纹划分成固定长度的数据段,添加首部,依次把分组传输到接收端.首部中含有地址等控制信息.交换机根据地址信息实现存储转发.收到分组后还原.</li><li>分组交换的优点:高效、灵活、迅速、可靠</li><li>分组交换的问题:分组在转发时需要时延,首部信息带来额外开销.</li><li>计算机网络的性能指标:<ul><li>比特:一个二进制数字.速率即数据率(data rate)或比特率(bit rate).</li><li>带宽:数字信道所能传送的“最高数据率”的同义语，单位是“比特每秒”，或 b/s (bit/s).</li><li>吞吐量:在单位时间内通过某个网络（或信道、接口）的数据量</li><li>传输时延: 发送数据时，数据块从结点进入到传输媒体所需要的时间.数据块长度（比特）/信道带宽（比特/秒）</li><li>传播时延:电磁波在信道中需要传播一定的距离而花费的时间.信道长度（米）/信号在信道上的传播速率（米/秒）</li><li>信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）</li></ul></li><li>网络协议的组成要素:语法、语义、同步</li><li>分层的好处:各层独立、灵活、结构可分割、便于实现和维护、促进标准化工作.</li><li>五层协议体系结构:物理层、数据链路层、网络层、运输层、应用层.</li><li>实体(entity) 表示任何可发送或接收信息的硬件或软件进程</li><li>协议是控制两个对等实体进行通信的规则的集合</li><li>协议是水平的,服务是垂直的</li><li>同一系统相邻两层的实体进行交互的地方，称为服务访问点 SAP </li></ul><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><ul><li>物理层的主要任务是确定与传输媒体接口的特性.如机械特性、电气特性、功能特性、过程特性.</li><li>中继器：又叫转发器，功能是将信号整形放大再转发出去，以消除信号的失真和衰减，扩大网络传输的距离，其原理是信号再生，仅作用于电气部分，不管数据中是否有错误</li><li>集线器(HUB):实质上是多端口的中继器，也工作在物理层。一口接受数据信号，将其整形放大转发到其他所有(输入端除外)处于工作状态的端口上，多口输入，冲突-&gt;无效</li><li>码元:在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形.</li><li>几种通信:单工通信、半双工通信(双方交替)、全双工通信</li><li>码元传输的速率越高，或信号传输的距离越远，在信道的输出端的波形的失真就越严重。 </li><li>奈氏准则:在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能.</li><li>信道的极限信息传输速率 C : C = W log2(1+S/N)  b/s ; W 为信道的带宽（以 Hz 为单位）；S 为信道内所传信号的平均功率；N 为信道内部的高斯噪声功率。  ·</li><li>导引型传播媒体:双绞线(屏蔽、无屏蔽)、同轴电缆、光缆(单模光纤、双模光纤)、非导引型传输媒体:无线传输介质:无线电波、微波、红外线、激光.</li><li>频分复用:所有用户在同样的时间占用频率不同的带宽资源.</li><li>时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙</li><li>波分复用：光的频分复用</li><li>码分复用:各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现</li><li>宽带接入技术:ADSL、HFC、FTTx</li></ul><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><ul><li>数据链路层使用的信道:点对点信道ppp协议和广播信道.</li><li>链路(link)是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。<br>一条链路只是一条通路的一个组成部分。数据链路(data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</li><li>数据链路的基本单位是帧.</li><li>数据链路层解决的三个问题是封装成帧、透明传输、差错控制</li><li>封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。</li><li>透明传输:原始数据中出现控制符如何转义.0比特填充.</li><li>循环冗余检验 CRC:现在 k = 6, M = 101001。设 n = 3, 除数 P = 1101，被除数是 2nM = 101001000。 模 2 运算的结果是：商 Q = 110101，余数 R = 001。把余数 R 作为冗余码添加在数据 M 的后面发送出去。发送的数据是：2nM + R 即：101001001，共 (k + n) 位。 </li><li>在数据后面添加上的冗余码称为帧检验序列 FCS . CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法 </li><li>CRC不能实现可靠传输,需要确认和重传机制.</li><li>0比特填充:连续五个1之后加入一个0.</li><li>数据链路层的两个子层:逻辑链路控制 LLC (Logical Link Control)子层<br>媒体接入控制 MAC (Medium Access Control)子层.</li><li>通信适配器,也就是网卡,作用是:进行串行/并行转换。对数据进行缓存。在计算机的操作系统安装设备驱动程序。实现以太网协议。 </li><li>CSMA/CD 协议: Carrier Sense Multiple Access with Collision Detection.“多点接入”表示许多计算机以多点接入的方式连接在一根总线上。“载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 “碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。只能实现半双工通信.</li><li>退避算法:发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。</li><li>在局域网中，硬件地址又称为物理地址，或 MAC 地址。 </li><li>集线器的优缺点:使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信,扩大了局域网覆盖的地理范围.缺点是碰撞域增大了，但总的吞吐量并未提高。如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。   </li><li>网桥:在数据链路层扩展局域网.根据 MAC 帧的目的地址对收到的帧进行转发.具有过滤帧的功能</li><li>网桥的优缺点: 过滤通信量。 扩大了物理范围。提高了可靠性。可互连不同物理层、不同 MAC 子层和不同速率（如10 Mb/s 和 100 Mb/s 以太网）的局域网。缺点:存储转发增加了时延。 在MAC 子层并没有流量控制功能。 具有不同 MAC 子层的网段桥接在一起时时延更大。网桥只适合于用户数不太多(不超过几百个)和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。  </li><li>网桥和集线器的不同:集线器转发时不进行检查,而网桥会进行CSMA/CD算法.</li><li>透明网桥:“透明”是指局域网上的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的。 </li><li>在网桥的转发表中写入的信息除了地址和接口外，还有帧进入该网桥的时间。</li><li>避免产生转发的帧在网络中不断地兜圈子的方法是生成树.</li><li>以太网交换机:以太网交换机的每个接口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，进行无碰撞地传输数据。 以太网交换机由于使用了专用的交换结构芯片，其交换速率就较高。    </li><li>虚拟局域网:虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组。这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的工作站是属于哪一个 VLAN。</li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><ul><li>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li><li>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。</li><li>IP协议.地址解析协议 ARP.(IP地址-&gt;物理地址)逆地址解析协议 RARP.网际控制报文协议 ICMP.网际组管理协议 IGMP都是网络层的协议,TCP、UDP是运输层的协议.</li><li>中间设备又称为中间系统或中继(relay)系统。物理层中继系统：转发器(repeater)。数据链路层中继系统：网桥或桥接器(bridge)。网络层中继系统：路由器(router)。网桥和路由器的混合物：桥路器(brouter)。网络层以上的中继系统：网关(gateway)。  </li><li>四类IP地址:A类0开头网络号8位,主机号24位.B类10开头网络号16位.C类110开头网络号24位.D类1110开头,多播地址.E类1111开头,保留地址.</li><li>IP分网络号和主机号:第一，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。第二，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。 </li><li>ARP:每一个主机都设有一个 ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。</li><li>ICMP:ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告.有两种报文种类:即 ICMP 差错报告报文和 ICMP 询问报文.Ping和Traceroute指令通过ICMP协议,不经过TCP或者UDP.</li><li>路由选择协议:内部网关协议 IGP( RIP 和 OSPF)和外部网关协议EGP( BGP-4)</li><li>RIP:是一种分布式的基于距离向量的路由选择协议,每一个路由器都要维护从它自己到其他每一个目的网络的距离记录.RIP 允许一条路径最多只能包含 15 个路由器.</li><li>RIP协议三个要点:仅和相邻路由器交换信息。 交换的信息是当前本路由器所知道的全部信息，即自己的路由表。 按固定的时间间隔交换路由信息，例如，每隔 30 秒。 </li><li>RIP的优缺点:优点:实现简单开销小,缺点是故障传输慢、网络规模小.</li><li>OSPF协议:是分布式的链路状态协议.OSPF 不用 UDP 而是直接用 IP 数据报传送。</li><li>OSPF的三个要点:向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。  </li><li>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫作区域。减少了整个网络上的通信量。</li><li>OSPF的五种分组类型:问候、数据库描述、链路状态请求、链路状态更新、链路状态确认.</li><li>MTU(路径最大传输单元)</li><li>CIDR:无类别域间路由.缓解了地址枯竭的趋势；控制甚至缩减了路由表的开销<br>分配IP地址的时候不再以类别来分，而是按照可变长的地址块来分配.基于可变长子网掩码VLSM.</li><li>拥塞控制:流量感知路由、准入控制、流量调节、负载丢弃、随机早期检测RED.</li><li>流量整形:漏桶、令牌桶.</li></ul><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><ul><li>应用进程之间的通信又称为端到端的通信。 运输层的一个很重要的功能就是复用和分用。应用层不同进程的报文通过不同的端口向下交到运输层，再往下就共用网络层提供的服务。IP协议提供主机之间的逻辑通信,而TCP/UDP提供进程之间的逻辑通信.</li><li>用户数据报协议 UDP  和  传输控制协议 TCP  ,TCP 要提供可靠的、面向连接的运输服务.</li><li>两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元 TPDU .</li><li>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能,不保证可靠交付，同时也不使用拥塞控制</li><li>TCP 是面向连接的运输层协议。每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。 TCP 提供可靠交付的服务。 TCP 提供全双工通信。面向字节流。  </li><li>TCP 连接的端点叫做套接字(socket)或插口。</li><li>ARQ:使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。这种可靠传输协议常称为自动重传请求ARQ (Automatic Repeat reQuest), ARQ 表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组 。</li><li>连续ARQ和回退NARQ.</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li>DNS:同时使用TCP和UDP:53</li><li>FTP:TCP:21</li><li>NFS:UDP</li><li>TFTP:UDP</li><li>TELNET:TCP:23</li><li>RPC:TCP</li><li>HTTP:TCP:80</li><li>SMTP:TCP:25,发邮件</li><li>POP3:TCP:110</li><li>IMAP:TCP</li><li>MIME:MIME类型是一种通知客户端其接收文件的多样性的机制:</li><li>DHCP:UDP</li><li>SNMP:UDP</li><li>POP3和IMAP的区别:POP3协议允许电子邮件客户端下载服务器上的邮件，但是在客户端的操作（如移动邮件、标记已读等），不会反馈到服务器上，比如通过客户端收取了邮箱中的3封邮件并移动到其他文件夹，邮箱服务器上的这些邮件是没有同时被移动的 。而IMAP提供webmail 与电子邮件客户端之间的双向通信，客户端的操作都会反馈到服务器上，对邮件进行的操作，服务器上的邮件也会做相应的动作。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络基础&quot;&gt;&lt;a href=&quot;#计算机网络基础&quot; class=&quot;headerlink&quot; title=&quot;计算机网络基础&quot;&gt;&lt;/a&gt;计算机网络基础&lt;/h1&gt;&lt;p&gt;以谢希仁《计算机网络》第五版教学课件为参考整理.&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目:&quot;&gt;&lt;/a&gt;题目:&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;分组交换和电路交换的比较.&lt;/li&gt;
&lt;li&gt;有关码元、信道、香农定律、奈式准则、信噪比的计算.&lt;/li&gt;
&lt;li&gt;码分复用的计算&lt;/li&gt;
&lt;li&gt;CRC&lt;/li&gt;
&lt;li&gt;0比特填充&lt;/li&gt;
&lt;li&gt;CSMA/CD 协议&lt;/li&gt;
&lt;li&gt;网桥自学习转发表&lt;/li&gt;
&lt;li&gt;VLAN&lt;/li&gt;
&lt;li&gt;虚电路和数据报&lt;/li&gt;
&lt;li&gt;ARQ、滑动窗口、停止等待&lt;/li&gt;
&lt;li&gt;RIP和OSPF&lt;/li&gt;
&lt;li&gt;IP分类、子网掩码计&lt;/li&gt;
&lt;li&gt;TCP的握手和挥手&lt;/li&gt;
&lt;li&gt;路由表更新&lt;/li&gt;
&lt;li&gt;局域网组网配置&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="network" scheme="https://vevlins.github.io/categories/network/"/>
    
    
      <category term="network" scheme="https://vevlins.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>Sass入门</title>
    <link href="https://vevlins.github.io/2018/01/09/Sass%E5%85%A5%E9%97%A8/"/>
    <id>https://vevlins.github.io/2018/01/09/Sass入门/</id>
    <published>2018-01-09T15:39:41.000Z</published>
    <updated>2018-01-09T15:40:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sass入门"><a href="#Sass入门" class="headerlink" title="Sass入门"></a>Sass入门</h1><p>编写css的工具主要有less、sass、stylus.具体谁优谁略很难定论.昨天看了下less,感觉有些用法理解起来很奇怪,而且功能上比sass稍弱一点,所以决定使用sass作为以后编写css的工具.sass和scss是一种东西的两种写法,scss与css的写法一致,而sass需要缩进,无分号等特性.以下介绍的是scss的写法.</p><h2 id="CIL"><a href="#CIL" class="headerlink" title="CIL"></a>CIL</h2><p>安装</p><pre><code class="bash">gem install sass</code></pre><p>编译风格:</p><ul><li>nested：嵌套缩进的css代码，它是默认值。</li><li>expanded：没有缩进的、扩展的css代码。</li><li>compact：简洁格式的css代码。</li><li>compressed：压缩后的css代码。</li></ul><p>监听:</p><pre><code class="bash">　// watch a file　　sass --watch input.scss:output.css　　// watch a directory　　sass --watch app/sass:public/stylesheets</code></pre><a id="more"></a><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>¥开头,声明方式如css属性一样使用<code>:</code>,如果嵌套在字符串中,比如放在属性名称中,需要写在#{}中.</p><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><p>支持计算.</p><h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><p>这里比较特别的是属性也是可以嵌套的.比如:</p><pre><code>font: {    family:xxx;    size:xxx;}</code></pre><p>另外&amp;可以在嵌套中表示上一层.</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p><code>/* */</code>样式的注视可以保留到css文件中,如果想要保留到压缩后,需要在一个*之后添加叹号,而<code>//</code>只会保留在sass文件中.</p><h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p><code>@extend 选择器</code>可以继承所选中选择器的所有属性.</p><h4 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h4><p>继承只能死板地复制粘贴过来,而mixin则更强大,它可以指定参数和缺省值.声明需要@mixin,使用需要@include</p><pre><code class="sass">　　@mixin left($value: 10px) {　　　　float: left;　　　　margin-right: $value;　　}</code></pre><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>通过@import可以插入外部文件,局部文件,也就是并不是想要编译出来的文件的用户名以下划线开始.</p><p>默认变量名.这是为了提高复用灵活性的一个特性,你可以在局部文件中声明变量时使用!default,在包含它的文件中另外声明覆盖掉这个default块.</p><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><p>这些高级功能可以说是sass与less抉择中最重要的一部分,虽然less也可以实现,但是其实现方案实在是太过诡异.</p><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>@if、@else用法和常规编程语言高度类似.</p><pre><code class="sass">　　@if lightness($color) &gt; 30% {　　　　background-color: #000;　　} @else {　　　　background-color: #fff;　　}</code></pre><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><pre><code class="sass">//for　　@for $i from 1 to 10 {　　　　.border-#{$i} {　　　　　　border: #{$i}px solid blue;　　　　}　　}//while　　$i: 6;　　@while $i &gt; 0 {　　　　.item-#{$i} { width: 2em * $i; }　　　　$i: $i - 2;　　}//each　　@each $member in a, b, c, d {　　　　.#{$member} {　　　　　　background-image: url(&quot;/image/#{$member}.jpg&quot;);　　　　}　　}</code></pre><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><p>使用@function可以编写函数,使用时实际产生的是retrn出来的语句.</p><pre><code class="sass">　　@function double($n) {　　　　@return $n * 2;　　}　　#sidebar {　　　　width: double(5px);　　}</code></pre><p>参考资料:</p><ul><li><a href="http://www.ruanyifeng.com/blog/2012/06/sass.html" target="_blank" rel="noopener">SASS用法指南 - 阮一峰的网络日志</a></li><li><a href="https://www.sass.hk/guide/" target="_blank" rel="noopener">https://www.sass.hk/guide/</a></li><li><a href="https://www.w3cplus.com/sassguide/" target="_blank" rel="noopener">sass入门 - sass教程</a></li><li><a href="https://www.w3cplus.com/preprocessor/sass-other-function.html" target="_blank" rel="noopener">Sass基础——Sass函数_Preprocessor, Sass, SCSS 教程_w3cplus</a></li><li><a href="https://www.sass.hk/skill/sass25.html" target="_blank" rel="noopener">Sass基础——颜色函数 | Sass中文网</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Sass入门&quot;&gt;&lt;a href=&quot;#Sass入门&quot; class=&quot;headerlink&quot; title=&quot;Sass入门&quot;&gt;&lt;/a&gt;Sass入门&lt;/h1&gt;&lt;p&gt;编写css的工具主要有less、sass、stylus.具体谁优谁略很难定论.昨天看了下less,感觉有些用法理解起来很奇怪,而且功能上比sass稍弱一点,所以决定使用sass作为以后编写css的工具.sass和scss是一种东西的两种写法,scss与css的写法一致,而sass需要缩进,无分号等特性.以下介绍的是scss的写法.&lt;/p&gt;
&lt;h2 id=&quot;CIL&quot;&gt;&lt;a href=&quot;#CIL&quot; class=&quot;headerlink&quot; title=&quot;CIL&quot;&gt;&lt;/a&gt;CIL&lt;/h2&gt;&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;gem install sass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译风格:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nested：嵌套缩进的css代码，它是默认值。&lt;/li&gt;
&lt;li&gt;expanded：没有缩进的、扩展的css代码。&lt;/li&gt;
&lt;li&gt;compact：简洁格式的css代码。&lt;/li&gt;
&lt;li&gt;compressed：压缩后的css代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;监听:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;　// watch a file
　　sass --watch input.scss:output.css
　　// watch a directory
　　sass --watch app/sass:public/stylesheets
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="sass" scheme="https://vevlins.github.io/categories/sass/"/>
    
    
      <category term="css" scheme="https://vevlins.github.io/tags/css/"/>
    
      <category term="sass" scheme="https://vevlins.github.io/tags/sass/"/>
    
  </entry>
  
  <entry>
    <title>操作系统总结</title>
    <link href="https://vevlins.github.io/2018/01/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/"/>
    <id>https://vevlins.github.io/2018/01/07/操作系统总结/</id>
    <published>2018-01-07T14:14:01.000Z</published>
    <updated>2018-01-07T14:16:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统总结"><a href="#操作系统总结" class="headerlink" title="操作系统总结"></a>操作系统总结</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>计算机系统的四个组成部分:计算机硬件、操作系统、系统程序与应用程序、用户.</li><li>计算机硬件包含什么:CPU、内存、IO.</li><li>什么是操作系统:管理计算机硬件的程序.</li><li>操作系统的目标:方便性、有效性、可扩充性、开放性.</li><li>操作系统的基本特征:并发性、共享性、虚拟性、异步性.</li><li>操作系统的基本类型:批处理系统、分时系统、实时系统</li><li>内核态和用户态的区别:内核态:控制计算机的硬件资源,并提供上层应用程序运行的环境.用户态:上层应用程序的活动空间,应用程序的执行依赖于内核提供的资源.内核态可以很好的保护硬件和资源的访问.<a id="more"></a></li><li>信号量semaphore的操作:P、V、wait.</li><li>管程Monitor:信号量机制功能强大，但使用时对信号量的操作分散，而且难以控制，读写和维护都很困难。因此后来又提出了一种集中式同步进程——管程。其基本思想是将共享变量和对它们的操作集中在一个模块中.管程就是代表共享资源的数据结构以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序共同构成的一个操作系统的资源管理模块.</li><li>多处理器调度:多处理器调度是根据处理器调度策略每次取出一个任务，将任务分配到处理器上运行的方法。多处理器调度包括给处理器分配进程、在单个处理器上是否使用多道程序技术、实际分派进程三个相关的方面。多处理器系统中线程调度通常有负载共享、成组调度、专用处理器分配、动态调度四种方式.非对称处理、对称多处理.</li><li>处理器亲和性:由于使缓存无效或重构的代价高，因而SMP努力的使一个进程在同一个处理器上运行，这被称为处理器亲和性.</li><li>负载平衡:负载平衡设法将工作负载平均地分配到SMP系统中的所有处理器上.</li><li>竞争范围:多对一和多对多模型上:PCS,进程竞争范围.一对一SCS,系统竞争范围.</li><li>用户态和内核态的转换:系统调用、异常、外围设备中断</li><li>多道程序设计:同时把多个作业放入内存交替执行,共享系统资源.可以减少CPU时间的浪费,增加系统吞吐量,提高系统效率.</li><li>中断和异常:中断也称为外中断,指来自CPU执行指令外部的事件,比如IO等,通常与当前程序无关.异常也称为内中断,是来自CPU执行指令内的事件,如非法操作码、地址越界等.</li><li>机制和策略:机制mechanism提供干什么,策略policy提供怎么做.</li><li>系统调用类别:进程控制、文件管理、设备管理、信息维护、通信</li><li>操作系统的结构:简单结构、分层结构、微内核结构、模块结构</li><li>原语是由若干条机器指令构成的一段程序，用以完成特定功能，这段程序在执行期间不可分割。即原语的执行不能被中断，原语操作具有原子性.</li><li>系统调用:指运行在用户态的程序向内核请求需要更高权限运行的服务。系统调用提供用户程序与操作系统之间的接口。<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2></li><li>进程:执行中的程序.</li><li>创建新进程的过程:分配进程号、分配空间、初始PCB、设置连接、创建或拓展其他数据结构.</li><li>非抢占和抢占的区别:让进程运行直到结束或阻塞的调度方式;允许将逻辑上可继续运行的在运行过程暂停的调度方式;抢占可以放置单一进程长时间占用cpu.</li><li>CPU调度的原因:提高CPU利用率;每个进程存在io、cpu两个过程,当进行io时可以进程进程调度以改善cpu利用率.</li><li>进程的三状态和无状态:运行、就绪、阻塞;创建、就绪、运行、等待、结束.</li><li>PCB的主要信息:进程状态、程序计数器、CPU寄存器、CPU调度信息.</li><li>长中短期调度:长期:哪一个程序被选中创建进程.中期:是否将进程调度内存.短期:哪个进程获得处理器资源.</li><li>上下文切换:CPU切换到另一个进程需要保存当前进程状态并且恢复另一个进程状态.上下文切换包括保存当前任务运行环境和恢复将要运行任务的运行环境.</li><li>共享内存和消息传递的比较:共享内存有公共状态,消息传递是显示传递.</li><li>线程:CPU使用的基本单位.包括线程ID、程序计数器、寄存器集合、栈.</li><li>线程和进程的比较:进程是系统资源分配的单位,线程的资源调度的单位.进程之间不能共享资源,进程有独立的地址空间,线程必须依赖进程存在.</li><li>多线程模型:一对一、多对一、多对多.</li><li>调度和分派的区别:调度是从就绪队列选择程序,分派是将进程加载到CPU.</li><li>常用调度算法:先到先服务、最短作业优先、最短剩余时间优先、轮转法、多级队列、多级反馈队列.</li><li>死锁:两个及以上的进程或者线程在执行过程中,因争夺资源造成的一种互相等待的现象.</li><li>死锁发生条件:互斥、占有等待、非抢占、循环等待.</li><li>临界资源和临界区:临界资源是每次仅允许一个进程访问的资源,每个进程中访问临界资源的那段代码称为临界区.</li><li>临界区问题解决的 三个条件:呼哧、空闲让进、有限等待.</li><li>调度基本特征:周转时间=作业完成时刻-到达时刻;带权周转时间=周转时间/服务时间;平均周转时间=作业周转总时间/昨夜个数;平均带权周转时间=带权周转总时间.<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2></li><li>内存交换的概念:把处于等待（阻塞）状态（或在CPU调度原则下被剥夺运行权利）的程序（进程）从内存移到辅存（外存），把内存空间腾出来，这一过程又叫换出。把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称为换入。中级调度（策略）就是釆用交换技术。</li><li>连续内存分配方案:单一连续分配、固定分区分配、动态分区分配.</li><li>内部碎片和外部碎片:内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间.外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域.</li><li>页表结构:层次页表、哈希页表、反向页表.</li><li>分页和分段的区别: (1) 页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率。段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。(2) 页的大小固定且由系统决定；而段的长度却不固定，决定于用户所编写的程序。(3) 分页的地址空间是一维的，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。</li><li>TLB:TLB是一个小的，虚拟寻址的缓存，其中每一行都保存着一个由单个PTE(Page Table Entry,页表项)组成的块。如果没有TLB，则每次取数据都需要两次访问内存，即查页表获得物理地址和取数据.</li><li>虚拟内存:虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换.</li><li>按需调页:只有程序执行需要时才载入页，那些从未访问的页不会调入到物理内存，也把这种页交换方式称为懒惰交换.</li><li>抖动问题:在请求分页存储管理中，刚被替换出去的页，立即又要被访问因无空,此时因无空闲内存，又要替换另一页，而后者又是下一次要被访问的页，于是系统需花费大量的时间忙于进行这种频繁的页面交换，致使系统的实际效率很低，这种现象称为抖动现象。一般都是由于置换算法不佳引起.</li><li>buffer和cache的区别:cache 是为了弥补高速设备和低速设备的鸿沟而引入的中间层，最终起到<strong>加快访问速度</strong>的作用。而 buffer 的主要目的进行流量整形，把突发的大数量较小规模的 I/O 整理成平稳的小数量较大规模的 I/O，以<strong>减少响应次数</strong>。</li><li>cache写机制:write through:CPU向cache写入数据时，同时向memory(后端存储)也写一份，使cache 和memory的数据保持一致。优点是简单，缺点是每次都要访问memory，速度比较慢.write back:cpu更新cache时，只是把更新的cache区标记一下，并不同步更新memory,(后端存储)。只是在cache区要被新进入的数据取代时，才更新memory.</li></ul><h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><ul><li>文件属性有哪些:名称、标识符、类型、位置、大小、保护等.</li><li>文件:记录在外存上的相关信息具有名称的集合.文件是逻辑外存的最小分配单位.</li><li>文件访问模型:顺序访问、直接访问、索引访问.</li><li>目录结构:单层结构、双层结构、树状结构.</li><li>目录的实现方式:线性、哈希.</li><li>数据分配方式:连续、链式、索引.</li><li>空闲空间管理方式:位向量、链表、组、计数.</li><li>磁盘调度算法:FCFS、SSTF、SCAN、C-SCAN、CLOCK.</li><li>DMA:直接内存访问（Direct Memory Access，DMA）是计算机科学中的一种内存访问技术。它允许某些电脑内部的硬件子系统（电脑外设），可以独立地直接读写系统内存，而不需中央处理器（CPU）介入处理.</li><li>DMA解决CPU同访问主存方式:(1)停止CPU访内存；(2)周期挪用；(3)DMA与CPU交替访问内存.</li><li>DMA使用方式:周期存取方式、直接存取方式、数据块传送方式.</li><li>DMA过程:1.告知设备驱动器2.设备驱动器告知磁盘3.磁盘初始化DMA传输.4.磁盘控制器向DMA传送字节5.DMA控制器向缓冲区传输.6.DMA中断CPU.</li></ul><ul><li>调度算法甘特图</li><li>信号量实现同步互斥</li><li>银行家算法</li><li>磁盘调度算法</li><li>页面置换算法</li><li>页表计算</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统总结&quot;&gt;&lt;a href=&quot;#操作系统总结&quot; class=&quot;headerlink&quot; title=&quot;操作系统总结&quot;&gt;&lt;/a&gt;操作系统总结&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;计算机系统的四个组成部分:计算机硬件、操作系统、系统程序与应用程序、用户.&lt;/li&gt;
&lt;li&gt;计算机硬件包含什么:CPU、内存、IO.&lt;/li&gt;
&lt;li&gt;什么是操作系统:管理计算机硬件的程序.&lt;/li&gt;
&lt;li&gt;操作系统的目标:方便性、有效性、可扩充性、开放性.&lt;/li&gt;
&lt;li&gt;操作系统的基本特征:并发性、共享性、虚拟性、异步性.&lt;/li&gt;
&lt;li&gt;操作系统的基本类型:批处理系统、分时系统、实时系统&lt;/li&gt;
&lt;li&gt;内核态和用户态的区别:内核态:控制计算机的硬件资源,并提供上层应用程序运行的环境.用户态:上层应用程序的活动空间,应用程序的执行依赖于内核提供的资源.内核态可以很好的保护硬件和资源的访问.
    
    </summary>
    
      <category term="os" scheme="https://vevlins.github.io/categories/os/"/>
    
    
      <category term="笔记" scheme="https://vevlins.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="https://vevlins.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="os" scheme="https://vevlins.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>游戏策划-社交网络</title>
    <link href="https://vevlins.github.io/2018/01/05/%E6%B8%B8%E6%88%8F%E7%AD%96%E5%88%92%E6%A1%88-%E8%AF%B4%E6%83%B3%E6%B3%95%E6%9B%B4%E5%90%88%E9%80%82-%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C/"/>
    <id>https://vevlins.github.io/2018/01/05/游戏策划案-说想法更合适-社交网络/</id>
    <published>2018-01-05T13:48:12.000Z</published>
    <updated>2018-01-07T14:27:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="游戏策划-《社交网络》"><a href="#游戏策划-《社交网络》" class="headerlink" title="游戏策划-《社交网络》"></a>游戏策划-《社交网络》</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><p>这不像是一个游戏策划案,更像是一篇对人性探讨的哲学向论文.</p><h2 id="游戏概述"><a href="#游戏概述" class="headerlink" title="游戏概述:"></a>游戏概述:</h2><p>人本思想随着资本主义遍布全球.一句“我不在乎大国崛起,我只在乎小民尊严.”将所有人引导到了一个现实问题的岔路口上:做一个精致的利己主义者还是一个仁义道德的卫道士?<br><a id="more"></a><br>马克思和恩格斯说:</p><blockquote><p>“资产阶级在它已经取得了统治的地方把一切封建的、宗法的和田园诗般的关系都破坏了。它无情地斩断了把人们束缚于天然首长的形形色色的封建羁绊,它使人和人之间除了赤裸裸的利害关系,除了冷酷无情的“现金交易’ ,就再也没有任何别的联系了。”</p><p>你的思考呢?人生路上,这个社交网络拓扑图的每一条关联,是愈发健壮还是妻离子散,面对突如其来的疾病、失业、不快,你和你的亲友又会发生怎样的变化.</p></blockquote><p>这是一款人生模拟游戏,但是它并没有华丽的视图,或者应该用更恰当的说法——不需要.没有每天起床吃饭,而是直接面对最冰冷的现实,人生路上最难处理的事情,就是人与人的关系.</p><p>在这款游戏当中,你会和其他玩家一起诞生在一个错综复杂的人际网络中,每个玩家会被包围在众多AI和真实玩家中,每一个抉择,都会影响你的一级关系网络甚至更多,也许是越发稳健,也许是越发远离.你将面临生离死别,做出一个个切身利益相关的选择,金币和声望值等评价也会做出动态调整.社会整体面临的选项也会与当前社会的整体导向相关.当游戏时间结束,全社会的整体趋向将会导致评价体系内各个指标权重的不同,进而得到你最终的得分.当然,如果你因为某些选择导致众叛亲离或者自身死亡,游戏也将终止,并且会即时进行结算.</p><p>我们不设定任何的价值导向.所有的成功和失败的定义,都由所有玩家一起构建.</p><p>这里到底是温暖的伊甸园还是现实的名利场抑或是悲惨的人间炼狱?这不是一个简单的游戏,这是一个冰冷的问题,你的选择也并非仅仅是游戏中的一个变量,而可能就是现实生活的一次演习.</p><p>这款游戏,将引发你对于社会关系的深层次思考.回到最初那个问题:做一个精致的利己主义者还是一个仁义道德的卫道士?</p><h2 id="游戏背景"><a href="#游戏背景" class="headerlink" title="游戏背景:"></a>游戏背景:</h2><p>游戏的直接起因是一系列的知乎问题:</p><ul><li>如何看待丈夫28岁肝癌晚期，妻子打掉腹中五个月的孩子并要求离婚这一事件:<a href="https://www.zhihu.com/question/265004594" target="_blank" rel="noopener">https://www.zhihu.com/question/265004594</a></li><li>岳父重病生活不能自理，我提出离婚，妻子不同意。我该怎么办:<a href="https://www.zhihu.com/question/66231199" target="_blank" rel="noopener">https://www.zhihu.com/question/66231199</a></li></ul><p>面对这之类的问题,我看到了两个点,其一是女权婊的双标,这与游戏无关不赘述,其二就是一群回答者的“冷静客观”的思考,当然,基于利益的思考.</p><p>我们应该如何抉择呢?究竟是关注个人利益本身还是遵守现有的道德秩序?精英们的“不要站在道德高地上对他人的行为指手画脚”到底是真理还是婊子立牌坊式的价值观扭曲呢?</p><p>我并非是一个哲学家,无法给出结论,我只能根据自己的思考写下我自己的结论:</p><p>知乎的精致利己主义真是让人恶心，资产阶级利益驱动下生怕别人耽误自己的丑陋嘴脸。女权婊的双标也是恶心。读多了仁义道德，便矫枉过正，反对世人认同的，支持世人不认同的，仿佛就是真理，精英群体们的理性思考，不过是取反吗？</p><p>一个人道德败坏并不可怕，可怕的事社会竟然批判起别人的道德来，还要啐一口唾沫，歪着嘴说要是你赶上这样的事。此所谓以小人之心度君子之腹也。键盘上的道德不一定是行动上的道德，但至少还意味着整个社会的道德还未崩塌。你诚然可以选择不道德的选项，但没必要大张旗鼓颠倒黑白。</p><p>至于道德不道德，或者单纯的好不好的界定，简单的很，我有我的道，你有你的道，和自己的父母以及认识自己的爱人友人之前都声明出来。我声明的是孝悌，是死生不离，仁义礼智信。你声明的是不要耽误我的利益。</p><p>道德是一种社会群体契约，它在保证整个社会的互信和共赢，它在用社会导向来保证有仁义信者，虽然难免吃亏，但是依然受人尊重，依然有人激赏，以后得到更多人的帮助。个人的精致利己，着眼于人这一个独立单位，而以利益作为最小单位之间的关联。这里是零和游戏，世人都不是傻子，你要求一分利，我便少一分利，自以为地沾沾自喜，旁人却唯恐避之不及。</p><p>恶魔不可怕，可怕的是人心向魔鬼，私德崩塌不可怕，可怕的是社会舆论扭曲。你说道德高地上的圣人何以强制别人？我说你何以强制我不得发声呢？你说赶明天你遇上就好了，我说我会伤心难过，绝不会背信弃义。</p><p>嗟乎！大阉之乱，缙绅而能不易其志者，四海之大，有几人欤？而五人生于编伍之间，素不闻诗书之训，激昂大义，蹈死不顾，亦曷故哉？且矫诏纷出，钩党之捕遍于天下，卒以吾郡之发愤一击，不敢复有株治；大阉亦逡巡畏义，非常之谋难于猝发，待圣人之出而投缳道路，不可谓非五人之力也。</p><p>道不同者，不相为谋。大家频率不在同一波段上，你看我对牛弹琴，我看你油盐不进，全无意义。不认同的，可以直接删除拉黑。</p><p>当然,我个人的选择只能代表我自己,社会中的每一个人如何做出自己的选择呢?所以我想到了做这一款模拟游戏.不设定任何立场.基于人自己的选择模拟整个社会关系的演变,为玩家做一个提醒.</p><p>但是,我仍然希望,所有人,能够在这个游戏里面最终发现一个充满仁义礼智信的道德社会比一个充满金钱利益的资本社会更合理.这是我的初心,但是并不会故意如此设定,因为它的定位不仅是一个以教育为目的,希望引发玩家思考的游戏,更是一场残酷的社会实验.</p><h2 id="目标用户"><a href="#目标用户" class="headerlink" title="目标用户:"></a>目标用户:</h2><p>从游戏的概述和背景可以看出来,这个游戏的定位有两个:一是引发群体性思考,二是借助玩家的选择完成一场宏大的社会实验.</p><p>为了完成目的,这个游戏的用户应当是包含普罗大众的,因为社会也是这个样子,但是由于深入了解这款游戏所需要的哲学思考甚至计算过多,对于游戏感兴趣的可能更多是有一定文化知识,对心理和社会关系有过思考的小众群体.</p><p>另外,这个模拟游戏也有很好的教育意义,可以引入到中小学生群体进行人际关系教育.或者引入到监狱等机构,辅助进行改造教育.需要注意的是,这个游戏原本没有最终设定或者导向.所以如果明确用于教育作用,需要初期引入行为引导或参数更改.</p><p>为了完成游戏本身的目的,我们需要引入AI角色,达到社会网络整体的真实和平衡.但是由于缺乏足够的覆盖面积广的真实玩家,这个游戏的第二个目的可能注定失败.这是一款注定失败的游戏,但如果它能引发一定的思考,也足够光荣.</p><h2 id="游戏机制"><a href="#游戏机制" class="headerlink" title="游戏机制:"></a>游戏机制:</h2><p>每一局100个玩家,可以利用手中虚拟货币在进入游戏前选择自己诞生的身份.</p><p>进入游戏后,将会以玩家为中心呈现出一个简单的网络关系拓扑图.游戏中包含一定的AI角色.各个真实玩家之间不会有一级关联.每个玩家(包括AI)视作一个节点.并且有初始化的评价指标:财富值、声望值、道德值.每个玩家(包括AI)之间的会有默认的关联值.</p><p>多人组队时每个队伍都会建立一个社群.如果没有组队,则会随机分配一个社群.</p><p>在不同的时间段会解锁玩家不同的操作.并且会随机引入各种情况.比如生病、破产,玩家的所有操作将会广播给一级关联人,也可以付出一定的金币来请求屏蔽这条信息的广播.每隔十分钟,所有一级关联人和社群的声望前三名可以对每个人进行评议,决定对其声望和道德的增减.</p><p>玩家可以进行的操作有:</p><ol><li>解除与任意一个人的关系.(包括出卖)</li><li>建立与任意一个人的关系(主动建立关系需要对方同意)</li><li>与其他人(个人或者群体)发生互动:工作、交流、交易、游戏、嘲讽、打架等.</li><li>退出和加入其他社群.</li></ol><p>面板提示玩家进行各种操作可以获得的指标提升或者衰减.并且会导致人际关联值的变化.</p><p>指标的提升和衰减与否和具体值要根据不同的身份所在的社群的声望值前三名进行商定并通过全体投票通过.</p><p>社群所有成员的实时加权分数将会累加作为社群势力.社群势力将会在每隔十分钟进行排名.排名前30%、20%、10%的社群可以调整指标,调整额度分别为3分、2分、1分.第一名的社群可以强制指定其他社群的一个指标,但是需要付出本社群的财富值.被指定社群可以接受或者抵制,接受则获得财富值,抵制则损失财富值.做指定的社群的声望值相应变化.</p><p>随着游戏的进行,玩家的性格将会得到固化,自己的评价指标将会显示给关系网络中关联度较高的人.在固化之后,如果做出与自己已经被判定的性格相反的事情会付出额外的代价并且削弱判定的力度.如果是与判定的性格相同的事情则会增加判定的力度.</p><p>玩家会收到系统推荐的相同性格的人并且建立关联.</p><p>注意!游戏支持直接交流和金钱交易,所以所有的评议等可能存在并不公正的情况.</p><p>当死亡、所有关联破裂、游戏计时结束任意一种情况发生时,将会结束玩家操作并实时计算分数,其指标将在整场游戏结束时按照最终权重再次结算.两者直接相加作为总得分.</p><p>游戏结束后将会展示玩家在游戏过程中的社群势力、性格及其转变、直接相关关系图及其转变、最终得分.作为玩家对局信息供所有人查看.</p><p>得分将折算为金币,可以用于选择之后游戏的身份选择.</p><h2 id="游戏特色"><a href="#游戏特色" class="headerlink" title="游戏特色:"></a>游戏特色:</h2><p>这款游戏注定是一个小众游戏.一个看起来怪异SIM游戏.但是怪异往往意味着特色鲜明.</p><ol><li>教育意义.从游戏脱离出来到引发群体思考.</li><li>玩家构建的社交网络整体趋势影响评分权重,没有硬性指标,游戏高度灵活</li><li>面临的问题现实,更有模拟游戏的意义.</li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记:"></a>后记:</h2><p>这不是一个普通的打怪升级酣畅淋漓的游戏,你可能体会不到快感,反而感受到压力,这压力不是我给予你,而是社会给予你,至于是游戏里的社会还是现实生活的社会,只有你自己知道答案.<br>这是一个危险的游戏.我会像三体的1379号监听员一样给叶文洁最初发出的信号同样的回复:“不要回答！不要回答！不要回答！”</p><p>这里到底是温暖的伊甸园还是现实的名利场抑或是悲惨的人间炼狱?这不是一个简单的游戏,这是一个冰冷的问题,你的选择也并非仅仅是游戏中的一个变量,而可能就是现实生活的一次演习.</p><p>这款游戏,将引发你对于社会关系的深层次思考.回到最初那个问题:做一个精致的利己主义者还是一个仁义道德的卫道士?<br>给我你的回答吧.</p><p>Give me your answer.</p><p>Me Votre réponse.</p><p>私にあなたの回答をください.</p><p>너의 대답.</p><p>Дай мне свой ответ.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;游戏策划-《社交网络》&quot;&gt;&lt;a href=&quot;#游戏策划-《社交网络》&quot; class=&quot;headerlink&quot; title=&quot;游戏策划-《社交网络》&quot;&gt;&lt;/a&gt;游戏策划-《社交网络》&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h2&gt;&lt;p&gt;这不像是一个游戏策划案,更像是一篇对人性探讨的哲学向论文.&lt;/p&gt;
&lt;h2 id=&quot;游戏概述&quot;&gt;&lt;a href=&quot;#游戏概述&quot; class=&quot;headerlink&quot; title=&quot;游戏概述:&quot;&gt;&lt;/a&gt;游戏概述:&lt;/h2&gt;&lt;p&gt;人本思想随着资本主义遍布全球.一句“我不在乎大国崛起,我只在乎小民尊严.”将所有人引导到了一个现实问题的岔路口上:做一个精致的利己主义者还是一个仁义道德的卫道士?&lt;br&gt;
    
    </summary>
    
      <category term="随感" scheme="https://vevlins.github.io/categories/%E9%9A%8F%E6%84%9F/"/>
    
    
      <category term="游戏" scheme="https://vevlins.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="感想" scheme="https://vevlins.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
      <category term="哲学" scheme="https://vevlins.github.io/tags/%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>CSS3完全学习笔记三:BFC、IFC、GFC、FFC</title>
    <link href="https://vevlins.github.io/2017/12/30/CSS3%E5%AE%8C%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89-BFC%E3%80%81IFC%E3%80%81GFC%E3%80%81FFC/"/>
    <id>https://vevlins.github.io/2017/12/30/CSS3完全学习笔记三-BFC、IFC、GFC、FFC/</id>
    <published>2017-12-30T15:07:58.000Z</published>
    <updated>2017-12-30T15:08:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS3完全学习笔记三-BFC、IFC、GFC、FFC"><a href="#CSS3完全学习笔记三-BFC、IFC、GFC、FFC" class="headerlink" title="CSS3完全学习笔记三:BFC、IFC、GFC、FFC"></a>CSS3完全学习笔记三:BFC、IFC、GFC、FFC</h1><p>//待续!</p><p>FC的全称是Formatting Contexts,格式上下文.它决定了其子元素如何定位以及和其他元素的关系.原本的FC有两种,也就是BFC和IFC,其余两者是CSS3中定义的.</p><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>Block Formatting Context 叫做“块级格式化上下文”.</p><p>规则如下:</p><ul><li>内部的盒子会在垂直方向，一个个地放置；</li><li>盒子垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的上下margin会发生重叠；</li><li>每个元素的左边，与包含的盒子的左边相接触，即使存在浮动也是如此；</li><li>BFC的区域不会与float重叠；</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此；</li><li>计算BFC的高度时，浮动元素也参与计算。</li></ul><p>产生原因如下:</p><ul><li>根元素-body</li><li>float的属性不为none；</li><li>position为absolute或fixed；</li><li>display为table-cell, table-caption, inline-block//?</li><li>overflow不为visible</li></ul><p>用处:</p><ul><li>清除浮动</li><li>解决margin重叠<a id="more"></a></li></ul><h2 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h2><p>Inline Formatting Context叫做“内联格式化上下文”.</p><p>规则如下:</p><ul><li>框会从包含块的顶部开始，一个接一个地水平摆放。</li><li>摆放这些框的时候，它们在水平方向上的外边距、边框、内边距所占用的空间都会被考虑在内。在垂直方向上，这些框可能会以不同形式来对齐：它们可能会把底部或顶部对齐，也可能把其内部的文本基线对齐。能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的行框。水平的margin、padding、border有效，垂直无效。不能指定宽高。</li><li>行框的宽度是由包含块和存在的浮动来决定。</li></ul><p>用处:</p><ul><li>水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。</li><li>垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</li></ul><h2 id="GFC"><a href="#GFC" class="headerlink" title="GFC"></a>GFC</h2><p>GridLayout Formatting Contexts叫做”网格布局格式化上下文“.</p><p>产生原因:</p><ul><li>display值为grid</li></ul><h2 id="FFC"><a href="#FFC" class="headerlink" title="FFC"></a>FFC</h2><p>Flex Formatting Contexts叫做”自适应格式化上下文”.Flex Box 由伸缩容器和伸缩项目组成。通过设置元素的 display 属性为 flex 或 inline-flex 可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。</p><p>产生原因:</p><ul><li>display值为flex或者inline-flex</li></ul><p>参考资料:</p><ul><li><a href="http://www.cnblogs.com/fsjohnhuang/p/5259121.html" target="_blank" rel="noopener">CSS魔法堂：重新认识Box Model、IFC、BFC和Collapsing margins - ^_^肥仔John - 博客园</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CSS3完全学习笔记三-BFC、IFC、GFC、FFC&quot;&gt;&lt;a href=&quot;#CSS3完全学习笔记三-BFC、IFC、GFC、FFC&quot; class=&quot;headerlink&quot; title=&quot;CSS3完全学习笔记三:BFC、IFC、GFC、FFC&quot;&gt;&lt;/a&gt;CSS3完全学习笔记三:BFC、IFC、GFC、FFC&lt;/h1&gt;&lt;p&gt;//待续!&lt;/p&gt;
&lt;p&gt;FC的全称是Formatting Contexts,格式上下文.它决定了其子元素如何定位以及和其他元素的关系.原本的FC有两种,也就是BFC和IFC,其余两者是CSS3中定义的.&lt;/p&gt;
&lt;h2 id=&quot;BFC&quot;&gt;&lt;a href=&quot;#BFC&quot; class=&quot;headerlink&quot; title=&quot;BFC&quot;&gt;&lt;/a&gt;BFC&lt;/h2&gt;&lt;p&gt;Block Formatting Context 叫做“块级格式化上下文”.&lt;/p&gt;
&lt;p&gt;规则如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部的盒子会在垂直方向，一个个地放置；&lt;/li&gt;
&lt;li&gt;盒子垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的上下margin会发生重叠；&lt;/li&gt;
&lt;li&gt;每个元素的左边，与包含的盒子的左边相接触，即使存在浮动也是如此；&lt;/li&gt;
&lt;li&gt;BFC的区域不会与float重叠；&lt;/li&gt;
&lt;li&gt;BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此；&lt;/li&gt;
&lt;li&gt;计算BFC的高度时，浮动元素也参与计算。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;产生原因如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根元素-body&lt;/li&gt;
&lt;li&gt;float的属性不为none；&lt;/li&gt;
&lt;li&gt;position为absolute或fixed；&lt;/li&gt;
&lt;li&gt;display为table-cell, table-caption, inline-block//?&lt;/li&gt;
&lt;li&gt;overflow不为visible&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用处:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;清除浮动&lt;/li&gt;
&lt;li&gt;解决margin重叠
    
    </summary>
    
      <category term="css" scheme="https://vevlins.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://vevlins.github.io/tags/css/"/>
    
      <category term="bfc" scheme="https://vevlins.github.io/tags/bfc/"/>
    
      <category term="ifc" scheme="https://vevlins.github.io/tags/ifc/"/>
    
  </entry>
  
  <entry>
    <title>CSS计数器:counter</title>
    <link href="https://vevlins.github.io/2017/12/27/CSS%E8%AE%A1%E6%95%B0%E5%99%A8-counter/"/>
    <id>https://vevlins.github.io/2017/12/27/CSS计数器-counter/</id>
    <published>2017-12-27T07:49:09.000Z</published>
    <updated>2017-12-27T07:51:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS计数器-counter"><a href="#CSS计数器-counter" class="headerlink" title="CSS计数器:counter"></a>CSS计数器:counter</h1><p>Css计数器是css2开始支持的,只能用在content属性上.//关于css3的变化,语焉不详.援引css88的说法是:<code>在CSS2.1中counter()只能被使用在content属性上。</code></p><p>Counter并非只是一个单纯的属性,而是包含了以下几部分:</p><ul><li>counter-reset</li><li>counter-increment</li><li>counter</li><li>counters</li></ul><h2 id="counter-reset"><a href="#counter-reset" class="headerlink" title="counter-reset"></a>counter-reset</h2><p>在某个地方声明一个计数器,并且最初值为0.</p><p>语法:</p><pre><code class="css">counter-reset: [&lt;user-ident&gt; &lt;integer&gt;?]+ | none</code></pre><p>可以看出来,这里还可以设置初始值,需要注意的是,0是不会被显示在第一个上的,真正的显示是1,类似于++i.</p><h2 id="counter-increment"><a href="#counter-increment" class="headerlink" title="counter-increment"></a>counter-increment</h2><p>计数器增加.</p><p>这里还可以设置增量的不长,取负值也是允许的,如<code>counter-increment: counter-name 2;</code></p><h2 id="counter"><a href="#counter" class="headerlink" title="counter"></a>counter</h2><p>用在content属性内,控制显示的值.</p><p>可以设置表现形式,比如字母,罗马数字,具体的选项有:decimal, decimal-leading-zero, lower-roman, upper-roman, lower-greek, lower-latin, upper-latin, armenian, georgian, lower-alpha, upper-alpha.</p><p>设置的语法为:<code>content: counter(counter-name, lower-roman);</code></p><p>你也可以设置更灵活的方法,比如设置为第1章,第2章.只需要在content中进行拼凑即可.<code>content: &quot;第 &quot; counter(section) &quot; 章:</code></p><h2 id="counters"><a href="#counters" class="headerlink" title="counters"></a>counters</h2><p>支持嵌套.</p><p>语法:</p><pre><code class="css">counters( &lt;ident&gt;, &lt;string&gt; [, [ &lt;counter-style&gt; | none ] ]? )</code></pre><p>如果想要支持嵌套,<code>content: counters(section, &quot;.&quot;);</code>,需要使用counters并且声明使用的分割符号.</p><hr><p>在查阅资料的时候,偶然发现了以下两个规则:<code>@counter-style</code>和<code>symbols()</code>,他们可以用来在list里显示自定义的前缀,但是只有firefox支持,所以不做进一步学习.</p><p>参考资料:</p><ul><li><a href="http://www.css88.com/archives/6394" target="_blank" rel="noopener">http://www.css88.com/archives/6394</a></li><li><a href="https://css-tricks.com/almanac/properties/c/counter-increment/" target="_blank" rel="noopener">counter-increment | CSS-Tricks</a></li><li><a href="https://css-tricks.com/almanac/properties/c/counter-reset/" target="_blank" rel="noopener">https://css-tricks.com/almanac/properties/c/counter-reset/</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Counters" target="_blank" rel="noopener">使用CSS计数器 - Web开发者指南 | MDN</a></li><li><a href="https://www.quackit.com/css/functions/css_counters_function.cfm" target="_blank" rel="noopener">CSS counters() Function</a></li><li><a href="https://www.quackit.com/css/functions/css\_symbols_function.cfm" target="_blank" rel="noopener">https://www.quackit.com/css/functions/css\_symbols_function.cfm</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSS计数器-counter&quot;&gt;&lt;a href=&quot;#CSS计数器-counter&quot; class=&quot;headerlink&quot; title=&quot;CSS计数器:counter&quot;&gt;&lt;/a&gt;CSS计数器:counter&lt;/h1&gt;&lt;p&gt;Css计数器是css2开始支持的,只能用在c
      
    
    </summary>
    
      <category term="css" scheme="https://vevlins.github.io/categories/css/"/>
    
    
      <category term="笔记" scheme="https://vevlins.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="css" scheme="https://vevlins.github.io/tags/css/"/>
    
      <category term="counter" scheme="https://vevlins.github.io/tags/counter/"/>
    
  </entry>
  
  <entry>
    <title>CSS3完全学习笔记二: 属性全解</title>
    <link href="https://vevlins.github.io/2017/12/26/CSS3%E5%AE%8C%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%B1%9E%E6%80%A7%E5%85%A8%E8%A7%A3/"/>
    <id>https://vevlins.github.io/2017/12/26/CSS3完全学习笔记二-属性全解/</id>
    <published>2017-12-26T15:10:01.000Z</published>
    <updated>2017-12-27T07:51:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS3完全学习笔记二-属性全解"><a href="#CSS3完全学习笔记二-属性全解" class="headerlink" title="CSS3完全学习笔记二: 属性全解"></a>CSS3完全学习笔记二: 属性全解</h1><p>对于目前没有主流浏览器支持的属性和一些需要特别学习的属性,在这篇笔记中没有学习.</p><h2 id="动画属性"><a href="#动画属性" class="headerlink" title="动画属性"></a>动画属性</h2><h3 id="keyframes"><a href="#keyframes" class="headerlink" title="@keyframes"></a>@keyframes</h3><p>使用@keyframes规则，你可以创建动画。<br>创建动画是通过逐步改变从一个CSS样式设定到另一个。指定的变化时发生时使用％，或关键字”from”和”to”，这是和0％到100％相同。</p><p>语法:</p><pre><code class="css">@keyframes animationname {keyframes-selector {css-styles;}}</code></pre><a id="more"></a><p>值:</p><ul><li>animationname    必需的。定义animation的名称。</li><li>keyframes-selector    必需的。动画持续时间的百分比。合法值：0-100%;from (和0%相同);to (和100%相同)</li><li>css-styles    必需的。一个或多个合法的CSS样式属性</li></ul><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p>动画复合属性.</p><p>语法:</p><pre><code class="css">animation: name duration timing-function delay iteration-count direction fill-mode play-state;</code></pre><p>值:</p><ul><li>animation-name</li><li>animation-duration :时间,s或者ms</li><li>animation-timing-function:速度曲线;linear; ease;ease-in;ease-out;ease-in-out;cubic-bezier(n,n,n,n)</li><li>animation-delay:延迟</li><li>animation-iteration-count:播放次数,infinite表示无限次</li><li>animation-direction:是否反向;normal;reverse; alternate;alternate-reverse</li><li>animation-fill-mode//?不理解;none;forwards; backwards; both</li><li>animation-play-state: 运行或者暂停.paused;running</li></ul><h2 id="背景属性"><a href="#背景属性" class="headerlink" title="背景属性"></a>背景属性</h2><h3 id="background"><a href="#background" class="headerlink" title="background"></a>background</h3><p>背景复合属性.</p><p>语法:</p><pre><code class="css">ackground:bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit;</code></pre><p>值:</p><ul><li>background-color:默认情况下是transparent<blockquote><p>合法的颜色值有:十六进制、rgb、rgba、hsl、hsla、浏览器定义颜色名称</p></blockquote></li><li>background-position:起始位置.可以用百分比、css单位、left、top等值<blockquote><p>注意对于这个工作在Firefox和Opera，background-attachment必须设置为 “fixed（固定）”.<br>关于css长度单位额外进行学习.</p></blockquote></li><li>background-size:背景图片大小。length:宽度-高度,未设置的为auto; percentage; cover(保持横纵比的最小); contain(保持横纵比的最大).这里可以想象正方形盒子和长方形图片.</li><li>background-repeat:repaat、repeat-x、repeat-y、repeat-y、inherit</li><li>background-origin:定位;padding-box;border-box;content-box;//设置repeat为no-repeat和position时可以看出效果</li><li>background-clip:背景绘制区域;border-box;padding-box;content-bo</li><li>background-attachment:是否固定:scroll、fixed</li><li>background-image:背景图:<blockquote><p>提示：请设置一种可用的背景颜色，这样的话，假如背景图像不可用，可以使用背景色带代替。</p></blockquote></li></ul><h2 id="边框和outline属性"><a href="#边框和outline属性" class="headerlink" title="边框和outline属性"></a>边框和outline属性</h2><h3 id="border"><a href="#border" class="headerlink" title="border"></a>border</h3><p>边框复合属性.</p><p>值:</p><ul><li>border-width: thin、medium、thick、length</li><li>border-style:none;hidden;dotted;dashed;solid;double;groove; ridge; inset;outset<blockquote><p>hidden:与 “none” 相同。不过应用于表时除外，对于表，hidden 用于解决边框冲突。//边框冲突另外学习</p></blockquote></li><li>border-color</li></ul><h3 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h3><p>outline（轮廓）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。与border高度类似,区别是不占用盒子.</p><p>值:</p><ul><li>outline-color</li><li>outline-style:没有hidden</li><li>outline-width</li></ul><h3 id="outline-offset"><a href="#outline-offset" class="headerlink" title="outline-offset"></a>outline-offset</h3><p>outline在border外边的便宜</p><h3 id="border-image"><a href="#border-image" class="headerlink" title="border-image"></a>border-image</h3><p>Css3新属性.九宫格划分.浏览器支持不佳</p><p>语法:</p><pre><code class="css">border-image: source slice width outset repeat|initial|inherit;</code></pre><p>值:</p><ul><li>border-image-source</li><li>border-image-slice//?不懂</li><li>border-image-width:number(倍数)、%、auto</li><li>border-image-outset //不懂</li><li>border-image-repeat:填充方式;stretch、repeat、round、space、</li></ul><h3 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h3><p>语法:</p><pre><code class="css">border-radius: 1-4 length|% / 1-4 length|%;</code></pre><h3 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h3><p>阴影.</p><p>语法:</p><pre><code class="css">box-shadow: h-shadow v-shadow blur spread color inset;</code></pre><p>值:</p><ul><li>h-shadow:必选</li><li>v-shadow:必选</li><li>blur:模糊距离</li><li>spread:阴影大小//?为什么是可选,默认多少</li><li>color</li><li>inset//不从右下角开始而是从左上角开始</li></ul><h2 id="盒子属性"><a href="#盒子属性" class="headerlink" title="盒子属性"></a>盒子属性</h2><h3 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h3><p>内容溢出框的处理方式</p><p>值:</p><ul><li>visible</li><li>hidden</li><li>scroll//不论是否剪裁都显示滚动条,至少在ie下如此</li><li>auto//只有超出才会显示滚动条</li></ul><h3 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h3><p>值:length/%(规定基于父元素的宽度的百分比的填充)</p><h3 id="height-width"><a href="#height-width" class="headerlink" title="height/width"></a>height/width</h3><p>值:auto;length;%(基于包含它的块级对象的百分比高度)</p><h3 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h3><p>值与padding类似</p><h3 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h3><p>盒子大小.</p><p>值:</p><ul><li>content-box</li><li>border-box</li></ul><h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><p>可否调整大小</p><p>值:</p><ul><li>none</li><li>both</li><li>horizontal</li><li>vertical</li></ul><h2 id="颜色属性"><a href="#颜色属性" class="headerlink" title="颜色属性"></a>颜色属性</h2><h3 id="opacity"><a href="#opacity" class="headerlink" title="opacity"></a>opacity</h3><p>透明度,从0-1.1表示完全透明.</p><h2 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h2><h3 id="font"><a href="#font" class="headerlink" title="font"></a>font</h3><p>字体复合属性.</p><p>值:</p><ul><li>font-style: normal、italic、oblique//oblique: 指的是将正常竖直文本倾斜;</li><li>font-variant:小型大写字母样式.normal/small-caps//存在的意义是什么???</li><li>font-weight:normal、bold、bolder、lighter;100-900.400等于normal,而700等于bold.//er是跟父元素比较</li><li>font-size/line-height:xx-small;x-small;small;medium;large;x-large;xx-large; smaller; larger;length;%(与父元素比较)</li><li>font-family:family-name - 指定的系列名称：具体字体的名称，比如：”times”、”courier”、”arial”。generic-family - 通常字体系列名称：比如：”serif”、”sans-serif”、”cursive”、”fantasy”、”monospace。</li></ul><hr><p>对于以下存在疑惑://表现大小差异</p><ul><li>caption</li><li>icon</li><li>menu</li><li>message-box</li><li>small-caption</li><li>status-bar</li></ul><h3 id="font-face"><a href="#font-face" class="headerlink" title="@font-face"></a>@font-face</h3><blockquote><p> Internet Explorer 9 只支持 .eot 类型的字体, Firefox, Chrome, Safari, 和 Opera 支持 .ttf 与.otf 两种类型字体.</p></blockquote><p>值:</p><ul><li>font-family:自行定义的名称</li><li>src</li><li>font-stretch</li><li>font-style</li><li>font-weight</li><li>unicode-range</li></ul><h2 id="内容生成属性"><a href="#内容生成属性" class="headerlink" title="内容生成属性"></a>内容生成属性</h2><h3 id="content"><a href="#content" class="headerlink" title="content"></a>content</h3><p>在:before和:after中添加内容.</p><p>值:</p><ul><li>none</li><li>normal</li><li>counter//计数器内容额外学习</li><li>attr(attribute)</li><li>string</li><li>open-quote</li><li>close-quote</li><li>no-open-quote//</li><li>no-close-quote//没看见效果</li><li>url(url)</li></ul><h3 id="quotes"><a href="#quotes" class="headerlink" title="quotes"></a>quotes</h3><p>定义选择器和嵌套时的引号包裹.</p><p>值:</p><ul><li>none</li><li>string string string string。前两个是一级引号,后两个是下一级</li></ul><h2 id="列表属性"><a href="#列表属性" class="headerlink" title="列表属性"></a>列表属性</h2><h3 id="list-style"><a href="#list-style" class="headerlink" title="list-style"></a>list-style</h3><p>语法:</p><pre><code class="css"> list-style-type, list-style-position, list-style-image.</code></pre><p>值:</p><ul><li>list-style-type:列表项标记,可选值过多,不一一指出,详细见附录</li><li>list-style-position:标记放在content内还是padding内. inside/outside</li><li>list-style-image:url()/none</li></ul><h2 id="多列属性"><a href="#多列属性" class="headerlink" title="多列属性"></a>多列属性</h2><h3 id="column-count"><a href="#column-count" class="headerlink" title="column-count"></a>column-count</h3><p>文本划分为几列//间隙如何控制。1em.列数和宽度同时满足必须挤压height吗?</p><p>值:</p><ul><li>number</li><li>auto</li></ul><h3 id="column-fil"><a href="#column-fil" class="headerlink" title="column-fil"></a>column-fil</h3><p>如何填充.</p><p>值:</p><ul><li>balance     长短均衡</li><li>auto 顺序填充</li></ul><h3 id="column-gap"><a href="#column-gap" class="headerlink" title="column-gap"></a>column-gap</h3><p>指定每一列之间的差距.</p><p>值:</p><ul><li>length</li><li>normal:1em</li></ul><h3 id="column-rule"><a href="#column-rule" class="headerlink" title="column-rule"></a>column-rule</h3><p>列之间规则的复合属性.</p><p>值:</p><ul><li>column-rule-width:列中间间隔线的宽度: thin medium thick length</li><li>column-rule-style:与border相同</li><li>column-rule-color</li></ul><h3 id="column-span"><a href="#column-span" class="headerlink" title="column-span"></a>column-span</h3><p>指定某个元素应该横跨多少列.在划分好container的列数之后,可能会有想要让其中某些跨的多,某些少.</p><p>值:</p><ul><li>1</li><li>all//所有</li></ul><h3 id="columns"><a href="#columns" class="headerlink" title="columns"></a>columns</h3><p>列宽和列数.</p><p>语法:</p><pre><code class="css">columns: column-width column-count;</code></pre><h2 id="定位属性"><a href="#定位属性" class="headerlink" title="定位属性"></a>定位属性</h2><h3 id="visibility"><a href="#visibility" class="headerlink" title="visibility"></a>visibility</h3><p>是否可见.//与display:none相比仍然会占据空间</p><p>值:</p><ul><li>visible</li><li>hidden</li><li>collapse<blockquote><p>当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上，会呈现为 “hidden”。//具体情境<a href="http://www.runoob.com/try/try.php?filename=trycss_visibility_collapse" target="_blank" rel="noopener">菜鸟教程在线编辑器</a></p></blockquote></li></ul><h3 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h3><p>堆叠顺序.拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面.<br>对非static元素起作用.</p><h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p>定位方式.</p><p>值:</p><ul><li>absolute :相对于 static 定位以外的第一个父元素进行定位</li><li>fixed</li><li>relative</li><li>static :元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）</li></ul><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>元素生成的框属性.</p><p>值过多,参考<a href="http://www.runoob.com/cssref/pr-class-display.html" target="_blank" rel="noopener">CSS display 属性 | 菜鸟教程</a></p><h3 id="cursor"><a href="#cursor" class="headerlink" title="cursor"></a>cursor</h3><p>光标样式.</p><p>值:</p><ul><li>url</li><li>crosshair</li><li>wait</li><li>help</li><li>等…</li></ul><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><p>盒子浮动.</p><p>值:</p><ul><li>left</li><li>right</li><li>none//默认值,不浮动</li></ul><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>指定段落的左侧或右侧不允许浮动的元素</p><p>值:</p><ul><li>left</li><li>right</li><li>both</li><li>none</li></ul><h3 id="clip"><a href="#clip" class="headerlink" title="clip"></a>clip</h3><p>对图像进行剪裁.</p><blockquote><p>注意：: 如果先有”overflow：visible”，clip属性不起作用。//那么根据这个说法,是不是clip是修改了盒子大小.</p></blockquote><p>值:</p><ul><li>shape:rect(top, right, bottom,left)</li><li>auto</li></ul><h2 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h2><h3 id="border-collapse"><a href="#border-collapse" class="headerlink" title="border-collapse"></a>border-collapse</h3><p>设置表格的边框是否被合并为一个单一的边框，还是象在标准的 HTML 中那样分开显示。</p><p>值:</p><ul><li>collapse</li><li>separate</li></ul><h3 id="border-spacing"><a href="#border-spacing" class="headerlink" title="border-spacing"></a>border-spacing</h3><p>相邻单元格边框之间的距离</p><p>值:</p><ul><li>length</li><li>length length //先水平,后垂直</li></ul><h3 id="caption-side"><a href="#caption-side" class="headerlink" title="caption-side"></a>caption-side</h3><p>表格标题的位置</p><p>值:</p><ul><li>top</li><li>bottom</li></ul><h3 id="empty-cells"><a href="#empty-cells" class="headerlink" title="empty-cells"></a>empty-cells</h3><p>隐藏表中的空单元格的边框和背景//有意义吗?</p><p>值:</p><ul><li>hide</li><li>show</li></ul><h3 id="table-layout"><a href="#table-layout" class="headerlink" title="table-layout"></a>table-layout</h3><p>列宽度的设定</p><p>值:</p><ul><li>automatic:根据内容适应</li><li>fixed:写死width</li></ul><h2 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h2><h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><p>值:</p><ul><li>color_name</li><li>hex</li><li>rgb</li></ul><h3 id="direction"><a href="#direction" class="headerlink" title="direction"></a>direction</h3><p>文本方向.</p><p>值:</p><ul><li>ltr</li><li>rtl</li></ul><h3 id="letter-spacing"><a href="#letter-spacing" class="headerlink" title="letter-spacing"></a>letter-spacing</h3><p>字符间隔.</p><p>值:</p><ul><li>normal</li><li>length(允许负值)</li></ul><h3 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h3><p>行高.</p><p>值:</p><ul><li>normal</li><li>number //与字体大小相乘</li><li>length</li><li>% //基于字体的</li></ul><h3 id="text-align"><a href="#text-align" class="headerlink" title="text-align"></a>text-align</h3><p>文本水平对齐.</p><p>值:</p><ul><li>left</li><li>right</li><li>center</li><li>justify</li></ul><h3 id="text-decoration"><a href="#text-decoration" class="headerlink" title="text-decoration"></a>text-decoration</h3><p>文本装饰//下划线及其他</p><p>值:</p><ul><li>none</li><li>underline</li><li>overline</li><li>line-through</li><li>blink//没有看到效果</li></ul><h3 id="text-indent"><a href="#text-indent" class="headerlink" title="text-indent"></a>text-indent</h3><p>文本首行缩进.</p><p>值:</p><ul><li>length</li><li>%//基于父元素宽度</li></ul><h3 id="text-transform"><a href="#text-transform" class="headerlink" title="text-transform"></a>text-transform</h3><p>控制文本的大小写</p><p>值:</p><ul><li>none</li><li>capitalize</li><li>uppercase</li><li>lowercase</li></ul><h3 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h3><p>垂直对齐方式.<br>//关于vertical-align和line-height进一步学习.<br>值:</p><ul><li>baseline</li><li>sub</li><li>super</li><li>top</li><li>text-top</li><li>middle</li><li>bottom</li><li>text-bottom</li><li>length</li><li>%:使用 “line-height” 属性的百分比值来排列此元素。允许使用负值。</li></ul><h3 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a>white-space</h3><p>空白如何处理//?</p><p>值:</p><ul><li>normal</li><li>pre 类似于pre标签</li><li>nowrap</li><li>pre-wrap:保留空白但是换行</li><li>pre-line 合并空白但是换行</li></ul><h3 id="word-spacing"><a href="#word-spacing" class="headerlink" title="word-spacing"></a>word-spacing</h3><p>单词间距.</p><p>值:</p><ul><li>normal</li><li>length</li></ul><h3 id="text-align-last"><a href="#text-align-last" class="headerlink" title="text-align-last"></a>text-align-last</h3><p>针对textalign=justify时的文本最后一行对齐.</p><p>值:</p><ul><li>auto</li><li>left</li><li>right</li><li>center</li><li>justify</li><li>start//根据text-derection而定</li><li>end</li></ul><h3 id="text-overflow"><a href="#text-overflow" class="headerlink" title="text-overflow"></a>text-overflow</h3><p>文本溢出处理方式.</p><p>值:</p><ul><li>clip</li><li>ellipsis :省略号</li><li>string:给定字符串表示,火狐下</li></ul><h3 id="text-shadow"><a href="#text-shadow" class="headerlink" title="text-shadow"></a>text-shadow</h3><p>文本阴影</p><p>值:</p><ul><li>h-shadow 必须</li><li>v-shadow 必须</li><li>blur</li><li>color</li></ul><h3 id="word-break"><a href="#word-break" class="headerlink" title="word-break"></a>word-break</h3><p>非cjk(中日韩)字符的断行规则</p><p>值: </p><ul><li>normal</li><li>break-all//单词内换行</li><li>keep-all //半角空格和连字符</li></ul><h3 id="word-wrap"><a href="#word-wrap" class="headerlink" title="word-wrap"></a>word-wrap</h3><p>换行规则.//与break的区别是什么?!!</p><p>值:</p><ul><li>normal</li><li>break-word:在长单词和url地址内部换行</li></ul><h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p>⚠️,并非所有属性都可以过渡.与keyframes相比过渡更强调两种状态之间的平稳过渡,而后者强调关键帧的存在.</p><p>语法:</p><pre><code class="css">transition: property duration timing-function delay;</code></pre><p>值:</p><ul><li>transition-property:过渡生效的属性:none/all/属性名称列表逗号分割</li><li>transition-duration:秒或者毫秒</li><li>transition-timing-function:速度曲线</li><li>transition-delay:开始延迟</li></ul><p>参考资料:</p><ul><li><a href="http://www.runoob.com/cssref/css-animatable.html" target="_blank" rel="noopener">CSS 动画 | 菜鸟教程</a></li><li><a href="http://www.runoob.com/cssref/css-units.html" target="_blank" rel="noopener">CSS 单位 | 菜鸟教程</a></li><li><a href="http://www.runoob.com/try/try.php?filename=trycss_border-style" target="_blank" rel="noopener">菜鸟教程在线编辑器</a></li><li><a href="http://www.zhangxinxu.com/wordpress/2010/01/css3-border-image/" target="_blank" rel="noopener">CSS3 border-image详解、应用及jQuery插件 «  张鑫旭-鑫空间-鑫生活</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-image-slice" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-image-slice</a></li><li><a href="http://www.runoob.com/try/playit.php?f=playcss_border-image-repeat&amp;preval=stretch" target="_blank" rel="noopener">在线实例</a></li><li><a href="http://www.css88.com/archives/6394" target="_blank" rel="noopener">http://www.css88.com/archives/6394</a></li><li><a href="http://www.runoob.com/cssref/pr-list-style-type.html" target="_blank" rel="noopener">CSS list-style-type 属性 | 菜鸟教程</a></li><li><a href="http://www.runoob.com/cssref/css3-pr-column-span.html" target="_blank" rel="noopener">CSS3 column-span 属性 | 菜鸟教程</a></li><li><a href="http://www.runoob.com/try/try.php?filename=trycss_visibility_collapse" target="_blank" rel="noopener">菜鸟教程在线编辑器</a></li><li><a href="http://www.runoob.com/cssref/pr-class-display.html" target="_blank" rel="noopener">CSS display 属性 | 菜鸟教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CSS3完全学习笔记二-属性全解&quot;&gt;&lt;a href=&quot;#CSS3完全学习笔记二-属性全解&quot; class=&quot;headerlink&quot; title=&quot;CSS3完全学习笔记二: 属性全解&quot;&gt;&lt;/a&gt;CSS3完全学习笔记二: 属性全解&lt;/h1&gt;&lt;p&gt;对于目前没有主流浏览器支持的属性和一些需要特别学习的属性,在这篇笔记中没有学习.&lt;/p&gt;
&lt;h2 id=&quot;动画属性&quot;&gt;&lt;a href=&quot;#动画属性&quot; class=&quot;headerlink&quot; title=&quot;动画属性&quot;&gt;&lt;/a&gt;动画属性&lt;/h2&gt;&lt;h3 id=&quot;keyframes&quot;&gt;&lt;a href=&quot;#keyframes&quot; class=&quot;headerlink&quot; title=&quot;@keyframes&quot;&gt;&lt;/a&gt;@keyframes&lt;/h3&gt;&lt;p&gt;使用@keyframes规则，你可以创建动画。&lt;br&gt;创建动画是通过逐步改变从一个CSS样式设定到另一个。指定的变化时发生时使用％，或关键字”from”和”to”，这是和0％到100％相同。&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;@keyframes animationname {keyframes-selector {css-styles;}}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="css" scheme="https://vevlins.github.io/categories/css/"/>
    
    
      <category term="css3" scheme="https://vevlins.github.io/tags/css3/"/>
    
      <category term="笔记" scheme="https://vevlins.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="教程" scheme="https://vevlins.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CSS3完全学习笔记一:选择器</title>
    <link href="https://vevlins.github.io/2017/12/25/CSS3%E5%AE%8C%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>https://vevlins.github.io/2017/12/25/CSS3完全学习笔记一-选择器/</id>
    <published>2017-12-25T11:55:15.000Z</published>
    <updated>2017-12-25T12:30:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS3完全学习笔记一-选择器"><a href="#CSS3完全学习笔记一-选择器" class="headerlink" title="CSS3完全学习笔记一:选择器"></a>CSS3完全学习笔记一:选择器</h1><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ul><li>.class   .intro 选择所有class中包含该值的元素</li><li>#id #intro  选择所有id=intro的元素</li><li>* 所有元素</li><li>element p 选择所有的p元素</li><li>,   div,p 选择所有的div元素和p元素</li><li>elment element 选择子(包含直接子元素和孙元素等)元素</li><li>> 直接子元素</li><li>+ 紧挨着前者的后者(直接弟节点)</li><li>[attribute] 包含该属性的</li><li>[attribute=value] 属性值为value的元素,加不加引号都可以</li><li>[attribute~=value] 属性值中包含该部分,类似于文本的匹配</li><li>[attribute|=value] 选择指定属性具有指定值开始(以-分隔开)的元素,可以没有后续部分</li><li>:link 未访问链接<a id="more"></a></li><li>:visited 访问过的链接</li><li>:active 活动链接,当点击链接时,该链接变为活动链接<br>这里为了显示正确需要按照顺序lvha书写</li><li>:hover 鼠标在链接上边时</li><li>:focus  获得焦点的输入元素</li><li>:first-letter 第一个字母<blockquote><p>只能设置以下属性: font properties;color properties ;background properties;margin properties;padding properties;border properties;text-decoration;vertical-align (only if float is ‘none’);text-transform;line-height;float;clear</p></blockquote></li></ul><p>这个地方的具体选择元素仍有困惑,比如设置为div:first-letter时,内直接嵌套p,那么p的首字母可以表现,而在p之前填充其他span、img标签则p没有表现.</p><ul><li>:first-line 第一行</li><li>:first-child  p:first-child  当p元素是父元素的第一个子元素时</li><li>:before 在元素之前添加内容,使用content 属性来指定要插入的内容。</li><li>:after 之后</li><li>:lang(language) p:lang(it) lang属性值的起始值为it的p元素</li></ul><hr><p>之后为css3新定义选择器</p><ul><li>element1~element2 p~ul p元素同一父元素之后的每一个ul元素. 与+类似,非直接弟节点</li><li>[attribute^=value] 属性以value开头,与|=类似,但是不要求以-分割</li><li>[attribute$=value] 结尾</li><li>[attribute*=value] 包含子串</li><li>:first-of-type  p:first-of-type, 是其父元素的第一个p子元素,与:nth-of-type(1)相同</li><li>:last-of-type,与:nth-last-of-type(1)相同</li><li>:only-of-type 唯一,不排除其他元素</li><li>:only-child 是父亲的唯一子元素</li><li>:nth-child(n) 是父亲的第n的子元素<blockquote><p>选择父元素E的第n个子元素F。其中n可以是整数（1，2，3）、关键字（even，odd）、可以是公式（2n+1）,而且n值起始值为1，而不是0.</p></blockquote></li><li>:last-child 最后一个子元素</li><li>:nth-last-child(n) 倒数第n</li><li>:nth-of-type(n)。第n个该类型的</li><li>:nth-last-of-type(n) 倒数第n</li><li>:root。根元素,在html中始终是<html></html></li><li>:empty 没有子元素和文本节点</li><li>:target//??? 匹配hash与id相对应的元素,但是safari、chrome没有效果</li><li>:enabled 启用的输入元素</li><li>:disabled</li><li>:checked 选中的输入元素</li><li>:not(selector)     排除</li><li>::selection 被选中的部分<blockquote><p>只可以应用于少数的CSS属性：color, background, cursor,和outline。</p></blockquote></li><li>:out-of-range 匹配值在指定区间之外的input元素</li><li>:in-range    </li><li>:read-write  用于匹配可读及可写的元素/区别于只读元素</li><li>:read-only 匹配设置 “readonly”（只读） 属性的元素</li><li>:optional 可选的输入元素,区别于required</li><li>:required </li><li>:valid 输入值合法的元素</li><li>:invalid 输入值不合法的元素</li></ul><hr><h2 id="Css选择器的分类"><a href="#Css选择器的分类" class="headerlink" title="Css选择器的分类:"></a>Css选择器的分类:</h2><p><img src="http://ozc9m7ly1.bkt.clouddn.com/282324267509975.jpg" alt=""></p><h2 id="伪-pseudo-类和伪选择器"><a href="#伪-pseudo-类和伪选择器" class="headerlink" title="伪(pseudo)类和伪选择器:"></a>伪(pseudo)类和伪选择器:</h2><p>伪类:对现有元素进行筛选;伪选择器:创造出不存在的新元素.</p><blockquote><p>The pseudo-class concept is introduced to permit selection based on information that lies outside of the document tree or that cannot be expressed using the other simple selectors.</p><p>Pseudo-elements create abstractions about the document tree beyond those specified by the document language. For instance, document languages do not offer mechanisms to access the first letter or first line of an element’s content. Pseudo-elements allow authors to refer to this otherwise inaccessible information. Pseudo-elements may also provide authors a way to refer to content that does not exist in the source document.</p></blockquote><p>伪类总是以一个冒号开头。伪元素通常以两个冒号开头。在 CSS2 时代，伪元素和伪类均是以一个冒号开头的；在 CSS2.1 之后，为了对伪元素和伪类加以区分，规定伪类继续以一个冒号开头，而伪元素改为以两个冒号开头。但是为了向前兼容，浏览器同样接受 CSS2 时代已经存在的伪元素（它们包括:before, :after, :first-line, :first-letter）的单冒号写法。但是对于 CSS2 之后所有新增的伪元素（例如::selection），必须采用双冒号写法。</p><p>一些老旧的浏览器不支持双冒号的写法，因此如果必须兼容旧浏览器，则应该使用单冒号写法。IE 从 9 开始支持双冒号写法。//是否意味着ie9之前的浏览器无法使用::selection?</p><p>参考资料:</p><ul><li><a href="https://www.cnblogs.com/AllenChou/p/4684753.html" target="_blank" rel="noopener">最全CSS3选择器 - AllenChou - 博客园</a></li><li><a href="https://www.renfei.org/blog/css-pseudo-class-and-pseudo-element.html" target="_blank" rel="noopener">CSS 伪类和伪元素的区别 - Blog - Renfei Song</a></li><li><a href="http://www.runoob.com/cssref/css-ref-aural.html" target="_blank" rel="noopener">CSS 听觉参考手册 | 菜鸟教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CSS3完全学习笔记一-选择器&quot;&gt;&lt;a href=&quot;#CSS3完全学习笔记一-选择器&quot; class=&quot;headerlink&quot; title=&quot;CSS3完全学习笔记一:选择器&quot;&gt;&lt;/a&gt;CSS3完全学习笔记一:选择器&lt;/h1&gt;&lt;h2 id=&quot;选择器&quot;&gt;&lt;a href=&quot;#选择器&quot; class=&quot;headerlink&quot; title=&quot;选择器&quot;&gt;&lt;/a&gt;选择器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;.class   .intro 选择所有class中包含该值的元素&lt;/li&gt;
&lt;li&gt;#id #intro  选择所有id=intro的元素&lt;/li&gt;
&lt;li&gt;* 所有元素&lt;/li&gt;
&lt;li&gt;element p 选择所有的p元素&lt;/li&gt;
&lt;li&gt;,   div,p 选择所有的div元素和p元素&lt;/li&gt;
&lt;li&gt;elment element 选择子(包含直接子元素和孙元素等)元素&lt;/li&gt;
&lt;li&gt;&gt; 直接子元素&lt;/li&gt;
&lt;li&gt;+ 紧挨着前者的后者(直接弟节点)&lt;/li&gt;
&lt;li&gt;[attribute] 包含该属性的&lt;/li&gt;
&lt;li&gt;[attribute=value] 属性值为value的元素,加不加引号都可以&lt;/li&gt;
&lt;li&gt;[attribute~=value] 属性值中包含该部分,类似于文本的匹配&lt;/li&gt;
&lt;li&gt;[attribute|=value] 选择指定属性具有指定值开始(以-分隔开)的元素,可以没有后续部分&lt;/li&gt;
&lt;li&gt;:link 未访问链接
    
    </summary>
    
      <category term="css" scheme="https://vevlins.github.io/categories/css/"/>
    
    
      <category term="css3" scheme="https://vevlins.github.io/tags/css3/"/>
    
      <category term="笔记" scheme="https://vevlins.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="教程" scheme="https://vevlins.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
