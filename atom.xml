<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sosuke</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vevlins.github.io/"/>
  <updated>2018-03-28T19:24:12.000Z</updated>
  <id>https://vevlins.github.io/</id>
  
  <author>
    <name>Vevlins</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图片自适应的五种可能</title>
    <link href="https://vevlins.github.io/2018/03/29/%E5%9B%BE%E7%89%87%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E4%BA%94%E7%A7%8D%E5%8F%AF%E8%83%BD/"/>
    <id>https://vevlins.github.io/2018/03/29/图片自适应的五种可能/</id>
    <published>2018-03-28T18:58:31.000Z</published>
    <updated>2018-03-28T19:24:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在自适应问题上，图片的自适应可以说是最关键了。</p><p>在仿做小红书的过程中，我也遇到了这个问题，小红书作为一个商品展示性的社区，商品图片的自适应是很重要的。在放眼望去都是图片的页面里，一两个变形可能会极大地影响用户的感受。</p><p>我在两个地方遇到了图片适应的问题，一个是品牌精选的卡片，对于宽固定，图片高度不规则并且比容器本身要大的情况；还有一个是在做九宫格要求图片宽高一致。<br><a id="more"></a></p><h2 id="transform实现居中"><a href="#transform实现居中" class="headerlink" title="transform实现居中"></a>transform实现居中</h2><p>这是小红书官方采用的方案，设置外层<code>overflow:hidden</code>，然后将内部图片设置居中，多余的部分直接被隐藏。这种方案对于不能明确容器和待展示图片大小关系的情况时并不使用。</p><h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><p>主要应用到的是一个<code>background-size:cover</code>属性，这个属性可以使图片适应填满，多余的部分会被裁剪掉。</p><pre><code class="css">background-image:url();background-size: cover;background-posiiton:center;</code></pre><p>这种方案是目前使用范围最广泛，并且认为最理想的解决方案，但是张鑫旭的博客中对于这种方案提了一点问题：由于cover存在剪裁，所以在大小发生变化时展示出来的背景图区域也是不同的。这主要是因为视窗宽度变化时，高度没有等比例变化。对此他提出了本文最后的两种解决方案。</p><hr><p>一点延伸，在复习background属性时碰到了一个知识点。</p><p>background-clip和background-origin的可选值都是一样的，border-box、padding-box、content-box。那么他们的区别是什么？</p><p>简单来说，clip是规定了定位的区域，而origin只是定义了原点，也就是左上角。</p><p>另外对于border-box，如果填充的是图片，左边和上边实际上并不会填充进去。</p><h2 id="object-fit"><a href="#object-fit" class="headerlink" title="object-fit"></a>object-fit</h2><p><code>object-fit</code>基本上算是<code>background-size</code>的姐妹篇，不同的是，这个属性是对于置换元素而言而非背景图像。</p><h2 id="height使用vw单位"><a href="#height使用vw单位" class="headerlink" title="height使用vw单位"></a>height使用vw单位</h2><p>一言以蔽之：这主要是因为视窗宽度变化时，高度没有等比例变化。</p><h2 id="活用padding"><a href="#活用padding" class="headerlink" title="活用padding"></a>活用padding</h2><p>padding使用百分比单位时，是根据父级元素的宽度来确定的，所以通过设定padding，可以实现自适应，他们的宽高是同时变化的。</p><p>接下来是偷css大招。</p><pre><code class="css">.banner {    padding: 15.15% 0 0;    position: relative;}.banner &gt; img {    position: absolute;    width: 100%; height: 100%;    left: 0; top: 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在自适应问题上，图片的自适应可以说是最关键了。&lt;/p&gt;
&lt;p&gt;在仿做小红书的过程中，我也遇到了这个问题，小红书作为一个商品展示性的社区，商品图片的自适应是很重要的。在放眼望去都是图片的页面里，一两个变形可能会极大地影响用户的感受。&lt;/p&gt;
&lt;p&gt;我在两个地方遇到了图片适应的问题，一个是品牌精选的卡片，对于宽固定，图片高度不规则并且比容器本身要大的情况；还有一个是在做九宫格要求图片宽高一致。&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="https://vevlins.github.io/categories/css/"/>
    
    
      <category term="自适应" scheme="https://vevlins.github.io/tags/%E8%87%AA%E9%80%82%E5%BA%94/"/>
    
  </entry>
  
  <entry>
    <title>瀑布流实现方案探讨</title>
    <link href="https://vevlins.github.io/2018/03/28/%E7%80%91%E5%B8%83%E6%B5%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E6%8E%A2%E8%AE%A8/"/>
    <id>https://vevlins.github.io/2018/03/28/瀑布流实现方案探讨/</id>
    <published>2018-03-28T14:46:09.000Z</published>
    <updated>2018-03-28T16:02:23.943Z</updated>
    
    <content type="html"><![CDATA[<p>最近在仿小红书时又遇到了一个问题，就是笔记的瀑布流展示。</p><p>我采用的是张鑫旭在博客中提到的一种基于css3新的<code>column-count</code>特性的方案，这种方案本来是我最喜欢的，因为不需要额外的标签嵌套，也没有js参与布局，css写起来也是简洁又优雅。但是在使用safari调试页面时发现了一个奇怪的问题，使我最终决定放弃这种方案。<br><a id="more"></a><br>需要清楚的是safari和几乎全部的手机浏览器都是webkit内核，chrome原来使用的是webkit，但是后来脱离出来在webkit基础上研发了blink，所以这两种浏览器的表现是不完全一致的，由于chrome的调试工具比较合理，所以我习惯于在chrome下调试，没想到build出来发现在移动端出现了问题。</p><p>上文提到的<code>column-count</code>实现瀑布流的问题是在webkit下除第一竖栏之外其他栏的顶部会<strong><em>莫名其妙</em></strong>地掉下来一块。经过尝试，最终确定在webkit下的其它栏头顶会把上一栏最末尾自<code>border-bottom</code>以外的<code>padding-bottom</code>、<code>margin-bottom</code>乃至<code>box-shadow</code>全都显示出来，而原本应该包含这些的上一栏末尾都不会包含。</p><p>webkit对于<code>column-count</code>的渲染方式在我看来几乎等于是从第一栏底部腰斩。不仅如此，除第一竖栏之外的其他栏甚至在safari调试下根本无法被选中。</p><p>通过caniuse网站查询<code>column-count</code>的支持情况是很乐观的，但是事实还是给了我<strong><em>沉重一击</em></strong>。另外如果从瀑布流的角度来说，这种方案还有一个缺点就是它是竖向排列的，而用户观察是需要一横排一横排地获取新消息，所以这样的方案对于屏幕滚动实现懒加载和对于展示顺序有权重要求的情况并不适合，虽然可以额外通过js实现分块和重排序，但是<code>column-count</code>本来的优势-纯css代码简洁就已经不存在了。</p><p>除此之外，还有什么瀑布流的解决方案呢？</p><p>一、absolute定位打天下</p><p>始自鼻祖pinterest。pinterest的css让我神奇地想到了发牌。因为它的方式实在很像发牌的动作。原理很简单，通过绝对定位先将所有瀑布流中的元素归到左上角，然后根据屏幕宽度除以分栏数计算每一栏宽度，再计算每个图片的高度，通过transformX和transformY来指定其展示位置(向外发牌)。 </p><p>这样做的好处是原理清晰，理解上没什么难度，不会像<code>column-count</code>这样碰到奇奇怪怪的bug了。而且它的计算方式也是基于每一横排，对于控制显示权限和懒加载也很友好。缺点是需要大量的计算，不出所料，pinterest很鸡贼地没有根据页面宽度实现响应，因为窗口的宽度一变，不仅每一栏的宽度变化，为了防止图片变形，高度也要随之变化，所有元素都要重新计算一番。由于窗口变化触发重绘重排而在性能上造成的问题暂且不说，缩小后原本看到的内容也都滑倒上面去了。这对于客户而言很不友好，我记得曾经在使用某个网站时由于没有外接屏幕不得不缩放而遇到这样的问题，一变化就要重新<code>command+f</code>一番。虽然实现响应很酷，可是我们还是要明白窗口resize的情况下，进行响应是否真的有意义？</p><p>二、flexbox竖向布局</p><p>这是大漠在文章中提出的一种解决方案，思路也很清晰。所有的分栏通过一个flexbox控制横向排列，每个分栏里通过一个<code>flex-direction:column</code>控制分栏内部的竖向排列。这种方案我认为还是比较不错的，即避免了太复杂的计算，又没有太混乱的结构，懒加载向里填充新内容也不难。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在仿小红书时又遇到了一个问题，就是笔记的瀑布流展示。&lt;/p&gt;
&lt;p&gt;我采用的是张鑫旭在博客中提到的一种基于css3新的&lt;code&gt;column-count&lt;/code&gt;特性的方案，这种方案本来是我最喜欢的，因为不需要额外的标签嵌套，也没有js参与布局，css写起来也是简洁又优雅。但是在使用safari调试页面时发现了一个奇怪的问题，使我最终决定放弃这种方案。&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="https://vevlins.github.io/categories/css/"/>
    
    
      <category term="瀑布流" scheme="https://vevlins.github.io/tags/%E7%80%91%E5%B8%83%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>小红书图集错落九宫格实现方案</title>
    <link href="https://vevlins.github.io/2018/03/27/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E5%9B%BE%E9%9B%86%E9%94%99%E8%90%BD%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    <id>https://vevlins.github.io/2018/03/27/小红书图集错落九宫格实现方案/</id>
    <published>2018-03-27T08:59:41.000Z</published>
    <updated>2018-03-28T16:02:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在用vue仿小红书的h5版，在界面上唯一比较让人头大的就是这个伪九宫格(不知道有没有专业的称呼，我就这样叫了)的图集了。</p><p>难点分析如下：</p><ul><li>实现图片宽高一致</li><li>尽量减少html标签</li><li>尽量不使用js</li><li>6n和12n情况下大图的左右位置不同</li><li>最后一部分凑不齐9块的排布方案</li></ul><a id="more"></a><p>小红书的效果如下：</p><p><img src="http://ozc9m7ly1.bkt.clouddn.com/www.xiaohongshu.com_page_brands_5a4384888000862471d1493d%28iPhone%206_7_8%20Plus%29.png" alt="小红书图集"></p><p>小红书自己的方案是把每一个伪九宫格区域分为竖向左右两块，通过js判断数量动态决定添加的顺序为大小还是小大。<br>这样做的缺点有二：</p><ul><li>增加了很多无关内容的标签嵌套</li><li>通过js进行计算导致逻辑繁琐</li></ul><p>尝试过标签嵌套和绝对定位加js，最终通过vw和float实现了效果。</p><pre><code class="css">.imgs div {  box-sizing: border-box;  background-size: cover;  width: 33.3vw;  height: 33.3vw;  padding: 1px;  background-clip:content-box;  background-position: center center;  float: left;}.imgs div:nth-of-type(6n-5){    width: 66.6vw;    float: right;    height: 66.6vw;}.imgs div:nth-of-type(12n-5){    float: left;}</code></pre><pre><code class="html">    &lt;div class=&quot;imgs&quot;&gt;        &lt;div v-for=&quot;img in imgs&quot; :style=&#39;`background-image: url(${img})`&#39;&gt;&lt;/div&gt;    &lt;/div&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在用vue仿小红书的h5版，在界面上唯一比较让人头大的就是这个伪九宫格(不知道有没有专业的称呼，我就这样叫了)的图集了。&lt;/p&gt;
&lt;p&gt;难点分析如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现图片宽高一致&lt;/li&gt;
&lt;li&gt;尽量减少html标签&lt;/li&gt;
&lt;li&gt;尽量不使用js&lt;/li&gt;
&lt;li&gt;6n和12n情况下大图的左右位置不同&lt;/li&gt;
&lt;li&gt;最后一部分凑不齐9块的排布方案&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="css" scheme="https://vevlins.github.io/categories/css/"/>
    
    
      <category term="九宫格" scheme="https://vevlins.github.io/tags/%E4%B9%9D%E5%AE%AB%E6%A0%BC/"/>
    
      <category term="图片" scheme="https://vevlins.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>Promise原理剖析</title>
    <link href="https://vevlins.github.io/2018/03/16/Promise%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    <id>https://vevlins.github.io/2018/03/16/Promise原理剖析/</id>
    <published>2018-03-16T08:24:13.000Z</published>
    <updated>2018-03-28T16:03:52.774Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://segmentfault.com/a/1190000009478377" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009478377</a></p></blockquote><pre><code class="javascript">function Promise(fn) {    var state = &#39;pending&#39;,        value = null,        callbacks = [];    this.then = function (onFulfilled, onRejected) {        return new Promise(function (resolve, reject) {            handle({                onFulfilled: onFulfilled || null,                onRejected: onRejected || null,                resolve: resolve,                reject: reject            });        });    };    function handle(callback) {        if (state === &#39;pending&#39;) {            callbacks.push(callback);            return;        }        var cb = state === &#39;fulfilled&#39; ? callback.onFulfilled : callback.onRejected,            ret;        if (cb === null) {            cb = state === &#39;fulfilled&#39; ? callback.resolve : callback.reject;            cb(value);            return;        }        ret = cb(value);        callback.resolve(ret);    }    function resolve(newValue) {        if (newValue &amp;&amp; (typeof newValue === &#39;object&#39; || typeof newValue === &#39;function&#39;)) {            var then = newValue.then;            if (typeof then === &#39;function&#39;) {                then.call(newValue, resolve, reject);                return;            }        }        state = &#39;fulfilled&#39;;        value = newValue;        execute();    }    function reject(reason) {        state = &#39;rejected&#39;;        value = reason;        execute();    }    function execute() {        setTimeout(function () {            callbacks.forEach(function (callback) {                handle(callback);            });        }, 0);    }    fn(resolve, reject);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000009478377&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/119000000947
      
    
    </summary>
    
      <category term="javascript" scheme="https://vevlins.github.io/categories/javascript/"/>
    
    
      <category term="promise" scheme="https://vevlins.github.io/tags/promise/"/>
    
      <category term="异步" scheme="https://vevlins.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>ES6笔记</title>
    <link href="https://vevlins.github.io/2018/03/15/ES6%E7%AC%94%E8%AE%B0/"/>
    <id>https://vevlins.github.io/2018/03/15/ES6笔记/</id>
    <published>2018-03-15T14:54:40.000Z</published>
    <updated>2018-03-16T06:53:18.121Z</updated>
    
    <content type="html"><![CDATA[<p>根据阮一峰《ECMAScript 6 入门》整理。</p><h2 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><p>let是块级作用域变量，声明的变量只在<code>{}</code>内有效。<br>其适用于for循环内，特别需要注意的是：for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><pre><code class="javascript">for (let i = 0; i &lt; 3; i++) {  let i = &#39;abc&#39;;  console.log(i);}</code></pre><h4 id="没有变量提升"><a href="#没有变量提升" class="headerlink" title="没有变量提升"></a>没有变量提升</h4><pre><code class="javascript">// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2;</code></pre><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p><pre><code class="javascript">var tmp = 123;if (true) {  tmp = &#39;abc&#39;; // ReferenceError  let tmp;}</code></pre><a id="more"></a><h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><p>let在一个作用域内只能声明一次，对于函数形参，也不能在函数内部再次声明。</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>只读的常量。一旦声明，常量的值就不能改变。let所拥有的特性：块级作用域、没有变量提升、暂时性死区、不允许重复声明在const中也都适用。</p><h4 id="立即初始化"><a href="#立即初始化" class="headerlink" title="立即初始化"></a>立即初始化</h4><p>不允许<code>const foo</code>这种情况，否则会报错<code>// SyntaxError: Missing initializer in const declaration</code>.</p><h2 id="变量解构赋值"><a href="#变量解构赋值" class="headerlink" title="变量解构赋值"></a>变量解构赋值</h2><p>这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。如果解构不成功，变量的值就等于undefined。如果等号的右边不是可遍历的结构，那么将会报错。</p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>可以指定默认值。当本应该取到的值为undefind时候默认值生效。</p><pre><code class="javascript">let [foo = true] = [];foo // truelet [x, y = &#39;b&#39;] = [&#39;a&#39;]; // x=&#39;a&#39;, y=&#39;b&#39;let [x, y = &#39;b&#39;] = [&#39;a&#39;, undefined]; // x=&#39;a&#39;, y=&#39;b&#39;</code></pre><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>对象的属性是无序的，所以必须指定变量和属性同名，否则写成<code>foo:baz</code>用baz取出对象中foo的值。</p><pre><code class="javascript">let { foo: baz } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; };baz // &quot;aaa&quot;let obj = { first: &#39;hello&#39;, last: &#39;world&#39; };let { first: f, last: l } = obj;f // &#39;hello&#39;l // &#39;world&#39;</code></pre><h3 id="函数参数、字符串解构"><a href="#函数参数、字符串解构" class="headerlink" title="函数参数、字符串解构"></a>函数参数、字符串解构</h3><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="遍历接口"><a href="#遍历接口" class="headerlink" title="遍历接口"></a>遍历接口</h3><pre><code class="javascript">for (let codePoint of &#39;foo&#39;) {  console.log(codePoint)}</code></pre><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量，通过<code>${}</code>。</p><h4 id="保留换行和空格"><a href="#保留换行和空格" class="headerlink" title="保留换行和空格"></a>保留换行和空格</h4><p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p><h4 id="支持嵌入表达式和调用函数"><a href="#支持嵌入表达式和调用函数" class="headerlink" title="{}支持嵌入表达式和调用函数"></a>{}支持嵌入表达式和调用函数</h4><p>调用函数的情况：如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。</p><pre><code class="javascript">let x = 1;let y = 2;`${x} + ${y} = ${x + y}`// &quot;1 + 2 = 3&quot;`${x} + ${y * 2} = ${x + y * 2}`// &quot;1 + 4 = 5&quot;let obj = {x: 1, y: 2};`${obj.x + obj.y}`// &quot;3&quot;</code></pre><h4 id="支持多层嵌套"><a href="#支持多层嵌套" class="headerlink" title="支持多层嵌套"></a>支持多层嵌套</h4><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h3><p>常规方法：</p><pre><code class="javascript">if (typeof y === &#39;undefined&#39;) {  y = &#39;World&#39;;}</code></pre><pre><code class="javascript">function Point(x = 0, y = 0) {  this.x = x;  this.y = y;}const p = new Point();p // { x: 0, y: 0 }</code></pre><p>使用参数默认值时，函数不能有同名参数。</p><pre><code class="javascript">// 报错function foo(x, x, y = 1) {  // ...}</code></pre><p>每次都重新计算默认值表达式的值。</p><pre><code class="javascript">let x = 99;function foo(p = x + 1) {  console.log(p);}foo() // 100x = 100;foo() // 101</code></pre><h3 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h3><p>rest参数是真正的数组，而arguments虽然有length属性，可以用来遍历，但是并非真正的数组。rest参数之后不能再有其他参数。</p><pre><code class="javascript">// arguments变量的写法function sortNumbers() {  return Array.prototype.slice.call(arguments).sort();}// rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort();</code></pre><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ul><li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li><li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li><li>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li><li>不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</li></ul><h3 id="双冒号运算符"><a href="#双冒号运算符" class="headerlink" title="双冒号运算符"></a>双冒号运算符</h3><p>函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p><pre><code class="javascript">foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments);const hasOwnProperty = Object.prototype.hasOwnProperty;function hasOwn(obj, key) {  return obj::hasOwnProperty(key);}</code></pre><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>Object.assign方法实行的是浅拷贝，而不是深拷贝。</p><h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>Promise 是异步编程的一种解决方案。<br>Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p><pre><code class="javascript">let promise = new Promise(function(resolve, reject) {  console.log(&#39;Promise&#39;);  resolve();});promise.then(function() {  console.log(&#39;resolved.&#39;);});console.log(&#39;Hi!&#39;);// Promise// Hi!// resolved</code></pre><p>上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。</p><h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><p>Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p><h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><pre><code class="javascript">getJSON(&#39;/posts.json&#39;).then(function(posts) {  // ...}).catch(function(error) {  // 处理 getJSON 和 前一个回调函数运行时发生的错误  console.log(&#39;发生错误！&#39;, error);});</code></pre><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。</p><p>async 函数会返回一个Promise对象。按照我的理解，他可以把Promise的then链式调用写成同步代码的样式。</p><pre><code class="javascript">function takeLongTime(n) {    return new Promise(resolve =&gt; {        setTimeout(() =&gt; resolve(n + 200), n);    });}//基本函数function step1(n) {    console.log(`step1 with ${n}`);    return takeLongTime(n);}function step2(m, n) {    console.log(`step2 with ${m} and ${n}`);    return takeLongTime(m + n);}function step3(k, m, n) {    console.log(`step3 with ${k}, ${m} and ${n}`);    return takeLongTime(k + m + n);}//通过async实现async function doIt() {    console.time(&quot;doIt&quot;);    const time1 = 300;    const time2 = await step1(time1);    const time3 = await step2(time1, time2);    const result = await step3(time1, time2, time3);    console.log(`result is ${result}`);    console.timeEnd(&quot;doIt&quot;);}doIt();// 通过promise实现function doIt() {    console.time(&quot;doIt&quot;);    const time1 = 300;    step1(time1)        .then(time2 =&gt; {            return step2(time1, time2)                .then(time3 =&gt; [time1, time2, time3]);        })        .then(times =&gt; {            const [time1, time2, time3] = times;            return step3(time1, time2, time3);        })        .then(result =&gt; {            console.log(`result is ${result}`);            console.timeEnd(&quot;doIt&quot;);        });}doIt();</code></pre><pre><code class="javascript">async function timeout(ms) {  await new Promise((resolve) =&gt; {    setTimeout(resolve, ms);  });}async function asyncPrint(value, ms) {  await timeout(ms);  console.log(value);}asyncPrint(&#39;hello world&#39;, 50);</code></pre><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><pre><code class="javascript">//定义类class Point {  constructor(x, y) {    this.x = x;    this.y = y;  }  toString() {    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;  }}</code></pre><pre><code class="javascript">class ColorPoint extends Point {  constructor(x, y, color) {    super(x, y); // 调用父类的constructor(x, y)    this.color = color;  }  toString() {    return this.color + &#39; &#39; + super.toString(); // 调用父类的toString()  }}</code></pre><h2 id="model"><a href="#model" class="headerlink" title="model"></a>model</h2><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><pre><code class="javascript">import { stat, exists, readFile } from &#39;fs&#39;;</code></pre><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><pre><code class="javascript">// profile.jsvar firstName = &#39;Michael&#39;;var lastName = &#39;Jackson&#39;;var year = 1958;export {firstName, lastName, year};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据阮一峰《ECMAScript 6 入门》整理。&lt;/p&gt;
&lt;h2 id=&quot;let和const命令&quot;&gt;&lt;a href=&quot;#let和const命令&quot; class=&quot;headerlink&quot; title=&quot;let和const命令&quot;&gt;&lt;/a&gt;let和const命令&lt;/h2&gt;&lt;h3 id=&quot;let&quot;&gt;&lt;a href=&quot;#let&quot; class=&quot;headerlink&quot; title=&quot;let&quot;&gt;&lt;/a&gt;let&lt;/h3&gt;&lt;h4 id=&quot;块级作用域&quot;&gt;&lt;a href=&quot;#块级作用域&quot; class=&quot;headerlink&quot; title=&quot;块级作用域&quot;&gt;&lt;/a&gt;块级作用域&lt;/h4&gt;&lt;p&gt;let是块级作用域变量，声明的变量只在&lt;code&gt;{}&lt;/code&gt;内有效。&lt;br&gt;其适用于for循环内，特别需要注意的是：for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;for (let i = 0; i &amp;lt; 3; i++) {
  let i = &amp;#39;abc&amp;#39;;
  console.log(i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;没有变量提升&quot;&gt;&lt;a href=&quot;#没有变量提升&quot; class=&quot;headerlink&quot; title=&quot;没有变量提升&quot;&gt;&lt;/a&gt;没有变量提升&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;暂时性死区&quot;&gt;&lt;a href=&quot;#暂时性死区&quot; class=&quot;headerlink&quot; title=&quot;暂时性死区&quot;&gt;&lt;/a&gt;暂时性死区&lt;/h3&gt;&lt;p&gt;只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;var tmp = 123;

if (true) {
  tmp = &amp;#39;abc&amp;#39;; // ReferenceError
  let tmp;
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://vevlins.github.io/categories/javascript/"/>
    
    
      <category term="es6" scheme="https://vevlins.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>面试要点整理</title>
    <link href="https://vevlins.github.io/2018/03/14/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>https://vevlins.github.io/2018/03/14/面试要点整理/</id>
    <published>2018-03-14T05:49:45.000Z</published>
    <updated>2018-03-16T18:35:57.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="http相关"><a href="#http相关" class="headerlink" title="http相关"></a>http相关</h2><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>Https可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，即HTTP-SSL-TCP-IP,HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输.目前使用最广泛的是TLS 1.1、TLS 1.2。<br>HTTP面临的风险有：</p><ul><li>窃听风险</li><li>篡改风险</li><li>冒充风险</li></ul><p><img src="https://pic2.zhimg.com/80/v2-5e2241fae8b593ff7f3b3a308ef81c10_hd.jpg" alt=""><br><a id="more"></a></p><h3 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h3><p>当前使用的协议是http1.1,http2.0(RFC 7540)需要现代浏览器和web服务器的支持，其发展于SPDY。<br>其特点有：</p><ul><li>二进制分帧</li><li>压缩头部</li><li>多路复用（请求优先级）</li><li>服务器推送</li></ul><h3 id="http三次握手和四次挥手"><a href="#http三次握手和四次挥手" class="headerlink" title="http三次握手和四次挥手"></a>http三次握手和四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>第一次握手：主机A发送位码为syn＝1,随机产生seq number=x的数据包到服务器，客户端进入SYN_SEND状态，等待服务器的确认；主机B由SYN=1知道，A要求建立联机；</p><p>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number(主机A的seq+1),syn=1,ack=1,随机产生seq=y的包,此时服务器进入SYN_RECV状态;</p><p>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p><p>第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我也没有数据要发送了，可以进行关闭连接了；</p><p>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入CLOSE_WAIT状态；</p><p>第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><h3 id="常见的http头"><a href="#常见的http头" class="headerlink" title="常见的http头"></a>常见的http头</h3><h4 id="请求头："><a href="#请求头：" class="headerlink" title="请求头："></a>请求头：</h4><ul><li>Accept：接受的响应内容类型： text/plain</li><li>Cache-Control：是否使用缓存机制：no-cache</li><li>Origin：用于cors判断请求来源</li><li>Referer：访问的前一个页面</li><li>User-Agent：浏览器标识字符串</li></ul><h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><ul><li>Allow：允许的http方法</li><li>Content-Encoding：响应资源所使用的编码类型</li><li>ETag：资源版本的标识符</li><li>Expires：过期时间</li><li>Set-Cookie：设定cookie值</li></ul><h3 id="常见的http代码"><a href="#常见的http代码" class="headerlink" title="常见的http代码"></a>常见的http代码</h3><ul><li>1xx：临时响应</li><li>2xx：成功</li><li>3xx：重定向</li><li>4xx：客户端错误</li><li>5xx：服务器错误</li></ul><p>常见代码：</p><ul><li>301:永久移动</li><li>302：临时移动</li><li>304:未修改</li><li>400:不理解请求的语法</li><li>401:未授权</li><li>403:拒绝请求</li><li>405:不支持http方法</li><li>503:现在无法提供服务</li></ul><h3 id="http方法"><a href="#http方法" class="headerlink" title="http方法"></a>http方法</h3><ul><li>GET：获取资源</li><li>HEAD：获取报头</li><li>PUT：更新资源</li><li>POST：提交数据、新建资源</li><li>TRACE：检查http在过程中的变更</li><li>OPTIONS：返回支持的http方法</li><li>DELETE：删除页面</li><li>拓展方法如MOVE、COPY等</li></ul><h3 id="浏览器输入url到最终显示过程"><a href="#浏览器输入url到最终显示过程" class="headerlink" title="浏览器输入url到最终显示过程"></a>浏览器输入url到最终显示过程</h3><ul><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ul><h3 id="get请求和post请求的区别"><a href="#get请求和post请求的区别" class="headerlink" title="get请求和post请求的区别"></a>get请求和post请求的区别</h3><ul><li>get请求url长度受限制：url最大长度是2048个字符</li><li>get请求只能传输ascii字符</li><li>get请求可以显示在url中，所以安全性较差</li></ul><h3 id="服务器主动推送"><a href="#服务器主动推送" class="headerlink" title="服务器主动推送"></a>服务器主动推送</h3><ul><li>ajax轮询</li><li>Comet</li><li>Server-Sent</li><li>WebSocket</li></ul><h2 id="ajax相关"><a href="#ajax相关" class="headerlink" title="ajax相关"></a>ajax相关</h2><h3 id="ajax的优点"><a href="#ajax的优点" class="headerlink" title="ajax的优点"></a>ajax的优点</h3><ul><li>异步加载，优化用户体验</li><li>减少了与服务器之间不必要的传输</li><li>实现局部刷新</li><li>把服务器的负担转移到客户端</li></ul><h3 id="ajax的缺点"><a href="#ajax的缺点" class="headerlink" title="ajax的缺点"></a>ajax的缺点</h3><ul><li>不支持浏览器的历史记录</li><li>对搜索引擎的支持差</li></ul><h3 id="xml和json的比较"><a href="#xml和json的比较" class="headerlink" title="xml和json的比较"></a>xml和json的比较</h3><ul><li>xml解码难度大，json是js的子集，解析容易</li><li>xml占据了较早的市场</li><li>xml数据描述性更好</li><li>json体积小，传输速度快</li></ul><h3 id="js解析json的方法"><a href="#js解析json的方法" class="headerlink" title="js解析json的方法"></a>js解析json的方法</h3><ul><li>eval</li><li>new Function</li><li>JSON.parse</li></ul><h3 id="xmlhttprequest的readystate取值"><a href="#xmlhttprequest的readystate取值" class="headerlink" title="xmlhttprequest的readystate取值"></a>xmlhttprequest的readystate取值</h3><p>readyState属性 请求的状态 有5个可取值0=未初始化 ，1=正在加载，2=已加载，3=交互中，4=完成</p><h2 id="web安全相关"><a href="#web安全相关" class="headerlink" title="web安全相关"></a>web安全相关</h2><h3 id="csrf"><a href="#csrf" class="headerlink" title="csrf"></a>csrf</h3><p>csrf：跨站请求伪造。借助用户本地存储的cookie进行恶意的请求伪造。解决方案是检查其http-refer和制作token在请求中一并发送。</p><h3 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h3><p>xss：跨站脚本攻击。攻击者将恶意的js代码插入到页面中。分为基于反射的，基于存储的，基于dom的。解决方案是通过检查过滤用户输入的数据。</p><h3 id="clickjacking"><a href="#clickjacking" class="headerlink" title="clickjacking"></a>clickjacking</h3><p>clickjacking：设置iframe指向其他网站并且将其设置为透明，诱骗用户填入信息并触发请求。解决方案为在响应头中设置X-Frame-Options，可选为3个DENY、SAMEORIGIN、ALLOW-FROM。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="内容优化"><a href="#内容优化" class="headerlink" title="内容优化"></a>内容优化</h3><ul><li>减少http请求</li><li>dns预解析</li><li>减少iframe</li></ul><h3 id="服务器优化"><a href="#服务器优化" class="headerlink" title="服务器优化"></a>服务器优化</h3><ul><li>静态资源cookie隔离</li><li>cdn</li><li>gzip压缩</li><li>etag</li><li>避免空的图像src</li><li>开启缓存</li></ul><h3 id="js优化"><a href="#js优化" class="headerlink" title="js优化"></a>js优化</h3><ul><li>减少dom操作</li><li>减少长作用域链查找</li><li>在底部加载</li></ul><h3 id="css优化"><a href="#css优化" class="headerlink" title="css优化"></a>css优化</h3><ul><li>采用link而不是import</li><li>css放在顶部</li><li>尽量避免使用css表达式</li><li>减少选择器嵌套</li><li>减少css动画</li></ul><h3 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h3><ul><li>压缩图片</li><li>sprites</li><li>使用图标字体</li><li>懒加载</li></ul><h2 id="vue相关"><a href="#vue相关" class="headerlink" title="vue相关"></a>vue相关</h2><h3 id="mvvm和mvc"><a href="#mvvm和mvc" class="headerlink" title="mvvm和mvc"></a>mvvm和mvc</h3><ul><li>mvc：view-controller-model-view 单向传递</li><li>mvvm：view-viewmodel-model 双向传递</li></ul><h3 id="vue双向数据绑定"><a href="#vue双向数据绑定" class="headerlink" title="vue双向数据绑定"></a>vue双向数据绑定</h3><p>通过Object.defineProperty()实现数据劫持，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><ul><li>实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者。defineProperty</li><li>实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。createDocumentFragment</li><li>实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图。 订阅发布模式定义了一种一对多的关系，让多个观察者同时监听某一个主题对象，这个主题对象的状态发生改变时就会通知所有观察者对象</li><li>mvvm入口函数，整合以上三者</li></ul><h3 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h3><p>beforeCreate（创建前）,created（创建后），beforeMount(载入前),mounted（载入后）,beforeUpdate（更新前）,updated（更新后）,beforeDestroy（销毁前）,destroyed（销毁后）</p><h3 id="vue组件通信"><a href="#vue组件通信" class="headerlink" title="vue组件通信"></a>vue组件通信</h3><ul><li>父组件向子组件传递：父组件写在标签内，子组件通过通过props获取</li><li>子组件向父组件传递：<code>$emit</code>发送事件</li><li>兄弟组件传递：实例化一个第三方vue实例，<code>$emit</code>触发事件,<code>$on</code>接收事件</li></ul><h3 id="vuex的作用"><a href="#vuex的作用" class="headerlink" title="vuex的作用"></a>vuex的作用</h3><p>VueX 是一个专门为 Vue.js 应用设计的状态管理架构，统一管理和维护各个vue组件的可变化状态。当单独使用Vue.js,我们常常倾向于存储状态我们的组件内。也就是说,每个组件属于我们的应用程序状态,因此结果状态乱扔的到处都是。然而,有时一块状态需要由多个组件共享。常见的做法是让一个组件“发送”一些使用自定义事件系统其他组件。这种模式的问题是内部的事件流大组件树很快就变得复杂,通常很难原因时出现错误。</p><h3 id="vue1-0和vue2-0的区别是什么"><a href="#vue1-0和vue2-0的区别是什么" class="headerlink" title="vue1.0和vue2.0的区别是什么"></a>vue1.0和vue2.0的区别是什么</h3><ul><li>vue2.0代码必须包裹在一个根元素</li><li>vue2.0的生命周期发生了很大的变化</li></ul><h2 id="js相关"><a href="#js相关" class="headerlink" title="js相关"></a>js相关</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>基本数据类型：String、Number、Boolean、Undefined、Null、Symbol</li><li>引用类型：object、array、function</li></ul><h3 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h3><ul><li>typeof：对null返回object、无法判断array、date等类型</li><li>instanceof：检测两个对象是否实例关系</li><li>constructor：无法判断null和undefined，重写prototype之后constructor丢失默认为Object</li><li>Object.prototype.toString.call</li></ul><h3 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h3><p>惰性函数、柯里化、</p><h4 id="惰性载入函数"><a href="#惰性载入函数" class="headerlink" title="惰性载入函数"></a>惰性载入函数</h4><p>在浏览器功能检测中，函数的分支当第一次确定时就将分支内的函数作为返回值，这样就改变了这个函数。在以后加载中避免了每次都判断。</p><pre><code class="javascript">function addEvent (type, element, fun) {    if (element.addEventListener) {        addEvent = function (type, element, fun) {            element.addEventListener(type, fun, false);        }    }    else if(element.attachEvent){        addEvent = function (type, element, fun) {            element.attachEvent(&#39;on&#39; + type, fun);        }    }    else{        addEvent = function (type, element, fun) {            element[&#39;on&#39; + type] = fun;        }    }    return addEvent(type, element, fun);}</code></pre><h4 id="安全的类型检测"><a href="#安全的类型检测" class="headerlink" title="安全的类型检测"></a>安全的类型检测</h4><p>通过toString方法来检测传入参数的类型，以判断是否进行下一步操作。</p><pre><code class="javascript">  Object.prototype.toString.call(value)</code></pre><h4 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" class="headerlink" title="作用域安全的构造函数"></a>作用域安全的构造函数</h4><p>构造函数如果没有new，那么构造函数内部的this指向全局也就是window对象。先用instance判断一下this指向，如果不是指向构造函数，那么返回一个new实例化的对象。</p><pre><code class="javascript">function Person(name){    if(this instanceof Person){        this.name = name;    }else{        return new Person(name)    }}</code></pre><h4 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h4><p>它用于创建已经设置好了一个或者多个参数的函数，函数柯里化的基本方法和函数绑定是一样的，使用一个闭包返回一个函数。</p><pre><code class="javascript"> //普通的add版本function add(num1, num2){    return num1 + num2;}//第一个参数为5的add版本function curriedAdd5(num2){    return add(5, num2)}function curry(fn, context){//截取调用curry时候，除了fn,context,之后的所有参数    var args =[].slice.call(arguments,2);    return function(){//获取调用fn的所有参数        var totalArgs = args.concat([].slice.call(arguments));        return fn.apply(context, totalArgs);    }}var curriedAdd5 = curry(add, null, 5)</code></pre><h3 id="判断数组"><a href="#判断数组" class="headerlink" title="判断数组"></a>判断数组</h3><ul><li>instanceof</li><li>toString</li><li>constructor</li></ul><h3 id="箭头函数和this"><a href="#箭头函数和this" class="headerlink" title="箭头函数和this"></a>箭头函数和this</h3><p>箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。箭头函数的this其实就是在定义的时候就确定好的，以后不管怎么调用这个箭头函数，箭头函数的this始终为定义时的this。箭头函数没有arguments，可以用剩余参数代替。箭头函数不要再对象的方法中、作为构造函数、定义原型方法时使用。</p><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><ul><li>函数调用模式-全局调用：指向全局对象也就是window，包括在函数方法中嵌套的</li><li>方法调用模式：指向上层对象</li><li>构造器调用模式：通过new构造的this指向新的对象</li><li>apply、call、bind等调用模式：指向传入的对象</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>只有函数可以限定一个变量的作用范围，即函数才是变量的作用域。在ES6之前，JavaScript没有块级作用域(一对花括号{}即为一个块级作用域)，只有全局作用域和函数作用域。</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>函数在运行的瞬间，生成一个活动对象（Active Object），简称AO</p><ul><li>第一步：分析参数：函数接收形式参数，添加到AO的属性，并且这个时候值为undefine,即AO.age=undefined，接收实参，添加到AO的属性，覆盖之前的undefined</li><li>第二步：分析变量声明：如var age;或var age=18;如果上一步分析参数中AO还没有age属性，则添加AO属性为undefined，即AO.age=undefine，如果AO上面已经有age属性了，则不作任何修改</li><li>第三步：分析函数的声明：如果有function age(){}把函数赋给AO.age ,覆盖上一步分析的值</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>首字母大写，内部用this的函数，最后通过new来进行实例化。<br>构造函数的返回值有以下几种情况：</p><ul><li>没有返回值时返回实例化的对象。</li><li>返回值为基本数据类型时返回实例化的对象，用来两用函数。</li><li>返回值为引用类型时，返回该引用类型。</li></ul><h3 id="new的操作"><a href="#new的操作" class="headerlink" title="new的操作"></a>new的操作</h3><p>相当于以下步骤：</p><pre><code class="javascript">var obj = {}obj._proto_ = Co.prototyoeCo.call(obj)return obj</code></pre><h3 id="promise和async-await"><a href="#promise和async-await" class="headerlink" title="promise和async/await"></a>promise和async/await</h3><p>promise的三种状态pending（进行中）、fulfilled（已成功）和rejected（已失败）。两个参数resolve和reject。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。(MDN)用来访问另一个函数作用域链上的变量的函数。由于该变量被其他函数饮用所以内存回收机制导致其不会立即清除，也就是其定义时的上下文被记住，起到了记忆功能。</p><h3 id="js对象私有变量"><a href="#js对象私有变量" class="headerlink" title="js对象私有变量"></a>js对象私有变量</h3><ul><li>_开头的编码约定</li><li>基于闭包构造特权函数，缺点是无法挂载在prototype上，无法实现共享</li><li>强引用散列表</li><li>基于ES6的WeakMap</li></ul><h3 id="js垃圾回收机制"><a href="#js垃圾回收机制" class="headerlink" title="js垃圾回收机制"></a>js垃圾回收机制</h3><p>JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数。优化垃圾回收的主要思想是避免新建对象，而是尽量复用。比如delete obj的属性，而非new Object()。设置arr.length = 0而非 arr = []。</p><p>可能会导致内存泄漏的操作有：</p><ul><li>意外的全局变量</li><li>被遗忘的定时器或回调</li><li>没有清理的DOM元素引用</li><li>不恰当的闭包</li></ul><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><img src="https://pic1.zhimg.com/80/e83bca5f1d1e6bf359d1f75727968c11_hd.jpg" alt=""></p><h3 id="rhs和lhs"><a href="#rhs和lhs" class="headerlink" title="rhs和lhs"></a>rhs和lhs</h3><p>rhs为取值，lhs为赋值。<br>如果在rhs的所有嵌套的作用域查询中都无法找到该变量,js引擎就会抛出一个ReferenceError异常. ReferenceError是一个重要的异常.<br>相较之下， 当引擎执行 LHS 查询时， 如果在顶层（ 全局作用域） 中也无法找到目标变量，<br>全局作用域中就会创建一个具有该名称的变量， 并将其返还给引擎， 前提是程序运行在非 “ 严格模式” 下。</p><h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p>函数调用形成了一个栈帧。对象被分配在一个堆中，即用以表示一个大部分非结构化的内存区域。一个待处理的消息队列。当栈拥有足够内存时并且满足触发条件(如setTimeout)从队列中取出一个消息进行处理。一个 web worker 或者一个跨域的iframe都有自己的栈，堆和消息队列。两个不同的运行时只能通过 postMessage方法进行通信。如果后者侦听到message事件，则此方法会向其他运行时添加消息。</p><p>js所谓的单线程，是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个。不妨叫它主线程。实际上还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外，在此我们不做区分。不妨叫它们工作线程。</p><p>一个异步过程：主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定的动作(调用回调函数)。</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>HTTP 协议有一个缺陷：通信只能由客户端发起。HTTP 协议做不到服务器主动向客户端推送信息。WebSocket最大的特点就是服务器可以主动向服务器发送信息，客户端也可以向服务器端主动发送信息。SSE是单向推送，利用EventSource，content-type设置为text/event-stream。</p><p>特点有以下：</p><ul><li>建立在TCP之上</li><li>默认端口也是ws80和wss443，握手阶段采用http协议。</li><li>数据格式轻，性能开销小</li><li>可以发送文本和二进制文件</li><li>没有同源策略的限制</li></ul><p>客户端API：</p><ul><li>var ws = new WebSocket(‘ws://localhost:8080’);</li><li>webSocket.readyState 0=正在连接 1=连接成功 2=连接正在关闭 3=连接已经关闭</li><li>ws.onopen= function(){} 连接成功后的回调函数</li><li>ws.onclose = function(){} 连接关闭后的回调函数</li><li>onmessage 收到信息后 event.data instanceof ArrayBuffer || String</li><li>ws.send(‘your message’);</li><li>ws.bufferedAmount 还有多少字节没有发送完 判断是否发送完毕</li><li>ws.onerror </li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>原型链</li><li>构造函数</li><li>组合继承</li><li>原型式继承</li><li>寄生式继承</li><li>寄生组合式继承</li></ul><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ul><li>工厂模式</li><li>构造函数模式</li><li>原型模式</li><li>组合模式</li><li>动态原型模式</li><li>寄生构造模式</li><li>稳妥构造模式</li></ul><h3 id="js跨域"><a href="#js跨域" class="headerlink" title="js跨域"></a>js跨域</h3><p>同源策略要求三个相同：协议相同、域名相同、端口相同</p><ul><li>cors</li><li>图像ping</li><li>jsonp</li><li>iframe+document.domain：适用于主域相同而子域不同的情况，设置相同的domain，然后在a页面中创建b页面的iframe，获取ifr.contentDocument就可以操作b</li><li>iframe+location.hash:src指向目标，hash中带参数，目标页面处理之后设置一个src指向代理文件，代理文件通过parent.parent.location.hash向源文件传递参数，源文件通过hashchange事件获取hash</li><li>iframe+window.name:window.name2MB而且在页面切换后不会变，先iframe.src指向跨域地址，在onload时转向当前域下一空文件，之前取到的window.name依然不变</li><li>代理服务器</li><li>postmessage</li></ul><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><ul><li>comet</li><li>sse</li><li>websocket</li></ul><h3 id="多页面传参数"><a href="#多页面传参数" class="headerlink" title="多页面传参数"></a>多页面传参数</h3><ul><li>cookie轮询</li><li>localStorage和storage事件</li><li>websocket</li></ul><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝分两种情况，拷贝直接拷贝源对象的引用 和 源对象拷贝实例.对于第二种情况，常用方法为<code>Array.prototype.slice(), Array.prototype.concat(), jQury的$.extend({},obj)</code></p><pre><code>function shallowCopy(src) {  var dst = {};  for (var prop in src) {    if (src.hasOwnProperty(prop)) {      dst[prop] = src[prop];    }  }  return dst;}</code></pre><p>深拷贝后，两个对象，包括其内部的元素互不干扰。常见方法有JSON.parse(),JSON.stringify()，jQury的<code>$.extend(true,{},obj)</code>，lodash的<code>_.cloneDeep和_.clone(value, true)。</code>有两种解决方案：</p><pre><code>JSON.parse(JSON.stringify(test))</code></pre><pre><code>function clone(p,s){　　var s=s||{};　　for(var prop in p){　　　　if(typeof p[prop]==&#39;object&#39;){　　　　　　　　s[prop]=(p[prop].constructor===Array)?[]:{};//三元运算，将s[prop]初始化为数组或者对象　　　　　　　　clone(p[prop],s[prop])　　　　}　　　　else{　　　　　　s[prop]=p[prop];　　　　}};　　　　return s;};</code></pre><h3 id="js事件模型"><a href="#js事件模型" class="headerlink" title="js事件模型"></a>js事件模型</h3><h4 id="DOM0级模型"><a href="#DOM0级模型" class="headerlink" title="DOM0级模型"></a>DOM0级模型</h4><p>又称原始事件模型，事件不会传播，没有事件流的概念。事件绑定通过在html代码中直接写<code>onclick</code> 或者在js中通过<code>.onclick=xxx</code>实现，如果取消可以将其指向<code>null</code>。</p><h4 id="DOM2级模型"><a href="#DOM2级模型" class="headerlink" title="DOM2级模型"></a>DOM2级模型</h4><p>分为事件捕获阶段，事件处理阶段，事件冒泡阶段。通过    <code>addEventListener</code>和<code>removeEventListener</code>。<br>参数有三个：</p><ul><li>eventType指定事件类型(不要加on)</li><li>handler是事件处理函数</li><li>useCapture是一个boolean用于指定是否在捕获阶段进行处理，一般设置为false与IE浏览器保持一致。</li></ul><h4 id="IE事件模型"><a href="#IE事件模型" class="headerlink" title="IE事件模型"></a>IE事件模型</h4><p>事件处理和事件冒泡阶段。<br><code>attachEvent</code>和<code>detachEvent</code></p><h4 id="DOM事件模型和IE事件模型的区别"><a href="#DOM事件模型和IE事件模型的区别" class="headerlink" title="DOM事件模型和IE事件模型的区别"></a>DOM事件模型和IE事件模型的区别</h4><ul><li>event和window.event</li><li>target和srcElement</li><li>stopPropagation和cancelBubble</li><li>preventDefault和returnValue</li></ul><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>可以在全局最顶端声明，也可以在某个函数顶端声明。</p><ul><li>全局变量必须显式声明</li><li>禁止使用with语句</li><li>eval自己存在独立的作用域</li><li>禁止this指向全局对象</li><li>禁止删除变量</li><li>禁止重名</li></ul><h3 id="js模块化"><a href="#js模块化" class="headerlink" title="js模块化"></a>js模块化</h3><ul><li>无模块化：分js文件写script。缺点是污染全局作用域和依赖关系不明显。</li><li>CommonJS：CommonJS的核心思想就是通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口。用于node端，同步加载模块，不适用于浏览器端。</li><li>AMD：require.js。通过define来定义一个模块，然后使用require来加载一个模块。前置加载依赖。</li><li>CMD：sea.js，按需加载，依赖就近。</li><li>ES6模块化：import导入，export导出。</li></ul><h2 id="缓存和离线存储"><a href="#缓存和离线存储" class="headerlink" title="缓存和离线存储"></a>缓存和离线存储</h2><h3 id="http缓存"><a href="#http缓存" class="headerlink" title="http缓存"></a>http缓存</h3><ul><li>判断Cache-Control或者expires，如果未过期，直接读取http缓存文件，不发送http请求。</li><li>判断是否有etag，有则带上if-none-mathch发送请求，未修改返回304，修改返回200。</li><li>判断是否有last-modified，有则带上if-modified-since，有效返回200，无效返回304。</li></ul><p><img src="https://images2017.cnblogs.com/blog/621603/201709/621603-20170925162600417-90375901.png" alt=""><br><code>crtl+f5</code>可以强制刷新。</p><h3 id="session-cookie-localStorage-sessionStorage"><a href="#session-cookie-localStorage-sessionStorage" class="headerlink" title="session cookie localStorage sessionStorage"></a>session cookie localStorage sessionStorage</h3><ul><li><p>session和cookie<br>session存在服务器端，cookie存在浏览器端。cookie只能保存字符串类型，session通过类似于hashtable的数据结构存储任何类型的对象。cookie4kb，session无限制。session更安全。</p></li><li><p>localStorage sessionStorage<br>localStorage永久，sessionStorage仅在当前会话下有效，关闭浏览器窗口失效。存储都是5MB。都存在客户端，只能存文本类型。lcoalStorage的接口有getItem、setItem、removeItem、clear，另外存储时还会触发storage事件。</p></li></ul><h3 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h3><p><code>&lt;html manifest=&quot;demo_html.appcache&quot;&gt;</code></p><p>其分为三个部分：</p><ul><li>CACHE MANIFEST 缓存</li><li>NETWORK 不缓存</li><li>FALLBACK 无法访问时的回退</li></ul><p>window.applicationCache.status可以访问缓存状态，分别为：UNCACHED、IDLE、CHECKING、DOWNLOADING、UPDATEREADY、IDLE</p><p>离线缓存与传统浏览器缓存区别：</p><ul><li>离线缓存是针对整个应用，浏览器缓存是单个文件</li><li>离线缓存断网了还是可以打开页面，浏览器缓存不行</li><li>离线缓存可以主动通知浏览器更新资源</li></ul><h3 id="http缓存机制"><a href="#http缓存机制" class="headerlink" title="http缓存机制"></a>http缓存机制</h3><ul><li>Cache-Control：响应头表示了资源是否可以被缓存，以及缓存的有效期。</li><li>Etag：响应头标识了资源的版本，此后浏览器可据此进行缓存以及询问服务器。</li><li>Last-Modified：响应头标识了资源的修改时间，此后浏览器可据此进行缓存以及询问服务器。</li></ul><p>缓存策略三要素：</p><ul><li>缓存存储策略</li><li>缓存过期策略</li><li>缓存对比策略</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;http相关&quot;&gt;&lt;a href=&quot;#http相关&quot; class=&quot;headerlink&quot; title=&quot;http相关&quot;&gt;&lt;/a&gt;http相关&lt;/h2&gt;&lt;h3 id=&quot;https&quot;&gt;&lt;a href=&quot;#https&quot; class=&quot;headerlink&quot; title=&quot;https&quot;&gt;&lt;/a&gt;https&lt;/h3&gt;&lt;p&gt;Https可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，即HTTP-SSL-TCP-IP,HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输.目前使用最广泛的是TLS 1.1、TLS 1.2。&lt;br&gt;HTTP面临的风险有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;窃听风险&lt;/li&gt;
&lt;li&gt;篡改风险&lt;/li&gt;
&lt;li&gt;冒充风险&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-5e2241fae8b593ff7f3b3a308ef81c10_hd.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="面试" scheme="https://vevlins.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="前端" scheme="https://vevlins.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>从零制作网页样式库</title>
    <link href="https://vevlins.github.io/2018/03/07/%E4%BB%8E%E9%9B%B6%E5%88%B6%E4%BD%9C%E7%BD%91%E9%A1%B5%E6%A0%B7%E5%BC%8F%E5%BA%93/"/>
    <id>https://vevlins.github.io/2018/03/07/从零制作网页样式库/</id>
    <published>2018-03-07T00:45:22.000Z</published>
    <updated>2018-03-07T00:49:34.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="广告-amp-教材"><a href="#广告-amp-教材" class="headerlink" title="广告&amp;教材"></a>广告&amp;教材</h2><p><a href="https://github.com/Vevlins/ponyo" target="_blank" rel="noopener">GitHub - Vevlins/ponyo: 一个puputongtong的前端样式库</a></p><p>这是我自己做的练习，包含若干基本元素和组件的样式控制，压缩后的体积只有25kb，项目结构和代码都比较清晰，加上这一系列的文章，应该很好理解。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>不说废话，先来看看项目结构。最主要的部分是<code>src</code>/<code>dist</code>/<code>gulpfile.js</code>。</p><ul><li>src 是dist中的sass和pug编译之后的文件，为常规的css和html文件。</li><li>dist是sass文件和pug文件，sass是用来编写样式的工具，pug是为了编写实例网页，方便我们在开发中实时看到效果。</li><li>gulpfile.js是前端工程自动化的文件，通过gulp这个工具控制sass和pug的编译、css的压缩、浏览器自动刷新等。通过它，我们对源文件进行更改后按下<code>crtl+s</code>就可以在浏览器中看到更改后的样式，而不需要在命令行下手工编译，再在浏览器中刷新。</li></ul><a id="more"></a><p>至于src中sass文件的组成，在以下目录树中有相关注释说明。</p><pre><code>├── LICENSE├── README.md├── dist //pug和sass输出到dist目录│   ├── css│   │   ├── ponyo.css│   │   └── ponyo.min.css│   └── example│      └── index.html├── docs //托管在github pages的文档│   ├── index.html│   └── ponyo.min.css├── gulpfile.js //！重要，前端工程自动化文件├── package-lock.json├── package.json└── src    ├── css    │   ├── base//全局的基础样式控制    │   │   ├── base.scss    │   │   ├── normalize.scss    │   │   ├── print.scss    │   │   └── typography.scss    │   ├── component//由多个标签或者标签加脚本组成的组件    │   │   ├── alert.scss    │   │   ├── annimation.scss    │   │   ├── article.scss    │   │   ├── modal.scss    │   │   ├── navbar.scss    │   │   ├── notice.scss    │   │   ├── pagination.scss    │   │   ├── panel.scss    │   │   ├── progress.scss    │   │   ├── tab.scss    │   │   └── tip.scss    │   ├── element//单一标签    │   │   ├── badge.scss    │   │   ├── button.scss    │   │   ├── form.scss    │   │   ├── icon.scss    │   │   ├── img.scss    │   │   ├── list.scss    │   │   └── table.scss    │   ├── layout//布局上的样式    │   │   ├── grid.scss//栅格系统    │   │   └── util.scss    │   ├── ponyo.scss    │   └── variable.scss    ├── example    │   └── index.pug    └── js        ├── component        │   ├── alert.js        │   ├── collapse.js        │   ├── modal.js        │   ├── progress.js        │   └── tip.js        └── ponyo.js</code></pre><h2 id="gulp文件"><a href="#gulp文件" class="headerlink" title="gulp文件"></a>gulp文件</h2><p>越是庞大的工程，越要从头开始认真搭建骨架。</p><pre><code>gulp.task(&#39;build:scss&#39;, function () {    return gulp.src(&#39;./src/css/ponyo.scss&#39;)        .pipe(sourcemaps.init())//sourcemap,调试时用来定位压缩后的文件        .pipe(header(banner, { pkg : pkg } ))        .pipe(autoprefixer({//浏览器兼容问题，自动加私有前缀            browsers: [&#39;since 2010&#39;],            cascade: false        }))        .pipe(sass().on(&#39;error&#39;, sass.logError))        .pipe(sourcemaps.write())        .pipe(gulp.dest(&#39;./dist/css/&#39;));});gulp.task(&#39;compress:scss&#39;,function(){    return gulp.src(&#39;./src/css/ponyo.scss&#39;)    .pipe(header(banner, { pkg : pkg } ))    .pipe(autoprefixer({        browsers: [&#39;since 2010&#39;],        cascade: false    }))    .pipe(sass({outputStyle: &#39;compressed&#39;}).on(&#39;error&#39;, sass.logError))    .pipe(cleanCSS())//压缩css    .pipe(rename(&quot;ponyo.min.css&quot;))    .pipe(gulp.dest(&#39;./dist/css/&#39;));})gulp.task(&#39;build:pug&#39;,function(){    return gulp.src(&#39;./src/example/index.pug&#39;)        .pipe(pug().on(&#39;error&#39;,function(){}))        .pipe(gulp.dest(&#39;./dist/example/&#39;));})gulp.task(&#39;connect&#39;,function() {//在dist目录下创建一个本地服务器    connect.server({        root: &#39;dist/&#39;,        livereload: true    });})gulp.task(&#39;reload:html&#39;,[&#39;build:pug&#39;],function(){    return gulp.src(&#39;./dist/example/**/*.html&#39;)    .pipe(connect.reload());})gulp.task(&#39;reload:css&#39;,[&#39;build:scss&#39;,&#39;compress:scss&#39;],function(){    return gulp.src(&#39;./src/**/*.scss&#39;)    .pipe(connect.reload());})gulp.task(&#39;watch&#39;,[&#39;connect&#39;],function(){    gulp.watch(&#39;./src/**/*.scss&#39;,[&#39;reload:css&#39;]);//当css文件变化时服务器刷新    gulp.watch(&#39;./src/example/index.pug&#39;,[&#39;reload:html&#39;]);//当html文件变化时服务器刷新})gulp.task(&#39;default&#39;,[&#39;connect&#39;,&#39;watch&#39;])</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;广告-amp-教材&quot;&gt;&lt;a href=&quot;#广告-amp-教材&quot; class=&quot;headerlink&quot; title=&quot;广告&amp;amp;教材&quot;&gt;&lt;/a&gt;广告&amp;amp;教材&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Vevlins/ponyo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub - Vevlins/ponyo: 一个puputongtong的前端样式库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是我自己做的练习，包含若干基本元素和组件的样式控制，压缩后的体积只有25kb，项目结构和代码都比较清晰，加上这一系列的文章，应该很好理解。&lt;/p&gt;
&lt;h2 id=&quot;项目结构&quot;&gt;&lt;a href=&quot;#项目结构&quot; class=&quot;headerlink&quot; title=&quot;项目结构&quot;&gt;&lt;/a&gt;项目结构&lt;/h2&gt;&lt;p&gt;不说废话，先来看看项目结构。最主要的部分是&lt;code&gt;src&lt;/code&gt;/&lt;code&gt;dist&lt;/code&gt;/&lt;code&gt;gulpfile.js&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;src 是dist中的sass和pug编译之后的文件，为常规的css和html文件。&lt;/li&gt;
&lt;li&gt;dist是sass文件和pug文件，sass是用来编写样式的工具，pug是为了编写实例网页，方便我们在开发中实时看到效果。&lt;/li&gt;
&lt;li&gt;gulpfile.js是前端工程自动化的文件，通过gulp这个工具控制sass和pug的编译、css的压缩、浏览器自动刷新等。通过它，我们对源文件进行更改后按下&lt;code&gt;crtl+s&lt;/code&gt;就可以在浏览器中看到更改后的样式，而不需要在命令行下手工编译，再在浏览器中刷新。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="css" scheme="https://vevlins.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://vevlins.github.io/tags/css/"/>
    
      <category term="web" scheme="https://vevlins.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>见微知著,还是新式连坐?</title>
    <link href="https://vevlins.github.io/2018/03/05/%E8%A7%81%E5%BE%AE%E7%9F%A5%E8%91%97-%E8%BF%98%E6%98%AF%E6%96%B0%E5%BC%8F%E8%BF%9E%E5%9D%90/"/>
    <id>https://vevlins.github.io/2018/03/05/见微知著-还是新式连坐/</id>
    <published>2018-03-05T02:41:14.000Z</published>
    <updated>2018-03-05T02:48:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>合肥女教师阻拦高铁发车一事不断发酵，社会舆论也是甚嚣尘上。该教师的单位对其进行停职处分，央视专门进入地方教育局调查。而后《新京报》则发文表示应该保护该女子。（澎湃新闻，1月12号）</p></blockquote><p>对于此事，笔者关注了一个点，即该女子的教师身份和舆论因其身份而导致的师德缺失，不配做老师的观点。</p><p>据永红路小学官方网站信息显示，2009年罗海丽所带班级荣获区级优秀中队，2010年她又被评为区级德育先进个人，2011年被评委区级优秀班主任。她连续3年荣获辅导学生作文比赛金奖，2011年8月教授的阅读录像课获得安徽省录像课一等奖，2011年12月荣获区级语文教学能手。</p><p>对于这些荣誉，有好事者问大家如何看待，也有网友慷慨激昂，批评该女子完全没有师德，不配教育学生，应当彻底开除。还有部分人恶意揣测这些荣誉都是凭着心机争抢来的。<br><a id="more"></a><br>孙中山抛弃原配妻子，仍被称作国父；郭沫若圆滑世故，不失为一代大师；小鲜肉私生活不检，还有脑残粉吹捧。为何教师身份一出，就要被全体抨击，并且“见微知著”，判定其师德缺失，之前的荣誉也都不是正常途径获得的呢？这种有罪的推定与文革时期的全民狂热是否有些许相似？</p><p>各种成功学书籍都极力吹捧以小事识人。然后这种极端情况下情绪处理不当所做的行动当真就可以作为罪证，判人“死刑”吗？单从理性的角度思考，这件事情的发生是有特定条件的，即丈夫晚点但是列车还未离站，情急之下有不明智的举动当然仍是违法行为，但是这种情况下的表现难道就是单位生活中的她吗？先是从小见大批判这个人道德有问题，接着又是从大到小，质疑一切取得的身份、荣誉。这也能算是有理有据吗？这不是规则，这是暴力。</p><p>“师德”这两个字一出，好似千斤大鼎，压的人喘不过气来。不错，教师这种特殊职业需要有更严格的行为准则规范，但是凡事要讲求规则，上车晚点不应该蛮横无理阻拦列车，媒体和司法也不能因为一件事引起舆论关注就越权行使权力，迎合公众。</p><p>道德和职业是两部分，私德和职业道德也是两部分。教师行业特殊，但是也是对于其职业道德的要求，不应该收红包、歧视学生等。假如因为一个教师身份便要求是道德上的圣人，那身为政治家的孙中山，是不是因为抛弃原配也要被怀疑以后便会抛弃国家？身为文学家的郭沫若，是不是因为圆滑世故也要被怀疑令后代文人没有骨气？身为演员的小鲜肉，是不是因为私生活不检点也要被怀疑粉丝也会有样学样？</p><p>因为一件事，便定罪整个人，这不是新式连坐吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;合肥女教师阻拦高铁发车一事不断发酵，社会舆论也是甚嚣尘上。该教师的单位对其进行停职处分，央视专门进入地方教育局调查。而后《新京报》则发文表示应该保护该女子。（澎湃新闻，1月12号）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于此事，笔者关注了一个点，即该女子的教师身份和舆论因其身份而导致的师德缺失，不配做老师的观点。&lt;/p&gt;
&lt;p&gt;据永红路小学官方网站信息显示，2009年罗海丽所带班级荣获区级优秀中队，2010年她又被评为区级德育先进个人，2011年被评委区级优秀班主任。她连续3年荣获辅导学生作文比赛金奖，2011年8月教授的阅读录像课获得安徽省录像课一等奖，2011年12月荣获区级语文教学能手。&lt;/p&gt;
&lt;p&gt;对于这些荣誉，有好事者问大家如何看待，也有网友慷慨激昂，批评该女子完全没有师德，不配教育学生，应当彻底开除。还有部分人恶意揣测这些荣誉都是凭着心机争抢来的。&lt;br&gt;
    
    </summary>
    
      <category term="杂感" scheme="https://vevlins.github.io/categories/%E6%9D%82%E6%84%9F/"/>
    
    
      <category term="连坐" scheme="https://vevlins.github.io/tags/%E8%BF%9E%E5%9D%90/"/>
    
      <category term="师德" scheme="https://vevlins.github.io/tags/%E5%B8%88%E5%BE%B7/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础</title>
    <link href="https://vevlins.github.io/2018/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>https://vevlins.github.io/2018/01/11/计算机网络基础/</id>
    <published>2018-01-11T13:20:41.000Z</published>
    <updated>2018-01-11T13:21:43.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1><p>以谢希仁《计算机网络》第五版教学课件为参考整理.</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h1><ul><li>分组交换和电路交换的比较.</li><li>有关码元、信道、香农定律、奈式准则、信噪比的计算.</li><li>码分复用的计算</li><li>CRC</li><li>0比特填充</li><li>CSMA/CD 协议</li><li>网桥自学习转发表</li><li>VLAN</li><li>虚电路和数据报</li><li>ARQ、滑动窗口、停止等待</li><li>RIP和OSPF</li><li>IP分类、子网掩码计</li><li>TCP的握手和挥手</li><li>路由表更新</li><li>局域网组网配置</li></ul><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>计算机网络的定义:计算机网络是一些互相连接的、自治的计算机的集合</li><li>我们平时说的网络包含三个:电信网络、有线电视网络、计算机网络.</li><li>internet指多个计算机网络互联形成的网络.Internet是专有名词,指的是全球最大的计算机网络,前身是ARPANET.</li><li>计算机网络发展的三个阶段:第一个阶段是从单个网络 ARPANET 向互联网发展、第二个阶段是建成了三级结构的因特网(主干网、地区网、企业网)、第三阶段是多层次ISP结构的因特网.</li><li>万维网 WWW 在20世纪九十年代被CERN开发.</li><li>网络边缘端系统的通信方式有客户服务器方式(C/S)和对等方式(P2P).</li><li>路由器的作用是实现分组交换,这是网络核心部分最重要的功能.处理分组的方案是:先收入缓存,查找转发表找到下一跳,在适当的端口转发出去,.</li><li>电路交换的特点:面向连接.三个阶段:建立连接、通信、释放连接.由于计算机数据具有突发性导致通信线路利用率很低</li><li>分组交换的特点:在发送端将较长的豹纹划分成固定长度的数据段,添加首部,依次把分组传输到接收端.首部中含有地址等控制信息.交换机根据地址信息实现存储转发.收到分组后还原.</li><li>分组交换的优点:高效、灵活、迅速、可靠</li><li>分组交换的问题:分组在转发时需要时延,首部信息带来额外开销.</li><li>计算机网络的性能指标:<ul><li>比特:一个二进制数字.速率即数据率(data rate)或比特率(bit rate).</li><li>带宽:数字信道所能传送的“最高数据率”的同义语，单位是“比特每秒”，或 b/s (bit/s).</li><li>吞吐量:在单位时间内通过某个网络（或信道、接口）的数据量</li><li>传输时延: 发送数据时，数据块从结点进入到传输媒体所需要的时间.数据块长度（比特）/信道带宽（比特/秒）</li><li>传播时延:电磁波在信道中需要传播一定的距离而花费的时间.信道长度（米）/信号在信道上的传播速率（米/秒）</li><li>信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）</li></ul></li><li>网络协议的组成要素:语法、语义、同步</li><li>分层的好处:各层独立、灵活、结构可分割、便于实现和维护、促进标准化工作.</li><li>五层协议体系结构:物理层、数据链路层、网络层、运输层、应用层.</li><li>实体(entity) 表示任何可发送或接收信息的硬件或软件进程</li><li>协议是控制两个对等实体进行通信的规则的集合</li><li>协议是水平的,服务是垂直的</li><li>同一系统相邻两层的实体进行交互的地方，称为服务访问点 SAP </li></ul><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><ul><li>物理层的主要任务是确定与传输媒体接口的特性.如机械特性、电气特性、功能特性、过程特性.</li><li>中继器：又叫转发器，功能是将信号整形放大再转发出去，以消除信号的失真和衰减，扩大网络传输的距离，其原理是信号再生，仅作用于电气部分，不管数据中是否有错误</li><li>集线器(HUB):实质上是多端口的中继器，也工作在物理层。一口接受数据信号，将其整形放大转发到其他所有(输入端除外)处于工作状态的端口上，多口输入，冲突-&gt;无效</li><li>码元:在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形.</li><li>几种通信:单工通信、半双工通信(双方交替)、全双工通信</li><li>码元传输的速率越高，或信号传输的距离越远，在信道的输出端的波形的失真就越严重。 </li><li>奈氏准则:在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能.</li><li>信道的极限信息传输速率 C : C = W log2(1+S/N)  b/s ; W 为信道的带宽（以 Hz 为单位）；S 为信道内所传信号的平均功率；N 为信道内部的高斯噪声功率。  ·</li><li>导引型传播媒体:双绞线(屏蔽、无屏蔽)、同轴电缆、光缆(单模光纤、双模光纤)、非导引型传输媒体:无线传输介质:无线电波、微波、红外线、激光.</li><li>频分复用:所有用户在同样的时间占用频率不同的带宽资源.</li><li>时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙</li><li>波分复用：光的频分复用</li><li>码分复用:各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现</li><li>宽带接入技术:ADSL、HFC、FTTx</li></ul><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><ul><li>数据链路层使用的信道:点对点信道ppp协议和广播信道.</li><li>链路(link)是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。<br>一条链路只是一条通路的一个组成部分。数据链路(data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</li><li>数据链路的基本单位是帧.</li><li>数据链路层解决的三个问题是封装成帧、透明传输、差错控制</li><li>封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。</li><li>透明传输:原始数据中出现控制符如何转义.0比特填充.</li><li>循环冗余检验 CRC:现在 k = 6, M = 101001。设 n = 3, 除数 P = 1101，被除数是 2nM = 101001000。 模 2 运算的结果是：商 Q = 110101，余数 R = 001。把余数 R 作为冗余码添加在数据 M 的后面发送出去。发送的数据是：2nM + R 即：101001001，共 (k + n) 位。 </li><li>在数据后面添加上的冗余码称为帧检验序列 FCS . CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法 </li><li>CRC不能实现可靠传输,需要确认和重传机制.</li><li>0比特填充:连续五个1之后加入一个0.</li><li>数据链路层的两个子层:逻辑链路控制 LLC (Logical Link Control)子层<br>媒体接入控制 MAC (Medium Access Control)子层.</li><li>通信适配器,也就是网卡,作用是:进行串行/并行转换。对数据进行缓存。在计算机的操作系统安装设备驱动程序。实现以太网协议。 </li><li>CSMA/CD 协议: Carrier Sense Multiple Access with Collision Detection.“多点接入”表示许多计算机以多点接入的方式连接在一根总线上。“载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 “碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。只能实现半双工通信.</li><li>退避算法:发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。</li><li>在局域网中，硬件地址又称为物理地址，或 MAC 地址。 </li><li>集线器的优缺点:使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信,扩大了局域网覆盖的地理范围.缺点是碰撞域增大了，但总的吞吐量并未提高。如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。   </li><li>网桥:在数据链路层扩展局域网.根据 MAC 帧的目的地址对收到的帧进行转发.具有过滤帧的功能</li><li>网桥的优缺点: 过滤通信量。 扩大了物理范围。提高了可靠性。可互连不同物理层、不同 MAC 子层和不同速率（如10 Mb/s 和 100 Mb/s 以太网）的局域网。缺点:存储转发增加了时延。 在MAC 子层并没有流量控制功能。 具有不同 MAC 子层的网段桥接在一起时时延更大。网桥只适合于用户数不太多(不超过几百个)和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。  </li><li>网桥和集线器的不同:集线器转发时不进行检查,而网桥会进行CSMA/CD算法.</li><li>透明网桥:“透明”是指局域网上的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的。 </li><li>在网桥的转发表中写入的信息除了地址和接口外，还有帧进入该网桥的时间。</li><li>避免产生转发的帧在网络中不断地兜圈子的方法是生成树.</li><li>以太网交换机:以太网交换机的每个接口都直接与主机相连，并且一般都工作在全双工方式。交换机能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，进行无碰撞地传输数据。 以太网交换机由于使用了专用的交换结构芯片，其交换速率就较高。    </li><li>虚拟局域网:虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组。这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的工作站是属于哪一个 VLAN。</li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><ul><li>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li><li>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。</li><li>IP协议.地址解析协议 ARP.(IP地址-&gt;物理地址)逆地址解析协议 RARP.网际控制报文协议 ICMP.网际组管理协议 IGMP都是网络层的协议,TCP、UDP是运输层的协议.</li><li>中间设备又称为中间系统或中继(relay)系统。物理层中继系统：转发器(repeater)。数据链路层中继系统：网桥或桥接器(bridge)。网络层中继系统：路由器(router)。网桥和路由器的混合物：桥路器(brouter)。网络层以上的中继系统：网关(gateway)。  </li><li>四类IP地址:A类0开头网络号8位,主机号24位.B类10开头网络号16位.C类110开头网络号24位.D类1110开头,多播地址.E类1111开头,保留地址.</li><li>IP分网络号和主机号:第一，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。第二，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。 </li><li>ARP:每一个主机都设有一个 ARP 高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。</li><li>ICMP:ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告.有两种报文种类:即 ICMP 差错报告报文和 ICMP 询问报文.Ping和Traceroute指令通过ICMP协议,不经过TCP或者UDP.</li><li>路由选择协议:内部网关协议 IGP( RIP 和 OSPF)和外部网关协议EGP( BGP-4)</li><li>RIP:是一种分布式的基于距离向量的路由选择协议,每一个路由器都要维护从它自己到其他每一个目的网络的距离记录.RIP 允许一条路径最多只能包含 15 个路由器.</li><li>RIP协议三个要点:仅和相邻路由器交换信息。 交换的信息是当前本路由器所知道的全部信息，即自己的路由表。 按固定的时间间隔交换路由信息，例如，每隔 30 秒。 </li><li>RIP的优缺点:优点:实现简单开销小,缺点是故障传输慢、网络规模小.</li><li>OSPF协议:是分布式的链路状态协议.OSPF 不用 UDP 而是直接用 IP 数据报传送。</li><li>OSPF的三个要点:向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。  </li><li>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫作区域。减少了整个网络上的通信量。</li><li>OSPF的五种分组类型:问候、数据库描述、链路状态请求、链路状态更新、链路状态确认.</li><li>MTU(路径最大传输单元)</li><li>CIDR:无类别域间路由.缓解了地址枯竭的趋势；控制甚至缩减了路由表的开销<br>分配IP地址的时候不再以类别来分，而是按照可变长的地址块来分配.基于可变长子网掩码VLSM.</li><li>拥塞控制:流量感知路由、准入控制、流量调节、负载丢弃、随机早期检测RED.</li><li>流量整形:漏桶、令牌桶.</li></ul><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><ul><li>应用进程之间的通信又称为端到端的通信。 运输层的一个很重要的功能就是复用和分用。应用层不同进程的报文通过不同的端口向下交到运输层，再往下就共用网络层提供的服务。IP协议提供主机之间的逻辑通信,而TCP/UDP提供进程之间的逻辑通信.</li><li>用户数据报协议 UDP  和  传输控制协议 TCP  ,TCP 要提供可靠的、面向连接的运输服务.</li><li>两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元 TPDU .</li><li>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能,不保证可靠交付，同时也不使用拥塞控制</li><li>TCP 是面向连接的运输层协议。每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。 TCP 提供可靠交付的服务。 TCP 提供全双工通信。面向字节流。  </li><li>TCP 连接的端点叫做套接字(socket)或插口。</li><li>ARQ:使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。这种可靠传输协议常称为自动重传请求ARQ (Automatic Repeat reQuest), ARQ 表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组 。</li><li>连续ARQ和回退NARQ.</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li>DNS:同时使用TCP和UDP:53</li><li>FTP:TCP:21</li><li>NFS:UDP</li><li>TFTP:UDP</li><li>TELNET:TCP:23</li><li>RPC:TCP</li><li>HTTP:TCP:80</li><li>SMTP:TCP:25,发邮件</li><li>POP3:TCP:110</li><li>IMAP:TCP</li><li>MIME:MIME类型是一种通知客户端其接收文件的多样性的机制:</li><li>DHCP:UDP</li><li>SNMP:UDP</li><li>POP3和IMAP的区别:POP3协议允许电子邮件客户端下载服务器上的邮件，但是在客户端的操作（如移动邮件、标记已读等），不会反馈到服务器上，比如通过客户端收取了邮箱中的3封邮件并移动到其他文件夹，邮箱服务器上的这些邮件是没有同时被移动的 。而IMAP提供webmail 与电子邮件客户端之间的双向通信，客户端的操作都会反馈到服务器上，对邮件进行的操作，服务器上的邮件也会做相应的动作。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机网络基础&quot;&gt;&lt;a href=&quot;#计算机网络基础&quot; class=&quot;headerlink&quot; title=&quot;计算机网络基础&quot;&gt;&lt;/a&gt;计算机网络基础&lt;/h1&gt;&lt;p&gt;以谢希仁《计算机网络》第五版教学课件为参考整理.&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目:&quot;&gt;&lt;/a&gt;题目:&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;分组交换和电路交换的比较.&lt;/li&gt;
&lt;li&gt;有关码元、信道、香农定律、奈式准则、信噪比的计算.&lt;/li&gt;
&lt;li&gt;码分复用的计算&lt;/li&gt;
&lt;li&gt;CRC&lt;/li&gt;
&lt;li&gt;0比特填充&lt;/li&gt;
&lt;li&gt;CSMA/CD 协议&lt;/li&gt;
&lt;li&gt;网桥自学习转发表&lt;/li&gt;
&lt;li&gt;VLAN&lt;/li&gt;
&lt;li&gt;虚电路和数据报&lt;/li&gt;
&lt;li&gt;ARQ、滑动窗口、停止等待&lt;/li&gt;
&lt;li&gt;RIP和OSPF&lt;/li&gt;
&lt;li&gt;IP分类、子网掩码计&lt;/li&gt;
&lt;li&gt;TCP的握手和挥手&lt;/li&gt;
&lt;li&gt;路由表更新&lt;/li&gt;
&lt;li&gt;局域网组网配置&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="network" scheme="https://vevlins.github.io/categories/network/"/>
    
    
      <category term="network" scheme="https://vevlins.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>Sass入门</title>
    <link href="https://vevlins.github.io/2018/01/09/Sass%E5%85%A5%E9%97%A8/"/>
    <id>https://vevlins.github.io/2018/01/09/Sass入门/</id>
    <published>2018-01-09T15:39:41.000Z</published>
    <updated>2018-01-09T15:40:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sass入门"><a href="#Sass入门" class="headerlink" title="Sass入门"></a>Sass入门</h1><p>编写css的工具主要有less、sass、stylus.具体谁优谁略很难定论.昨天看了下less,感觉有些用法理解起来很奇怪,而且功能上比sass稍弱一点,所以决定使用sass作为以后编写css的工具.sass和scss是一种东西的两种写法,scss与css的写法一致,而sass需要缩进,无分号等特性.以下介绍的是scss的写法.</p><h2 id="CIL"><a href="#CIL" class="headerlink" title="CIL"></a>CIL</h2><p>安装</p><pre><code class="bash">gem install sass</code></pre><p>编译风格:</p><ul><li>nested：嵌套缩进的css代码，它是默认值。</li><li>expanded：没有缩进的、扩展的css代码。</li><li>compact：简洁格式的css代码。</li><li>compressed：压缩后的css代码。</li></ul><p>监听:</p><pre><code class="bash">　// watch a file　　sass --watch input.scss:output.css　　// watch a directory　　sass --watch app/sass:public/stylesheets</code></pre><a id="more"></a><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>¥开头,声明方式如css属性一样使用<code>:</code>,如果嵌套在字符串中,比如放在属性名称中,需要写在#{}中.</p><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><p>支持计算.</p><h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><p>这里比较特别的是属性也是可以嵌套的.比如:</p><pre><code>font: {    family:xxx;    size:xxx;}</code></pre><p>另外&amp;可以在嵌套中表示上一层.</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p><code>/* */</code>样式的注视可以保留到css文件中,如果想要保留到压缩后,需要在一个*之后添加叹号,而<code>//</code>只会保留在sass文件中.</p><h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p><code>@extend 选择器</code>可以继承所选中选择器的所有属性.</p><h4 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h4><p>继承只能死板地复制粘贴过来,而mixin则更强大,它可以指定参数和缺省值.声明需要@mixin,使用需要@include</p><pre><code class="sass">　　@mixin left($value: 10px) {　　　　float: left;　　　　margin-right: $value;　　}</code></pre><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>通过@import可以插入外部文件,局部文件,也就是并不是想要编译出来的文件的用户名以下划线开始.</p><p>默认变量名.这是为了提高复用灵活性的一个特性,你可以在局部文件中声明变量时使用!default,在包含它的文件中另外声明覆盖掉这个default块.</p><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><p>这些高级功能可以说是sass与less抉择中最重要的一部分,虽然less也可以实现,但是其实现方案实在是太过诡异.</p><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>@if、@else用法和常规编程语言高度类似.</p><pre><code class="sass">　　@if lightness($color) &gt; 30% {　　　　background-color: #000;　　} @else {　　　　background-color: #fff;　　}</code></pre><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><pre><code class="sass">//for　　@for $i from 1 to 10 {　　　　.border-#{$i} {　　　　　　border: #{$i}px solid blue;　　　　}　　}//while　　$i: 6;　　@while $i &gt; 0 {　　　　.item-#{$i} { width: 2em * $i; }　　　　$i: $i - 2;　　}//each　　@each $member in a, b, c, d {　　　　.#{$member} {　　　　　　background-image: url(&quot;/image/#{$member}.jpg&quot;);　　　　}　　}</code></pre><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><p>使用@function可以编写函数,使用时实际产生的是retrn出来的语句.</p><pre><code class="sass">　　@function double($n) {　　　　@return $n * 2;　　}　　#sidebar {　　　　width: double(5px);　　}</code></pre><p>参考资料:</p><ul><li><a href="http://www.ruanyifeng.com/blog/2012/06/sass.html" target="_blank" rel="noopener">SASS用法指南 - 阮一峰的网络日志</a></li><li><a href="https://www.sass.hk/guide/" target="_blank" rel="noopener">https://www.sass.hk/guide/</a></li><li><a href="https://www.w3cplus.com/sassguide/" target="_blank" rel="noopener">sass入门 - sass教程</a></li><li><a href="https://www.w3cplus.com/preprocessor/sass-other-function.html" target="_blank" rel="noopener">Sass基础——Sass函数_Preprocessor, Sass, SCSS 教程_w3cplus</a></li><li><a href="https://www.sass.hk/skill/sass25.html" target="_blank" rel="noopener">Sass基础——颜色函数 | Sass中文网</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Sass入门&quot;&gt;&lt;a href=&quot;#Sass入门&quot; class=&quot;headerlink&quot; title=&quot;Sass入门&quot;&gt;&lt;/a&gt;Sass入门&lt;/h1&gt;&lt;p&gt;编写css的工具主要有less、sass、stylus.具体谁优谁略很难定论.昨天看了下less,感觉有些用法理解起来很奇怪,而且功能上比sass稍弱一点,所以决定使用sass作为以后编写css的工具.sass和scss是一种东西的两种写法,scss与css的写法一致,而sass需要缩进,无分号等特性.以下介绍的是scss的写法.&lt;/p&gt;
&lt;h2 id=&quot;CIL&quot;&gt;&lt;a href=&quot;#CIL&quot; class=&quot;headerlink&quot; title=&quot;CIL&quot;&gt;&lt;/a&gt;CIL&lt;/h2&gt;&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;gem install sass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译风格:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nested：嵌套缩进的css代码，它是默认值。&lt;/li&gt;
&lt;li&gt;expanded：没有缩进的、扩展的css代码。&lt;/li&gt;
&lt;li&gt;compact：简洁格式的css代码。&lt;/li&gt;
&lt;li&gt;compressed：压缩后的css代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;监听:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;　// watch a file
　　sass --watch input.scss:output.css
　　// watch a directory
　　sass --watch app/sass:public/stylesheets
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="sass" scheme="https://vevlins.github.io/categories/sass/"/>
    
    
      <category term="css" scheme="https://vevlins.github.io/tags/css/"/>
    
      <category term="sass" scheme="https://vevlins.github.io/tags/sass/"/>
    
  </entry>
  
  <entry>
    <title>操作系统总结</title>
    <link href="https://vevlins.github.io/2018/01/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/"/>
    <id>https://vevlins.github.io/2018/01/07/操作系统总结/</id>
    <published>2018-01-07T14:14:01.000Z</published>
    <updated>2018-01-07T14:16:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统总结"><a href="#操作系统总结" class="headerlink" title="操作系统总结"></a>操作系统总结</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>计算机系统的四个组成部分:计算机硬件、操作系统、系统程序与应用程序、用户.</li><li>计算机硬件包含什么:CPU、内存、IO.</li><li>什么是操作系统:管理计算机硬件的程序.</li><li>操作系统的目标:方便性、有效性、可扩充性、开放性.</li><li>操作系统的基本特征:并发性、共享性、虚拟性、异步性.</li><li>操作系统的基本类型:批处理系统、分时系统、实时系统</li><li>内核态和用户态的区别:内核态:控制计算机的硬件资源,并提供上层应用程序运行的环境.用户态:上层应用程序的活动空间,应用程序的执行依赖于内核提供的资源.内核态可以很好的保护硬件和资源的访问.<a id="more"></a></li><li>信号量semaphore的操作:P、V、wait.</li><li>管程Monitor:信号量机制功能强大，但使用时对信号量的操作分散，而且难以控制，读写和维护都很困难。因此后来又提出了一种集中式同步进程——管程。其基本思想是将共享变量和对它们的操作集中在一个模块中.管程就是代表共享资源的数据结构以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序共同构成的一个操作系统的资源管理模块.</li><li>多处理器调度:多处理器调度是根据处理器调度策略每次取出一个任务，将任务分配到处理器上运行的方法。多处理器调度包括给处理器分配进程、在单个处理器上是否使用多道程序技术、实际分派进程三个相关的方面。多处理器系统中线程调度通常有负载共享、成组调度、专用处理器分配、动态调度四种方式.非对称处理、对称多处理.</li><li>处理器亲和性:由于使缓存无效或重构的代价高，因而SMP努力的使一个进程在同一个处理器上运行，这被称为处理器亲和性.</li><li>负载平衡:负载平衡设法将工作负载平均地分配到SMP系统中的所有处理器上.</li><li>竞争范围:多对一和多对多模型上:PCS,进程竞争范围.一对一SCS,系统竞争范围.</li><li>用户态和内核态的转换:系统调用、异常、外围设备中断</li><li>多道程序设计:同时把多个作业放入内存交替执行,共享系统资源.可以减少CPU时间的浪费,增加系统吞吐量,提高系统效率.</li><li>中断和异常:中断也称为外中断,指来自CPU执行指令外部的事件,比如IO等,通常与当前程序无关.异常也称为内中断,是来自CPU执行指令内的事件,如非法操作码、地址越界等.</li><li>机制和策略:机制mechanism提供干什么,策略policy提供怎么做.</li><li>系统调用类别:进程控制、文件管理、设备管理、信息维护、通信</li><li>操作系统的结构:简单结构、分层结构、微内核结构、模块结构</li><li>原语是由若干条机器指令构成的一段程序，用以完成特定功能，这段程序在执行期间不可分割。即原语的执行不能被中断，原语操作具有原子性.</li><li>系统调用:指运行在用户态的程序向内核请求需要更高权限运行的服务。系统调用提供用户程序与操作系统之间的接口。<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2></li><li>进程:执行中的程序.</li><li>创建新进程的过程:分配进程号、分配空间、初始PCB、设置连接、创建或拓展其他数据结构.</li><li>非抢占和抢占的区别:让进程运行直到结束或阻塞的调度方式;允许将逻辑上可继续运行的在运行过程暂停的调度方式;抢占可以放置单一进程长时间占用cpu.</li><li>CPU调度的原因:提高CPU利用率;每个进程存在io、cpu两个过程,当进行io时可以进程进程调度以改善cpu利用率.</li><li>进程的三状态和无状态:运行、就绪、阻塞;创建、就绪、运行、等待、结束.</li><li>PCB的主要信息:进程状态、程序计数器、CPU寄存器、CPU调度信息.</li><li>长中短期调度:长期:哪一个程序被选中创建进程.中期:是否将进程调度内存.短期:哪个进程获得处理器资源.</li><li>上下文切换:CPU切换到另一个进程需要保存当前进程状态并且恢复另一个进程状态.上下文切换包括保存当前任务运行环境和恢复将要运行任务的运行环境.</li><li>共享内存和消息传递的比较:共享内存有公共状态,消息传递是显示传递.</li><li>线程:CPU使用的基本单位.包括线程ID、程序计数器、寄存器集合、栈.</li><li>线程和进程的比较:进程是系统资源分配的单位,线程的资源调度的单位.进程之间不能共享资源,进程有独立的地址空间,线程必须依赖进程存在.</li><li>多线程模型:一对一、多对一、多对多.</li><li>调度和分派的区别:调度是从就绪队列选择程序,分派是将进程加载到CPU.</li><li>常用调度算法:先到先服务、最短作业优先、最短剩余时间优先、轮转法、多级队列、多级反馈队列.</li><li>死锁:两个及以上的进程或者线程在执行过程中,因争夺资源造成的一种互相等待的现象.</li><li>死锁发生条件:互斥、占有等待、非抢占、循环等待.</li><li>临界资源和临界区:临界资源是每次仅允许一个进程访问的资源,每个进程中访问临界资源的那段代码称为临界区.</li><li>临界区问题解决的 三个条件:呼哧、空闲让进、有限等待.</li><li>调度基本特征:周转时间=作业完成时刻-到达时刻;带权周转时间=周转时间/服务时间;平均周转时间=作业周转总时间/昨夜个数;平均带权周转时间=带权周转总时间.<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2></li><li>内存交换的概念:把处于等待（阻塞）状态（或在CPU调度原则下被剥夺运行权利）的程序（进程）从内存移到辅存（外存），把内存空间腾出来，这一过程又叫换出。把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称为换入。中级调度（策略）就是釆用交换技术。</li><li>连续内存分配方案:单一连续分配、固定分区分配、动态分区分配.</li><li>内部碎片和外部碎片:内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间.外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域.</li><li>页表结构:层次页表、哈希页表、反向页表.</li><li>分页和分段的区别: (1) 页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率。段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。(2) 页的大小固定且由系统决定；而段的长度却不固定，决定于用户所编写的程序。(3) 分页的地址空间是一维的，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。</li><li>TLB:TLB是一个小的，虚拟寻址的缓存，其中每一行都保存着一个由单个PTE(Page Table Entry,页表项)组成的块。如果没有TLB，则每次取数据都需要两次访问内存，即查页表获得物理地址和取数据.</li><li>虚拟内存:虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换.</li><li>按需调页:只有程序执行需要时才载入页，那些从未访问的页不会调入到物理内存，也把这种页交换方式称为懒惰交换.</li><li>抖动问题:在请求分页存储管理中，刚被替换出去的页，立即又要被访问因无空,此时因无空闲内存，又要替换另一页，而后者又是下一次要被访问的页，于是系统需花费大量的时间忙于进行这种频繁的页面交换，致使系统的实际效率很低，这种现象称为抖动现象。一般都是由于置换算法不佳引起.</li><li>buffer和cache的区别:cache 是为了弥补高速设备和低速设备的鸿沟而引入的中间层，最终起到<strong>加快访问速度</strong>的作用。而 buffer 的主要目的进行流量整形，把突发的大数量较小规模的 I/O 整理成平稳的小数量较大规模的 I/O，以<strong>减少响应次数</strong>。</li><li>cache写机制:write through:CPU向cache写入数据时，同时向memory(后端存储)也写一份，使cache 和memory的数据保持一致。优点是简单，缺点是每次都要访问memory，速度比较慢.write back:cpu更新cache时，只是把更新的cache区标记一下，并不同步更新memory,(后端存储)。只是在cache区要被新进入的数据取代时，才更新memory.</li></ul><h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><ul><li>文件属性有哪些:名称、标识符、类型、位置、大小、保护等.</li><li>文件:记录在外存上的相关信息具有名称的集合.文件是逻辑外存的最小分配单位.</li><li>文件访问模型:顺序访问、直接访问、索引访问.</li><li>目录结构:单层结构、双层结构、树状结构.</li><li>目录的实现方式:线性、哈希.</li><li>数据分配方式:连续、链式、索引.</li><li>空闲空间管理方式:位向量、链表、组、计数.</li><li>磁盘调度算法:FCFS、SSTF、SCAN、C-SCAN、CLOCK.</li><li>DMA:直接内存访问（Direct Memory Access，DMA）是计算机科学中的一种内存访问技术。它允许某些电脑内部的硬件子系统（电脑外设），可以独立地直接读写系统内存，而不需中央处理器（CPU）介入处理.</li><li>DMA解决CPU同访问主存方式:(1)停止CPU访内存；(2)周期挪用；(3)DMA与CPU交替访问内存.</li><li>DMA使用方式:周期存取方式、直接存取方式、数据块传送方式.</li><li>DMA过程:1.告知设备驱动器2.设备驱动器告知磁盘3.磁盘初始化DMA传输.4.磁盘控制器向DMA传送字节5.DMA控制器向缓冲区传输.6.DMA中断CPU.</li></ul><ul><li>调度算法甘特图</li><li>信号量实现同步互斥</li><li>银行家算法</li><li>磁盘调度算法</li><li>页面置换算法</li><li>页表计算</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统总结&quot;&gt;&lt;a href=&quot;#操作系统总结&quot; class=&quot;headerlink&quot; title=&quot;操作系统总结&quot;&gt;&lt;/a&gt;操作系统总结&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;计算机系统的四个组成部分:计算机硬件、操作系统、系统程序与应用程序、用户.&lt;/li&gt;
&lt;li&gt;计算机硬件包含什么:CPU、内存、IO.&lt;/li&gt;
&lt;li&gt;什么是操作系统:管理计算机硬件的程序.&lt;/li&gt;
&lt;li&gt;操作系统的目标:方便性、有效性、可扩充性、开放性.&lt;/li&gt;
&lt;li&gt;操作系统的基本特征:并发性、共享性、虚拟性、异步性.&lt;/li&gt;
&lt;li&gt;操作系统的基本类型:批处理系统、分时系统、实时系统&lt;/li&gt;
&lt;li&gt;内核态和用户态的区别:内核态:控制计算机的硬件资源,并提供上层应用程序运行的环境.用户态:上层应用程序的活动空间,应用程序的执行依赖于内核提供的资源.内核态可以很好的保护硬件和资源的访问.
    
    </summary>
    
      <category term="os" scheme="https://vevlins.github.io/categories/os/"/>
    
    
      <category term="笔记" scheme="https://vevlins.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="操作系统" scheme="https://vevlins.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="os" scheme="https://vevlins.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>游戏策划-社交网络</title>
    <link href="https://vevlins.github.io/2018/01/05/%E6%B8%B8%E6%88%8F%E7%AD%96%E5%88%92%E6%A1%88-%E8%AF%B4%E6%83%B3%E6%B3%95%E6%9B%B4%E5%90%88%E9%80%82-%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C/"/>
    <id>https://vevlins.github.io/2018/01/05/游戏策划案-说想法更合适-社交网络/</id>
    <published>2018-01-05T13:48:12.000Z</published>
    <updated>2018-01-07T14:27:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="游戏策划-《社交网络》"><a href="#游戏策划-《社交网络》" class="headerlink" title="游戏策划-《社交网络》"></a>游戏策划-《社交网络》</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><p>这不像是一个游戏策划案,更像是一篇对人性探讨的哲学向论文.</p><h2 id="游戏概述"><a href="#游戏概述" class="headerlink" title="游戏概述:"></a>游戏概述:</h2><p>人本思想随着资本主义遍布全球.一句“我不在乎大国崛起,我只在乎小民尊严.”将所有人引导到了一个现实问题的岔路口上:做一个精致的利己主义者还是一个仁义道德的卫道士?<br><a id="more"></a><br>马克思和恩格斯说:</p><blockquote><p>“资产阶级在它已经取得了统治的地方把一切封建的、宗法的和田园诗般的关系都破坏了。它无情地斩断了把人们束缚于天然首长的形形色色的封建羁绊,它使人和人之间除了赤裸裸的利害关系,除了冷酷无情的“现金交易’ ,就再也没有任何别的联系了。”</p><p>你的思考呢?人生路上,这个社交网络拓扑图的每一条关联,是愈发健壮还是妻离子散,面对突如其来的疾病、失业、不快,你和你的亲友又会发生怎样的变化.</p></blockquote><p>这是一款人生模拟游戏,但是它并没有华丽的视图,或者应该用更恰当的说法——不需要.没有每天起床吃饭,而是直接面对最冰冷的现实,人生路上最难处理的事情,就是人与人的关系.</p><p>在这款游戏当中,你会和其他玩家一起诞生在一个错综复杂的人际网络中,每个玩家会被包围在众多AI和真实玩家中,每一个抉择,都会影响你的一级关系网络甚至更多,也许是越发稳健,也许是越发远离.你将面临生离死别,做出一个个切身利益相关的选择,金币和声望值等评价也会做出动态调整.社会整体面临的选项也会与当前社会的整体导向相关.当游戏时间结束,全社会的整体趋向将会导致评价体系内各个指标权重的不同,进而得到你最终的得分.当然,如果你因为某些选择导致众叛亲离或者自身死亡,游戏也将终止,并且会即时进行结算.</p><p>我们不设定任何的价值导向.所有的成功和失败的定义,都由所有玩家一起构建.</p><p>这里到底是温暖的伊甸园还是现实的名利场抑或是悲惨的人间炼狱?这不是一个简单的游戏,这是一个冰冷的问题,你的选择也并非仅仅是游戏中的一个变量,而可能就是现实生活的一次演习.</p><p>这款游戏,将引发你对于社会关系的深层次思考.回到最初那个问题:做一个精致的利己主义者还是一个仁义道德的卫道士?</p><h2 id="游戏背景"><a href="#游戏背景" class="headerlink" title="游戏背景:"></a>游戏背景:</h2><p>游戏的直接起因是一系列的知乎问题:</p><ul><li>如何看待丈夫28岁肝癌晚期，妻子打掉腹中五个月的孩子并要求离婚这一事件:<a href="https://www.zhihu.com/question/265004594" target="_blank" rel="noopener">https://www.zhihu.com/question/265004594</a></li><li>岳父重病生活不能自理，我提出离婚，妻子不同意。我该怎么办:<a href="https://www.zhihu.com/question/66231199" target="_blank" rel="noopener">https://www.zhihu.com/question/66231199</a></li></ul><p>面对这之类的问题,我看到了两个点,其一是女权婊的双标,这与游戏无关不赘述,其二就是一群回答者的“冷静客观”的思考,当然,基于利益的思考.</p><p>我们应该如何抉择呢?究竟是关注个人利益本身还是遵守现有的道德秩序?精英们的“不要站在道德高地上对他人的行为指手画脚”到底是真理还是婊子立牌坊式的价值观扭曲呢?</p><p>我并非是一个哲学家,无法给出结论,我只能根据自己的思考写下我自己的结论:</p><p>知乎的精致利己主义真是让人恶心，资产阶级利益驱动下生怕别人耽误自己的丑陋嘴脸。女权婊的双标也是恶心。读多了仁义道德，便矫枉过正，反对世人认同的，支持世人不认同的，仿佛就是真理，精英群体们的理性思考，不过是取反吗？</p><p>一个人道德败坏并不可怕，可怕的事社会竟然批判起别人的道德来，还要啐一口唾沫，歪着嘴说要是你赶上这样的事。此所谓以小人之心度君子之腹也。键盘上的道德不一定是行动上的道德，但至少还意味着整个社会的道德还未崩塌。你诚然可以选择不道德的选项，但没必要大张旗鼓颠倒黑白。</p><p>至于道德不道德，或者单纯的好不好的界定，简单的很，我有我的道，你有你的道，和自己的父母以及认识自己的爱人友人之前都声明出来。我声明的是孝悌，是死生不离，仁义礼智信。你声明的是不要耽误我的利益。</p><p>道德是一种社会群体契约，它在保证整个社会的互信和共赢，它在用社会导向来保证有仁义信者，虽然难免吃亏，但是依然受人尊重，依然有人激赏，以后得到更多人的帮助。个人的精致利己，着眼于人这一个独立单位，而以利益作为最小单位之间的关联。这里是零和游戏，世人都不是傻子，你要求一分利，我便少一分利，自以为地沾沾自喜，旁人却唯恐避之不及。</p><p>恶魔不可怕，可怕的是人心向魔鬼，私德崩塌不可怕，可怕的是社会舆论扭曲。你说道德高地上的圣人何以强制别人？我说你何以强制我不得发声呢？你说赶明天你遇上就好了，我说我会伤心难过，绝不会背信弃义。</p><p>嗟乎！大阉之乱，缙绅而能不易其志者，四海之大，有几人欤？而五人生于编伍之间，素不闻诗书之训，激昂大义，蹈死不顾，亦曷故哉？且矫诏纷出，钩党之捕遍于天下，卒以吾郡之发愤一击，不敢复有株治；大阉亦逡巡畏义，非常之谋难于猝发，待圣人之出而投缳道路，不可谓非五人之力也。</p><p>道不同者，不相为谋。大家频率不在同一波段上，你看我对牛弹琴，我看你油盐不进，全无意义。不认同的，可以直接删除拉黑。</p><p>当然,我个人的选择只能代表我自己,社会中的每一个人如何做出自己的选择呢?所以我想到了做这一款模拟游戏.不设定任何立场.基于人自己的选择模拟整个社会关系的演变,为玩家做一个提醒.</p><p>但是,我仍然希望,所有人,能够在这个游戏里面最终发现一个充满仁义礼智信的道德社会比一个充满金钱利益的资本社会更合理.这是我的初心,但是并不会故意如此设定,因为它的定位不仅是一个以教育为目的,希望引发玩家思考的游戏,更是一场残酷的社会实验.</p><h2 id="目标用户"><a href="#目标用户" class="headerlink" title="目标用户:"></a>目标用户:</h2><p>从游戏的概述和背景可以看出来,这个游戏的定位有两个:一是引发群体性思考,二是借助玩家的选择完成一场宏大的社会实验.</p><p>为了完成目的,这个游戏的用户应当是包含普罗大众的,因为社会也是这个样子,但是由于深入了解这款游戏所需要的哲学思考甚至计算过多,对于游戏感兴趣的可能更多是有一定文化知识,对心理和社会关系有过思考的小众群体.</p><p>另外,这个模拟游戏也有很好的教育意义,可以引入到中小学生群体进行人际关系教育.或者引入到监狱等机构,辅助进行改造教育.需要注意的是,这个游戏原本没有最终设定或者导向.所以如果明确用于教育作用,需要初期引入行为引导或参数更改.</p><p>为了完成游戏本身的目的,我们需要引入AI角色,达到社会网络整体的真实和平衡.但是由于缺乏足够的覆盖面积广的真实玩家,这个游戏的第二个目的可能注定失败.这是一款注定失败的游戏,但如果它能引发一定的思考,也足够光荣.</p><h2 id="游戏机制"><a href="#游戏机制" class="headerlink" title="游戏机制:"></a>游戏机制:</h2><p>每一局100个玩家,可以利用手中虚拟货币在进入游戏前选择自己诞生的身份.</p><p>进入游戏后,将会以玩家为中心呈现出一个简单的网络关系拓扑图.游戏中包含一定的AI角色.各个真实玩家之间不会有一级关联.每个玩家(包括AI)视作一个节点.并且有初始化的评价指标:财富值、声望值、道德值.每个玩家(包括AI)之间的会有默认的关联值.</p><p>多人组队时每个队伍都会建立一个社群.如果没有组队,则会随机分配一个社群.</p><p>在不同的时间段会解锁玩家不同的操作.并且会随机引入各种情况.比如生病、破产,玩家的所有操作将会广播给一级关联人,也可以付出一定的金币来请求屏蔽这条信息的广播.每隔十分钟,所有一级关联人和社群的声望前三名可以对每个人进行评议,决定对其声望和道德的增减.</p><p>玩家可以进行的操作有:</p><ol><li>解除与任意一个人的关系.(包括出卖)</li><li>建立与任意一个人的关系(主动建立关系需要对方同意)</li><li>与其他人(个人或者群体)发生互动:工作、交流、交易、游戏、嘲讽、打架等.</li><li>退出和加入其他社群.</li></ol><p>面板提示玩家进行各种操作可以获得的指标提升或者衰减.并且会导致人际关联值的变化.</p><p>指标的提升和衰减与否和具体值要根据不同的身份所在的社群的声望值前三名进行商定并通过全体投票通过.</p><p>社群所有成员的实时加权分数将会累加作为社群势力.社群势力将会在每隔十分钟进行排名.排名前30%、20%、10%的社群可以调整指标,调整额度分别为3分、2分、1分.第一名的社群可以强制指定其他社群的一个指标,但是需要付出本社群的财富值.被指定社群可以接受或者抵制,接受则获得财富值,抵制则损失财富值.做指定的社群的声望值相应变化.</p><p>随着游戏的进行,玩家的性格将会得到固化,自己的评价指标将会显示给关系网络中关联度较高的人.在固化之后,如果做出与自己已经被判定的性格相反的事情会付出额外的代价并且削弱判定的力度.如果是与判定的性格相同的事情则会增加判定的力度.</p><p>玩家会收到系统推荐的相同性格的人并且建立关联.</p><p>注意!游戏支持直接交流和金钱交易,所以所有的评议等可能存在并不公正的情况.</p><p>当死亡、所有关联破裂、游戏计时结束任意一种情况发生时,将会结束玩家操作并实时计算分数,其指标将在整场游戏结束时按照最终权重再次结算.两者直接相加作为总得分.</p><p>游戏结束后将会展示玩家在游戏过程中的社群势力、性格及其转变、直接相关关系图及其转变、最终得分.作为玩家对局信息供所有人查看.</p><p>得分将折算为金币,可以用于选择之后游戏的身份选择.</p><h2 id="游戏特色"><a href="#游戏特色" class="headerlink" title="游戏特色:"></a>游戏特色:</h2><p>这款游戏注定是一个小众游戏.一个看起来怪异SIM游戏.但是怪异往往意味着特色鲜明.</p><ol><li>教育意义.从游戏脱离出来到引发群体思考.</li><li>玩家构建的社交网络整体趋势影响评分权重,没有硬性指标,游戏高度灵活</li><li>面临的问题现实,更有模拟游戏的意义.</li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记:"></a>后记:</h2><p>这不是一个普通的打怪升级酣畅淋漓的游戏,你可能体会不到快感,反而感受到压力,这压力不是我给予你,而是社会给予你,至于是游戏里的社会还是现实生活的社会,只有你自己知道答案.<br>这是一个危险的游戏.我会像三体的1379号监听员一样给叶文洁最初发出的信号同样的回复:“不要回答！不要回答！不要回答！”</p><p>这里到底是温暖的伊甸园还是现实的名利场抑或是悲惨的人间炼狱?这不是一个简单的游戏,这是一个冰冷的问题,你的选择也并非仅仅是游戏中的一个变量,而可能就是现实生活的一次演习.</p><p>这款游戏,将引发你对于社会关系的深层次思考.回到最初那个问题:做一个精致的利己主义者还是一个仁义道德的卫道士?<br>给我你的回答吧.</p><p>Give me your answer.</p><p>Me Votre réponse.</p><p>私にあなたの回答をください.</p><p>너의 대답.</p><p>Дай мне свой ответ.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;游戏策划-《社交网络》&quot;&gt;&lt;a href=&quot;#游戏策划-《社交网络》&quot; class=&quot;headerlink&quot; title=&quot;游戏策划-《社交网络》&quot;&gt;&lt;/a&gt;游戏策划-《社交网络》&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h2&gt;&lt;p&gt;这不像是一个游戏策划案,更像是一篇对人性探讨的哲学向论文.&lt;/p&gt;
&lt;h2 id=&quot;游戏概述&quot;&gt;&lt;a href=&quot;#游戏概述&quot; class=&quot;headerlink&quot; title=&quot;游戏概述:&quot;&gt;&lt;/a&gt;游戏概述:&lt;/h2&gt;&lt;p&gt;人本思想随着资本主义遍布全球.一句“我不在乎大国崛起,我只在乎小民尊严.”将所有人引导到了一个现实问题的岔路口上:做一个精致的利己主义者还是一个仁义道德的卫道士?&lt;br&gt;
    
    </summary>
    
      <category term="随感" scheme="https://vevlins.github.io/categories/%E9%9A%8F%E6%84%9F/"/>
    
    
      <category term="游戏" scheme="https://vevlins.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="感想" scheme="https://vevlins.github.io/tags/%E6%84%9F%E6%83%B3/"/>
    
      <category term="哲学" scheme="https://vevlins.github.io/tags/%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>CSS3完全学习笔记三:BFC、IFC、GFC、FFC</title>
    <link href="https://vevlins.github.io/2017/12/30/CSS3%E5%AE%8C%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89-BFC%E3%80%81IFC%E3%80%81GFC%E3%80%81FFC/"/>
    <id>https://vevlins.github.io/2017/12/30/CSS3完全学习笔记三-BFC、IFC、GFC、FFC/</id>
    <published>2017-12-30T15:07:58.000Z</published>
    <updated>2017-12-30T15:08:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS3完全学习笔记三-BFC、IFC、GFC、FFC"><a href="#CSS3完全学习笔记三-BFC、IFC、GFC、FFC" class="headerlink" title="CSS3完全学习笔记三:BFC、IFC、GFC、FFC"></a>CSS3完全学习笔记三:BFC、IFC、GFC、FFC</h1><p>//待续!</p><p>FC的全称是Formatting Contexts,格式上下文.它决定了其子元素如何定位以及和其他元素的关系.原本的FC有两种,也就是BFC和IFC,其余两者是CSS3中定义的.</p><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>Block Formatting Context 叫做“块级格式化上下文”.</p><p>规则如下:</p><ul><li>内部的盒子会在垂直方向，一个个地放置；</li><li>盒子垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的上下margin会发生重叠；</li><li>每个元素的左边，与包含的盒子的左边相接触，即使存在浮动也是如此；</li><li>BFC的区域不会与float重叠；</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此；</li><li>计算BFC的高度时，浮动元素也参与计算。</li></ul><p>产生原因如下:</p><ul><li>根元素-body</li><li>float的属性不为none；</li><li>position为absolute或fixed；</li><li>display为table-cell, table-caption, inline-block//?</li><li>overflow不为visible</li></ul><p>用处:</p><ul><li>清除浮动</li><li>解决margin重叠<a id="more"></a></li></ul><h2 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h2><p>Inline Formatting Context叫做“内联格式化上下文”.</p><p>规则如下:</p><ul><li>框会从包含块的顶部开始，一个接一个地水平摆放。</li><li>摆放这些框的时候，它们在水平方向上的外边距、边框、内边距所占用的空间都会被考虑在内。在垂直方向上，这些框可能会以不同形式来对齐：它们可能会把底部或顶部对齐，也可能把其内部的文本基线对齐。能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的行框。水平的margin、padding、border有效，垂直无效。不能指定宽高。</li><li>行框的宽度是由包含块和存在的浮动来决定。</li></ul><p>用处:</p><ul><li>水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。</li><li>垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</li></ul><h2 id="GFC"><a href="#GFC" class="headerlink" title="GFC"></a>GFC</h2><p>GridLayout Formatting Contexts叫做”网格布局格式化上下文“.</p><p>产生原因:</p><ul><li>display值为grid</li></ul><h2 id="FFC"><a href="#FFC" class="headerlink" title="FFC"></a>FFC</h2><p>Flex Formatting Contexts叫做”自适应格式化上下文”.Flex Box 由伸缩容器和伸缩项目组成。通过设置元素的 display 属性为 flex 或 inline-flex 可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。</p><p>产生原因:</p><ul><li>display值为flex或者inline-flex</li></ul><p>参考资料:</p><ul><li><a href="http://www.cnblogs.com/fsjohnhuang/p/5259121.html" target="_blank" rel="noopener">CSS魔法堂：重新认识Box Model、IFC、BFC和Collapsing margins - ^_^肥仔John - 博客园</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CSS3完全学习笔记三-BFC、IFC、GFC、FFC&quot;&gt;&lt;a href=&quot;#CSS3完全学习笔记三-BFC、IFC、GFC、FFC&quot; class=&quot;headerlink&quot; title=&quot;CSS3完全学习笔记三:BFC、IFC、GFC、FFC&quot;&gt;&lt;/a&gt;CSS3完全学习笔记三:BFC、IFC、GFC、FFC&lt;/h1&gt;&lt;p&gt;//待续!&lt;/p&gt;
&lt;p&gt;FC的全称是Formatting Contexts,格式上下文.它决定了其子元素如何定位以及和其他元素的关系.原本的FC有两种,也就是BFC和IFC,其余两者是CSS3中定义的.&lt;/p&gt;
&lt;h2 id=&quot;BFC&quot;&gt;&lt;a href=&quot;#BFC&quot; class=&quot;headerlink&quot; title=&quot;BFC&quot;&gt;&lt;/a&gt;BFC&lt;/h2&gt;&lt;p&gt;Block Formatting Context 叫做“块级格式化上下文”.&lt;/p&gt;
&lt;p&gt;规则如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部的盒子会在垂直方向，一个个地放置；&lt;/li&gt;
&lt;li&gt;盒子垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的上下margin会发生重叠；&lt;/li&gt;
&lt;li&gt;每个元素的左边，与包含的盒子的左边相接触，即使存在浮动也是如此；&lt;/li&gt;
&lt;li&gt;BFC的区域不会与float重叠；&lt;/li&gt;
&lt;li&gt;BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此；&lt;/li&gt;
&lt;li&gt;计算BFC的高度时，浮动元素也参与计算。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;产生原因如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根元素-body&lt;/li&gt;
&lt;li&gt;float的属性不为none；&lt;/li&gt;
&lt;li&gt;position为absolute或fixed；&lt;/li&gt;
&lt;li&gt;display为table-cell, table-caption, inline-block//?&lt;/li&gt;
&lt;li&gt;overflow不为visible&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用处:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;清除浮动&lt;/li&gt;
&lt;li&gt;解决margin重叠
    
    </summary>
    
      <category term="css" scheme="https://vevlins.github.io/categories/css/"/>
    
    
      <category term="css" scheme="https://vevlins.github.io/tags/css/"/>
    
      <category term="bfc" scheme="https://vevlins.github.io/tags/bfc/"/>
    
      <category term="ifc" scheme="https://vevlins.github.io/tags/ifc/"/>
    
  </entry>
  
  <entry>
    <title>CSS计数器:counter</title>
    <link href="https://vevlins.github.io/2017/12/27/CSS%E8%AE%A1%E6%95%B0%E5%99%A8-counter/"/>
    <id>https://vevlins.github.io/2017/12/27/CSS计数器-counter/</id>
    <published>2017-12-27T07:49:09.000Z</published>
    <updated>2017-12-27T07:51:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS计数器-counter"><a href="#CSS计数器-counter" class="headerlink" title="CSS计数器:counter"></a>CSS计数器:counter</h1><p>Css计数器是css2开始支持的,只能用在content属性上.//关于css3的变化,语焉不详.援引css88的说法是:<code>在CSS2.1中counter()只能被使用在content属性上。</code></p><p>Counter并非只是一个单纯的属性,而是包含了以下几部分:</p><ul><li>counter-reset</li><li>counter-increment</li><li>counter</li><li>counters</li></ul><h2 id="counter-reset"><a href="#counter-reset" class="headerlink" title="counter-reset"></a>counter-reset</h2><p>在某个地方声明一个计数器,并且最初值为0.</p><p>语法:</p><pre><code class="css">counter-reset: [&lt;user-ident&gt; &lt;integer&gt;?]+ | none</code></pre><p>可以看出来,这里还可以设置初始值,需要注意的是,0是不会被显示在第一个上的,真正的显示是1,类似于++i.</p><h2 id="counter-increment"><a href="#counter-increment" class="headerlink" title="counter-increment"></a>counter-increment</h2><p>计数器增加.</p><p>这里还可以设置增量的不长,取负值也是允许的,如<code>counter-increment: counter-name 2;</code></p><h2 id="counter"><a href="#counter" class="headerlink" title="counter"></a>counter</h2><p>用在content属性内,控制显示的值.</p><p>可以设置表现形式,比如字母,罗马数字,具体的选项有:decimal, decimal-leading-zero, lower-roman, upper-roman, lower-greek, lower-latin, upper-latin, armenian, georgian, lower-alpha, upper-alpha.</p><p>设置的语法为:<code>content: counter(counter-name, lower-roman);</code></p><p>你也可以设置更灵活的方法,比如设置为第1章,第2章.只需要在content中进行拼凑即可.<code>content: &quot;第 &quot; counter(section) &quot; 章:</code></p><h2 id="counters"><a href="#counters" class="headerlink" title="counters"></a>counters</h2><p>支持嵌套.</p><p>语法:</p><pre><code class="css">counters( &lt;ident&gt;, &lt;string&gt; [, [ &lt;counter-style&gt; | none ] ]? )</code></pre><p>如果想要支持嵌套,<code>content: counters(section, &quot;.&quot;);</code>,需要使用counters并且声明使用的分割符号.</p><hr><p>在查阅资料的时候,偶然发现了以下两个规则:<code>@counter-style</code>和<code>symbols()</code>,他们可以用来在list里显示自定义的前缀,但是只有firefox支持,所以不做进一步学习.</p><p>参考资料:</p><ul><li><a href="http://www.css88.com/archives/6394" target="_blank" rel="noopener">http://www.css88.com/archives/6394</a></li><li><a href="https://css-tricks.com/almanac/properties/c/counter-increment/" target="_blank" rel="noopener">counter-increment | CSS-Tricks</a></li><li><a href="https://css-tricks.com/almanac/properties/c/counter-reset/" target="_blank" rel="noopener">https://css-tricks.com/almanac/properties/c/counter-reset/</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Counters" target="_blank" rel="noopener">使用CSS计数器 - Web开发者指南 | MDN</a></li><li><a href="https://www.quackit.com/css/functions/css_counters_function.cfm" target="_blank" rel="noopener">CSS counters() Function</a></li><li><a href="https://www.quackit.com/css/functions/css\_symbols_function.cfm" target="_blank" rel="noopener">https://www.quackit.com/css/functions/css\_symbols_function.cfm</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSS计数器-counter&quot;&gt;&lt;a href=&quot;#CSS计数器-counter&quot; class=&quot;headerlink&quot; title=&quot;CSS计数器:counter&quot;&gt;&lt;/a&gt;CSS计数器:counter&lt;/h1&gt;&lt;p&gt;Css计数器是css2开始支持的,只能用在c
      
    
    </summary>
    
      <category term="css" scheme="https://vevlins.github.io/categories/css/"/>
    
    
      <category term="笔记" scheme="https://vevlins.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="css" scheme="https://vevlins.github.io/tags/css/"/>
    
      <category term="counter" scheme="https://vevlins.github.io/tags/counter/"/>
    
  </entry>
  
  <entry>
    <title>CSS3完全学习笔记二: 属性全解</title>
    <link href="https://vevlins.github.io/2017/12/26/CSS3%E5%AE%8C%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C-%E5%B1%9E%E6%80%A7%E5%85%A8%E8%A7%A3/"/>
    <id>https://vevlins.github.io/2017/12/26/CSS3完全学习笔记二-属性全解/</id>
    <published>2017-12-26T15:10:01.000Z</published>
    <updated>2017-12-27T07:51:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS3完全学习笔记二-属性全解"><a href="#CSS3完全学习笔记二-属性全解" class="headerlink" title="CSS3完全学习笔记二: 属性全解"></a>CSS3完全学习笔记二: 属性全解</h1><p>对于目前没有主流浏览器支持的属性和一些需要特别学习的属性,在这篇笔记中没有学习.</p><h2 id="动画属性"><a href="#动画属性" class="headerlink" title="动画属性"></a>动画属性</h2><h3 id="keyframes"><a href="#keyframes" class="headerlink" title="@keyframes"></a>@keyframes</h3><p>使用@keyframes规则，你可以创建动画。<br>创建动画是通过逐步改变从一个CSS样式设定到另一个。指定的变化时发生时使用％，或关键字”from”和”to”，这是和0％到100％相同。</p><p>语法:</p><pre><code class="css">@keyframes animationname {keyframes-selector {css-styles;}}</code></pre><a id="more"></a><p>值:</p><ul><li>animationname    必需的。定义animation的名称。</li><li>keyframes-selector    必需的。动画持续时间的百分比。合法值：0-100%;from (和0%相同);to (和100%相同)</li><li>css-styles    必需的。一个或多个合法的CSS样式属性</li></ul><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p>动画复合属性.</p><p>语法:</p><pre><code class="css">animation: name duration timing-function delay iteration-count direction fill-mode play-state;</code></pre><p>值:</p><ul><li>animation-name</li><li>animation-duration :时间,s或者ms</li><li>animation-timing-function:速度曲线;linear; ease;ease-in;ease-out;ease-in-out;cubic-bezier(n,n,n,n)</li><li>animation-delay:延迟</li><li>animation-iteration-count:播放次数,infinite表示无限次</li><li>animation-direction:是否反向;normal;reverse; alternate;alternate-reverse</li><li>animation-fill-mode//?不理解;none;forwards; backwards; both</li><li>animation-play-state: 运行或者暂停.paused;running</li></ul><h2 id="背景属性"><a href="#背景属性" class="headerlink" title="背景属性"></a>背景属性</h2><h3 id="background"><a href="#background" class="headerlink" title="background"></a>background</h3><p>背景复合属性.</p><p>语法:</p><pre><code class="css">ackground:bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit;</code></pre><p>值:</p><ul><li>background-color:默认情况下是transparent<blockquote><p>合法的颜色值有:十六进制、rgb、rgba、hsl、hsla、浏览器定义颜色名称</p></blockquote></li><li>background-position:起始位置.可以用百分比、css单位、left、top等值<blockquote><p>注意对于这个工作在Firefox和Opera，background-attachment必须设置为 “fixed（固定）”.<br>关于css长度单位额外进行学习.</p></blockquote></li><li>background-size:背景图片大小。length:宽度-高度,未设置的为auto; percentage; cover(保持横纵比的最小); contain(保持横纵比的最大).这里可以想象正方形盒子和长方形图片.</li><li>background-repeat:repaat、repeat-x、repeat-y、repeat-y、inherit</li><li>background-origin:定位;padding-box;border-box;content-box;//设置repeat为no-repeat和position时可以看出效果</li><li>background-clip:背景绘制区域;border-box;padding-box;content-bo</li><li>background-attachment:是否固定:scroll、fixed</li><li>background-image:背景图:<blockquote><p>提示：请设置一种可用的背景颜色，这样的话，假如背景图像不可用，可以使用背景色带代替。</p></blockquote></li></ul><h2 id="边框和outline属性"><a href="#边框和outline属性" class="headerlink" title="边框和outline属性"></a>边框和outline属性</h2><h3 id="border"><a href="#border" class="headerlink" title="border"></a>border</h3><p>边框复合属性.</p><p>值:</p><ul><li>border-width: thin、medium、thick、length</li><li>border-style:none;hidden;dotted;dashed;solid;double;groove; ridge; inset;outset<blockquote><p>hidden:与 “none” 相同。不过应用于表时除外，对于表，hidden 用于解决边框冲突。//边框冲突另外学习</p></blockquote></li><li>border-color</li></ul><h3 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h3><p>outline（轮廓）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。与border高度类似,区别是不占用盒子.</p><p>值:</p><ul><li>outline-color</li><li>outline-style:没有hidden</li><li>outline-width</li></ul><h3 id="outline-offset"><a href="#outline-offset" class="headerlink" title="outline-offset"></a>outline-offset</h3><p>outline在border外边的便宜</p><h3 id="border-image"><a href="#border-image" class="headerlink" title="border-image"></a>border-image</h3><p>Css3新属性.九宫格划分.浏览器支持不佳</p><p>语法:</p><pre><code class="css">border-image: source slice width outset repeat|initial|inherit;</code></pre><p>值:</p><ul><li>border-image-source</li><li>border-image-slice//?不懂</li><li>border-image-width:number(倍数)、%、auto</li><li>border-image-outset //不懂</li><li>border-image-repeat:填充方式;stretch、repeat、round、space、</li></ul><h3 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h3><p>语法:</p><pre><code class="css">border-radius: 1-4 length|% / 1-4 length|%;</code></pre><h3 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h3><p>阴影.</p><p>语法:</p><pre><code class="css">box-shadow: h-shadow v-shadow blur spread color inset;</code></pre><p>值:</p><ul><li>h-shadow:必选</li><li>v-shadow:必选</li><li>blur:模糊距离</li><li>spread:阴影大小//?为什么是可选,默认多少</li><li>color</li><li>inset//不从右下角开始而是从左上角开始</li></ul><h2 id="盒子属性"><a href="#盒子属性" class="headerlink" title="盒子属性"></a>盒子属性</h2><h3 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h3><p>内容溢出框的处理方式</p><p>值:</p><ul><li>visible</li><li>hidden</li><li>scroll//不论是否剪裁都显示滚动条,至少在ie下如此</li><li>auto//只有超出才会显示滚动条</li></ul><h3 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h3><p>值:length/%(规定基于父元素的宽度的百分比的填充)</p><h3 id="height-width"><a href="#height-width" class="headerlink" title="height/width"></a>height/width</h3><p>值:auto;length;%(基于包含它的块级对象的百分比高度)</p><h3 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h3><p>值与padding类似</p><h3 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h3><p>盒子大小.</p><p>值:</p><ul><li>content-box</li><li>border-box</li></ul><h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><p>可否调整大小</p><p>值:</p><ul><li>none</li><li>both</li><li>horizontal</li><li>vertical</li></ul><h2 id="颜色属性"><a href="#颜色属性" class="headerlink" title="颜色属性"></a>颜色属性</h2><h3 id="opacity"><a href="#opacity" class="headerlink" title="opacity"></a>opacity</h3><p>透明度,从0-1.1表示完全透明.</p><h2 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h2><h3 id="font"><a href="#font" class="headerlink" title="font"></a>font</h3><p>字体复合属性.</p><p>值:</p><ul><li>font-style: normal、italic、oblique//oblique: 指的是将正常竖直文本倾斜;</li><li>font-variant:小型大写字母样式.normal/small-caps//存在的意义是什么???</li><li>font-weight:normal、bold、bolder、lighter;100-900.400等于normal,而700等于bold.//er是跟父元素比较</li><li>font-size/line-height:xx-small;x-small;small;medium;large;x-large;xx-large; smaller; larger;length;%(与父元素比较)</li><li>font-family:family-name - 指定的系列名称：具体字体的名称，比如：”times”、”courier”、”arial”。generic-family - 通常字体系列名称：比如：”serif”、”sans-serif”、”cursive”、”fantasy”、”monospace。</li></ul><hr><p>对于以下存在疑惑://表现大小差异</p><ul><li>caption</li><li>icon</li><li>menu</li><li>message-box</li><li>small-caption</li><li>status-bar</li></ul><h3 id="font-face"><a href="#font-face" class="headerlink" title="@font-face"></a>@font-face</h3><blockquote><p> Internet Explorer 9 只支持 .eot 类型的字体, Firefox, Chrome, Safari, 和 Opera 支持 .ttf 与.otf 两种类型字体.</p></blockquote><p>值:</p><ul><li>font-family:自行定义的名称</li><li>src</li><li>font-stretch</li><li>font-style</li><li>font-weight</li><li>unicode-range</li></ul><h2 id="内容生成属性"><a href="#内容生成属性" class="headerlink" title="内容生成属性"></a>内容生成属性</h2><h3 id="content"><a href="#content" class="headerlink" title="content"></a>content</h3><p>在:before和:after中添加内容.</p><p>值:</p><ul><li>none</li><li>normal</li><li>counter//计数器内容额外学习</li><li>attr(attribute)</li><li>string</li><li>open-quote</li><li>close-quote</li><li>no-open-quote//</li><li>no-close-quote//没看见效果</li><li>url(url)</li></ul><h3 id="quotes"><a href="#quotes" class="headerlink" title="quotes"></a>quotes</h3><p>定义选择器和嵌套时的引号包裹.</p><p>值:</p><ul><li>none</li><li>string string string string。前两个是一级引号,后两个是下一级</li></ul><h2 id="列表属性"><a href="#列表属性" class="headerlink" title="列表属性"></a>列表属性</h2><h3 id="list-style"><a href="#list-style" class="headerlink" title="list-style"></a>list-style</h3><p>语法:</p><pre><code class="css"> list-style-type, list-style-position, list-style-image.</code></pre><p>值:</p><ul><li>list-style-type:列表项标记,可选值过多,不一一指出,详细见附录</li><li>list-style-position:标记放在content内还是padding内. inside/outside</li><li>list-style-image:url()/none</li></ul><h2 id="多列属性"><a href="#多列属性" class="headerlink" title="多列属性"></a>多列属性</h2><h3 id="column-count"><a href="#column-count" class="headerlink" title="column-count"></a>column-count</h3><p>文本划分为几列//间隙如何控制。1em.列数和宽度同时满足必须挤压height吗?</p><p>值:</p><ul><li>number</li><li>auto</li></ul><h3 id="column-fil"><a href="#column-fil" class="headerlink" title="column-fil"></a>column-fil</h3><p>如何填充.</p><p>值:</p><ul><li>balance     长短均衡</li><li>auto 顺序填充</li></ul><h3 id="column-gap"><a href="#column-gap" class="headerlink" title="column-gap"></a>column-gap</h3><p>指定每一列之间的差距.</p><p>值:</p><ul><li>length</li><li>normal:1em</li></ul><h3 id="column-rule"><a href="#column-rule" class="headerlink" title="column-rule"></a>column-rule</h3><p>列之间规则的复合属性.</p><p>值:</p><ul><li>column-rule-width:列中间间隔线的宽度: thin medium thick length</li><li>column-rule-style:与border相同</li><li>column-rule-color</li></ul><h3 id="column-span"><a href="#column-span" class="headerlink" title="column-span"></a>column-span</h3><p>指定某个元素应该横跨多少列.在划分好container的列数之后,可能会有想要让其中某些跨的多,某些少.</p><p>值:</p><ul><li>1</li><li>all//所有</li></ul><h3 id="columns"><a href="#columns" class="headerlink" title="columns"></a>columns</h3><p>列宽和列数.</p><p>语法:</p><pre><code class="css">columns: column-width column-count;</code></pre><h2 id="定位属性"><a href="#定位属性" class="headerlink" title="定位属性"></a>定位属性</h2><h3 id="visibility"><a href="#visibility" class="headerlink" title="visibility"></a>visibility</h3><p>是否可见.//与display:none相比仍然会占据空间</p><p>值:</p><ul><li>visible</li><li>hidden</li><li>collapse<blockquote><p>当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上，会呈现为 “hidden”。//具体情境<a href="http://www.runoob.com/try/try.php?filename=trycss_visibility_collapse" target="_blank" rel="noopener">菜鸟教程在线编辑器</a></p></blockquote></li></ul><h3 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h3><p>堆叠顺序.拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面.<br>对非static元素起作用.</p><h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p>定位方式.</p><p>值:</p><ul><li>absolute :相对于 static 定位以外的第一个父元素进行定位</li><li>fixed</li><li>relative</li><li>static :元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）</li></ul><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>元素生成的框属性.</p><p>值过多,参考<a href="http://www.runoob.com/cssref/pr-class-display.html" target="_blank" rel="noopener">CSS display 属性 | 菜鸟教程</a></p><h3 id="cursor"><a href="#cursor" class="headerlink" title="cursor"></a>cursor</h3><p>光标样式.</p><p>值:</p><ul><li>url</li><li>crosshair</li><li>wait</li><li>help</li><li>等…</li></ul><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><p>盒子浮动.</p><p>值:</p><ul><li>left</li><li>right</li><li>none//默认值,不浮动</li></ul><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>指定段落的左侧或右侧不允许浮动的元素</p><p>值:</p><ul><li>left</li><li>right</li><li>both</li><li>none</li></ul><h3 id="clip"><a href="#clip" class="headerlink" title="clip"></a>clip</h3><p>对图像进行剪裁.</p><blockquote><p>注意：: 如果先有”overflow：visible”，clip属性不起作用。//那么根据这个说法,是不是clip是修改了盒子大小.</p></blockquote><p>值:</p><ul><li>shape:rect(top, right, bottom,left)</li><li>auto</li></ul><h2 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h2><h3 id="border-collapse"><a href="#border-collapse" class="headerlink" title="border-collapse"></a>border-collapse</h3><p>设置表格的边框是否被合并为一个单一的边框，还是象在标准的 HTML 中那样分开显示。</p><p>值:</p><ul><li>collapse</li><li>separate</li></ul><h3 id="border-spacing"><a href="#border-spacing" class="headerlink" title="border-spacing"></a>border-spacing</h3><p>相邻单元格边框之间的距离</p><p>值:</p><ul><li>length</li><li>length length //先水平,后垂直</li></ul><h3 id="caption-side"><a href="#caption-side" class="headerlink" title="caption-side"></a>caption-side</h3><p>表格标题的位置</p><p>值:</p><ul><li>top</li><li>bottom</li></ul><h3 id="empty-cells"><a href="#empty-cells" class="headerlink" title="empty-cells"></a>empty-cells</h3><p>隐藏表中的空单元格的边框和背景//有意义吗?</p><p>值:</p><ul><li>hide</li><li>show</li></ul><h3 id="table-layout"><a href="#table-layout" class="headerlink" title="table-layout"></a>table-layout</h3><p>列宽度的设定</p><p>值:</p><ul><li>automatic:根据内容适应</li><li>fixed:写死width</li></ul><h2 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h2><h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><p>值:</p><ul><li>color_name</li><li>hex</li><li>rgb</li></ul><h3 id="direction"><a href="#direction" class="headerlink" title="direction"></a>direction</h3><p>文本方向.</p><p>值:</p><ul><li>ltr</li><li>rtl</li></ul><h3 id="letter-spacing"><a href="#letter-spacing" class="headerlink" title="letter-spacing"></a>letter-spacing</h3><p>字符间隔.</p><p>值:</p><ul><li>normal</li><li>length(允许负值)</li></ul><h3 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h3><p>行高.</p><p>值:</p><ul><li>normal</li><li>number //与字体大小相乘</li><li>length</li><li>% //基于字体的</li></ul><h3 id="text-align"><a href="#text-align" class="headerlink" title="text-align"></a>text-align</h3><p>文本水平对齐.</p><p>值:</p><ul><li>left</li><li>right</li><li>center</li><li>justify</li></ul><h3 id="text-decoration"><a href="#text-decoration" class="headerlink" title="text-decoration"></a>text-decoration</h3><p>文本装饰//下划线及其他</p><p>值:</p><ul><li>none</li><li>underline</li><li>overline</li><li>line-through</li><li>blink//没有看到效果</li></ul><h3 id="text-indent"><a href="#text-indent" class="headerlink" title="text-indent"></a>text-indent</h3><p>文本首行缩进.</p><p>值:</p><ul><li>length</li><li>%//基于父元素宽度</li></ul><h3 id="text-transform"><a href="#text-transform" class="headerlink" title="text-transform"></a>text-transform</h3><p>控制文本的大小写</p><p>值:</p><ul><li>none</li><li>capitalize</li><li>uppercase</li><li>lowercase</li></ul><h3 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h3><p>垂直对齐方式.<br>//关于vertical-align和line-height进一步学习.<br>值:</p><ul><li>baseline</li><li>sub</li><li>super</li><li>top</li><li>text-top</li><li>middle</li><li>bottom</li><li>text-bottom</li><li>length</li><li>%:使用 “line-height” 属性的百分比值来排列此元素。允许使用负值。</li></ul><h3 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a>white-space</h3><p>空白如何处理//?</p><p>值:</p><ul><li>normal</li><li>pre 类似于pre标签</li><li>nowrap</li><li>pre-wrap:保留空白但是换行</li><li>pre-line 合并空白但是换行</li></ul><h3 id="word-spacing"><a href="#word-spacing" class="headerlink" title="word-spacing"></a>word-spacing</h3><p>单词间距.</p><p>值:</p><ul><li>normal</li><li>length</li></ul><h3 id="text-align-last"><a href="#text-align-last" class="headerlink" title="text-align-last"></a>text-align-last</h3><p>针对textalign=justify时的文本最后一行对齐.</p><p>值:</p><ul><li>auto</li><li>left</li><li>right</li><li>center</li><li>justify</li><li>start//根据text-derection而定</li><li>end</li></ul><h3 id="text-overflow"><a href="#text-overflow" class="headerlink" title="text-overflow"></a>text-overflow</h3><p>文本溢出处理方式.</p><p>值:</p><ul><li>clip</li><li>ellipsis :省略号</li><li>string:给定字符串表示,火狐下</li></ul><h3 id="text-shadow"><a href="#text-shadow" class="headerlink" title="text-shadow"></a>text-shadow</h3><p>文本阴影</p><p>值:</p><ul><li>h-shadow 必须</li><li>v-shadow 必须</li><li>blur</li><li>color</li></ul><h3 id="word-break"><a href="#word-break" class="headerlink" title="word-break"></a>word-break</h3><p>非cjk(中日韩)字符的断行规则</p><p>值: </p><ul><li>normal</li><li>break-all//单词内换行</li><li>keep-all //半角空格和连字符</li></ul><h3 id="word-wrap"><a href="#word-wrap" class="headerlink" title="word-wrap"></a>word-wrap</h3><p>换行规则.//与break的区别是什么?!!</p><p>值:</p><ul><li>normal</li><li>break-word:在长单词和url地址内部换行</li></ul><h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p>⚠️,并非所有属性都可以过渡.与keyframes相比过渡更强调两种状态之间的平稳过渡,而后者强调关键帧的存在.</p><p>语法:</p><pre><code class="css">transition: property duration timing-function delay;</code></pre><p>值:</p><ul><li>transition-property:过渡生效的属性:none/all/属性名称列表逗号分割</li><li>transition-duration:秒或者毫秒</li><li>transition-timing-function:速度曲线</li><li>transition-delay:开始延迟</li></ul><p>参考资料:</p><ul><li><a href="http://www.runoob.com/cssref/css-animatable.html" target="_blank" rel="noopener">CSS 动画 | 菜鸟教程</a></li><li><a href="http://www.runoob.com/cssref/css-units.html" target="_blank" rel="noopener">CSS 单位 | 菜鸟教程</a></li><li><a href="http://www.runoob.com/try/try.php?filename=trycss_border-style" target="_blank" rel="noopener">菜鸟教程在线编辑器</a></li><li><a href="http://www.zhangxinxu.com/wordpress/2010/01/css3-border-image/" target="_blank" rel="noopener">CSS3 border-image详解、应用及jQuery插件 «  张鑫旭-鑫空间-鑫生活</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-image-slice" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-image-slice</a></li><li><a href="http://www.runoob.com/try/playit.php?f=playcss_border-image-repeat&amp;preval=stretch" target="_blank" rel="noopener">在线实例</a></li><li><a href="http://www.css88.com/archives/6394" target="_blank" rel="noopener">http://www.css88.com/archives/6394</a></li><li><a href="http://www.runoob.com/cssref/pr-list-style-type.html" target="_blank" rel="noopener">CSS list-style-type 属性 | 菜鸟教程</a></li><li><a href="http://www.runoob.com/cssref/css3-pr-column-span.html" target="_blank" rel="noopener">CSS3 column-span 属性 | 菜鸟教程</a></li><li><a href="http://www.runoob.com/try/try.php?filename=trycss_visibility_collapse" target="_blank" rel="noopener">菜鸟教程在线编辑器</a></li><li><a href="http://www.runoob.com/cssref/pr-class-display.html" target="_blank" rel="noopener">CSS display 属性 | 菜鸟教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CSS3完全学习笔记二-属性全解&quot;&gt;&lt;a href=&quot;#CSS3完全学习笔记二-属性全解&quot; class=&quot;headerlink&quot; title=&quot;CSS3完全学习笔记二: 属性全解&quot;&gt;&lt;/a&gt;CSS3完全学习笔记二: 属性全解&lt;/h1&gt;&lt;p&gt;对于目前没有主流浏览器支持的属性和一些需要特别学习的属性,在这篇笔记中没有学习.&lt;/p&gt;
&lt;h2 id=&quot;动画属性&quot;&gt;&lt;a href=&quot;#动画属性&quot; class=&quot;headerlink&quot; title=&quot;动画属性&quot;&gt;&lt;/a&gt;动画属性&lt;/h2&gt;&lt;h3 id=&quot;keyframes&quot;&gt;&lt;a href=&quot;#keyframes&quot; class=&quot;headerlink&quot; title=&quot;@keyframes&quot;&gt;&lt;/a&gt;@keyframes&lt;/h3&gt;&lt;p&gt;使用@keyframes规则，你可以创建动画。&lt;br&gt;创建动画是通过逐步改变从一个CSS样式设定到另一个。指定的变化时发生时使用％，或关键字”from”和”to”，这是和0％到100％相同。&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;@keyframes animationname {keyframes-selector {css-styles;}}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="css" scheme="https://vevlins.github.io/categories/css/"/>
    
    
      <category term="css3" scheme="https://vevlins.github.io/tags/css3/"/>
    
      <category term="笔记" scheme="https://vevlins.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="教程" scheme="https://vevlins.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CSS3完全学习笔记一:选择器</title>
    <link href="https://vevlins.github.io/2017/12/25/CSS3%E5%AE%8C%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80-%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>https://vevlins.github.io/2017/12/25/CSS3完全学习笔记一-选择器/</id>
    <published>2017-12-25T11:55:15.000Z</published>
    <updated>2017-12-25T12:30:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS3完全学习笔记一-选择器"><a href="#CSS3完全学习笔记一-选择器" class="headerlink" title="CSS3完全学习笔记一:选择器"></a>CSS3完全学习笔记一:选择器</h1><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ul><li>.class   .intro 选择所有class中包含该值的元素</li><li>#id #intro  选择所有id=intro的元素</li><li>* 所有元素</li><li>element p 选择所有的p元素</li><li>,   div,p 选择所有的div元素和p元素</li><li>elment element 选择子(包含直接子元素和孙元素等)元素</li><li>> 直接子元素</li><li>+ 紧挨着前者的后者(直接弟节点)</li><li>[attribute] 包含该属性的</li><li>[attribute=value] 属性值为value的元素,加不加引号都可以</li><li>[attribute~=value] 属性值中包含该部分,类似于文本的匹配</li><li>[attribute|=value] 选择指定属性具有指定值开始(以-分隔开)的元素,可以没有后续部分</li><li>:link 未访问链接<a id="more"></a></li><li>:visited 访问过的链接</li><li>:active 活动链接,当点击链接时,该链接变为活动链接<br>这里为了显示正确需要按照顺序lvha书写</li><li>:hover 鼠标在链接上边时</li><li>:focus  获得焦点的输入元素</li><li>:first-letter 第一个字母<blockquote><p>只能设置以下属性: font properties;color properties ;background properties;margin properties;padding properties;border properties;text-decoration;vertical-align (only if float is ‘none’);text-transform;line-height;float;clear</p></blockquote></li></ul><p>这个地方的具体选择元素仍有困惑,比如设置为div:first-letter时,内直接嵌套p,那么p的首字母可以表现,而在p之前填充其他span、img标签则p没有表现.</p><ul><li>:first-line 第一行</li><li>:first-child  p:first-child  当p元素是父元素的第一个子元素时</li><li>:before 在元素之前添加内容,使用content 属性来指定要插入的内容。</li><li>:after 之后</li><li>:lang(language) p:lang(it) lang属性值的起始值为it的p元素</li></ul><hr><p>之后为css3新定义选择器</p><ul><li>element1~element2 p~ul p元素同一父元素之后的每一个ul元素. 与+类似,非直接弟节点</li><li>[attribute^=value] 属性以value开头,与|=类似,但是不要求以-分割</li><li>[attribute$=value] 结尾</li><li>[attribute*=value] 包含子串</li><li>:first-of-type  p:first-of-type, 是其父元素的第一个p子元素,与:nth-of-type(1)相同</li><li>:last-of-type,与:nth-last-of-type(1)相同</li><li>:only-of-type 唯一,不排除其他元素</li><li>:only-child 是父亲的唯一子元素</li><li>:nth-child(n) 是父亲的第n的子元素<blockquote><p>选择父元素E的第n个子元素F。其中n可以是整数（1，2，3）、关键字（even，odd）、可以是公式（2n+1）,而且n值起始值为1，而不是0.</p></blockquote></li><li>:last-child 最后一个子元素</li><li>:nth-last-child(n) 倒数第n</li><li>:nth-of-type(n)。第n个该类型的</li><li>:nth-last-of-type(n) 倒数第n</li><li>:root。根元素,在html中始终是<html></html></li><li>:empty 没有子元素和文本节点</li><li>:target//??? 匹配hash与id相对应的元素,但是safari、chrome没有效果</li><li>:enabled 启用的输入元素</li><li>:disabled</li><li>:checked 选中的输入元素</li><li>:not(selector)     排除</li><li>::selection 被选中的部分<blockquote><p>只可以应用于少数的CSS属性：color, background, cursor,和outline。</p></blockquote></li><li>:out-of-range 匹配值在指定区间之外的input元素</li><li>:in-range    </li><li>:read-write  用于匹配可读及可写的元素/区别于只读元素</li><li>:read-only 匹配设置 “readonly”（只读） 属性的元素</li><li>:optional 可选的输入元素,区别于required</li><li>:required </li><li>:valid 输入值合法的元素</li><li>:invalid 输入值不合法的元素</li></ul><hr><h2 id="Css选择器的分类"><a href="#Css选择器的分类" class="headerlink" title="Css选择器的分类:"></a>Css选择器的分类:</h2><p><img src="http://ozc9m7ly1.bkt.clouddn.com/282324267509975.jpg" alt=""></p><h2 id="伪-pseudo-类和伪选择器"><a href="#伪-pseudo-类和伪选择器" class="headerlink" title="伪(pseudo)类和伪选择器:"></a>伪(pseudo)类和伪选择器:</h2><p>伪类:对现有元素进行筛选;伪选择器:创造出不存在的新元素.</p><blockquote><p>The pseudo-class concept is introduced to permit selection based on information that lies outside of the document tree or that cannot be expressed using the other simple selectors.</p><p>Pseudo-elements create abstractions about the document tree beyond those specified by the document language. For instance, document languages do not offer mechanisms to access the first letter or first line of an element’s content. Pseudo-elements allow authors to refer to this otherwise inaccessible information. Pseudo-elements may also provide authors a way to refer to content that does not exist in the source document.</p></blockquote><p>伪类总是以一个冒号开头。伪元素通常以两个冒号开头。在 CSS2 时代，伪元素和伪类均是以一个冒号开头的；在 CSS2.1 之后，为了对伪元素和伪类加以区分，规定伪类继续以一个冒号开头，而伪元素改为以两个冒号开头。但是为了向前兼容，浏览器同样接受 CSS2 时代已经存在的伪元素（它们包括:before, :after, :first-line, :first-letter）的单冒号写法。但是对于 CSS2 之后所有新增的伪元素（例如::selection），必须采用双冒号写法。</p><p>一些老旧的浏览器不支持双冒号的写法，因此如果必须兼容旧浏览器，则应该使用单冒号写法。IE 从 9 开始支持双冒号写法。//是否意味着ie9之前的浏览器无法使用::selection?</p><p>参考资料:</p><ul><li><a href="https://www.cnblogs.com/AllenChou/p/4684753.html" target="_blank" rel="noopener">最全CSS3选择器 - AllenChou - 博客园</a></li><li><a href="https://www.renfei.org/blog/css-pseudo-class-and-pseudo-element.html" target="_blank" rel="noopener">CSS 伪类和伪元素的区别 - Blog - Renfei Song</a></li><li><a href="http://www.runoob.com/cssref/css-ref-aural.html" target="_blank" rel="noopener">CSS 听觉参考手册 | 菜鸟教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CSS3完全学习笔记一-选择器&quot;&gt;&lt;a href=&quot;#CSS3完全学习笔记一-选择器&quot; class=&quot;headerlink&quot; title=&quot;CSS3完全学习笔记一:选择器&quot;&gt;&lt;/a&gt;CSS3完全学习笔记一:选择器&lt;/h1&gt;&lt;h2 id=&quot;选择器&quot;&gt;&lt;a href=&quot;#选择器&quot; class=&quot;headerlink&quot; title=&quot;选择器&quot;&gt;&lt;/a&gt;选择器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;.class   .intro 选择所有class中包含该值的元素&lt;/li&gt;
&lt;li&gt;#id #intro  选择所有id=intro的元素&lt;/li&gt;
&lt;li&gt;* 所有元素&lt;/li&gt;
&lt;li&gt;element p 选择所有的p元素&lt;/li&gt;
&lt;li&gt;,   div,p 选择所有的div元素和p元素&lt;/li&gt;
&lt;li&gt;elment element 选择子(包含直接子元素和孙元素等)元素&lt;/li&gt;
&lt;li&gt;&gt; 直接子元素&lt;/li&gt;
&lt;li&gt;+ 紧挨着前者的后者(直接弟节点)&lt;/li&gt;
&lt;li&gt;[attribute] 包含该属性的&lt;/li&gt;
&lt;li&gt;[attribute=value] 属性值为value的元素,加不加引号都可以&lt;/li&gt;
&lt;li&gt;[attribute~=value] 属性值中包含该部分,类似于文本的匹配&lt;/li&gt;
&lt;li&gt;[attribute|=value] 选择指定属性具有指定值开始(以-分隔开)的元素,可以没有后续部分&lt;/li&gt;
&lt;li&gt;:link 未访问链接
    
    </summary>
    
      <category term="css" scheme="https://vevlins.github.io/categories/css/"/>
    
    
      <category term="css3" scheme="https://vevlins.github.io/tags/css3/"/>
    
      <category term="笔记" scheme="https://vevlins.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="教程" scheme="https://vevlins.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>http无状态和鉴权解决方案:cookie、session、token、oauth2及JWT</title>
    <link href="https://vevlins.github.io/2017/12/25/http%E6%97%A0%E7%8A%B6%E6%80%81%E5%92%8C%E9%89%B4%E6%9D%83%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-cookie%E3%80%81session%E3%80%81token%E3%80%81oauth2%E5%8F%8AJWT/"/>
    <id>https://vevlins.github.io/2017/12/25/http无状态和鉴权解决方案-cookie、session、token、oauth2及JWT/</id>
    <published>2017-12-25T10:33:12.000Z</published>
    <updated>2017-12-25T10:36:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="http无状态和鉴权解决方案-cookie、session、token、oauth2及JWT"><a href="#http无状态和鉴权解决方案-cookie、session、token、oauth2及JWT" class="headerlink" title="http无状态和鉴权解决方案:cookie、session、token、oauth2及JWT"></a>http无状态和鉴权解决方案:cookie、session、token、oauth2及JWT</h1><p>http协议本身是无状态的,但是在实际的web开发中常有一些操作需要有状态.比如想要访问一些私人访问权限的文章,或者这种操作需要明确当前用户身份.</p><p>显然,最简单的方案就是每次都发送账户和密码,但是这样重复操作用用户并不友好,对服务器页增添了额外的压力.为了解决无状态带来的鉴权问题,一般有以下几种解决方案:cookie、session、token.至于标题中提及的outh2、jwt本质上也是token方案.</p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>Cookie是储存在客户端的一串字符,一般说来大小不超过4kb.比如我们常见的记住密码功能,或者一些基于之前输入的提醒和默认配置,就是通过cookie来实现的,cookie简单说来就是一种本地存储方法.但是这里存储的信息常用来进行鉴权操作.cookie只能保存文本信息,浏览器可以禁止cookie.cookie的期限可以被自由设定,可以是仅仅一次浏览起效,也可以长达一年.如果是短期的,那么这些信息会被存储在内存中,如果是长期则会存储在硬盘上.cookie的起效范围是路径下的所有子路径.不允许其他来源的访问.</p><p>单纯的采用cookie来认证身份会带来一个比较麻烦的问题,就是伪造比较容易.因为这样处理,cookie中必然要带有身份信息,但是服务器也要解析这个身份信息,所以必然要在原理上支持双向的编码和解码,那么这个信息很容易被破解和进一步伪造.想一想,如果想要解决这个问题,我们常用的方案应该是加一个secret,而这个secret应该是放在服务器上的,服务器返回这样一个<code>带有secret编码的字符串</code>,而在服务器端再带上这个secret反向解密,如此一来,问题不就解决了吗?确实如此,但是这不代表cookie就安全,因为这已经不叫cookie了,而是我们要讲的第二个对象:session.<br><a id="more"></a></p><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>通过上面说的东西,我们已经能够获得身份信息,额外的,我们还可以把更复杂形式的信息都存储进来,因为这里没有cookie的纯文本限制.但是刚才说的<code>带有secret编码的字符串</code>也就是sessionid,依然要存储在客户端.是不是意味着session必定要依赖cookie呢?不是!想一想,我们实际上需要的是在每一次请求(至少是需要判定身份状态的请求中),都带上这个字符串,我们有以下这几种解决方案:</p><ul><li>cookie</li><li>表单隐藏字段:在form中放置一个隐藏的域</li><li>url重写:在url后边加上session的query段</li></ul><p>Session也可以设定有效时间.其实际的存储可以在内存、缓存、文件中.通过类似//可能具体实现不同.//hash表的数据结构存储.cookie是一个存在的实体,session是一种机制.</p><h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>对token的理解还不够,可能多有纰漏之处,待之后再进行修改.</p><p>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：</p><ul><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端<br>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li><li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li></ul><p>可以看出来,这里的token与sessionid有些类似,其区别:</p><ul><li>sessionid是带着之前的状态的,在服务器端可以getSession(sessionid)</li><li>token是在登录验证之后发放的一个包含着用户基本信息的较长的字符串,用处是验证身份以及简化后续获取信息的难度.</li><li>token机制更灵活,可以实现跨域</li></ul><h3 id="jwt"><a href="#jwt" class="headerlink" title="jwt"></a>jwt</h3><p>Jwt简单说来是一种token的具体实现规范!</p><p>Jwt标准的token有三个部分,中间用点分隔开，并且都会使用 Base64 编码:</p><ul><li>header<blockquote><p>header 部分主要是两部分内容，一个是 Token 的类型，另一个是使用的算法</p></blockquote></li><li>Payload <blockquote><p>里面是 Token 的具体内容，这些内容里面有一些是标准字段，你也可以添加其它需要的内容</p></blockquote></li><li>Signature<blockquote><p>编码以上两个部分并且加入一个secret使用信息摘要算法得出一个字符串</p></blockquote></li></ul><h3 id="oauth2"><a href="#oauth2" class="headerlink" title="oauth2"></a>oauth2</h3><p>简单来说,oauth是用来向第三方平台提供可以细致的权限管理的一种方案.</p><p>如何直接向第三方提供账号和密码,可能存在的问题有:</p><ul><li>不安全</li><li>无法更细致的限制授权范围和有效期</li><li>只有修改密码才能收回权限</li><li>一个第三方程序被破解将会导致用户密码泄漏</li></ul><p>OAuth的基本思路如下:</p><blockquote><p>OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。”客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章讲解的三种方案:cookie、session、token的理解可能会有问题,尤其是token和session很容易让人觉得token就是一种sessionid而已.简单的理解方式:</p><ul><li>Cookie 就是一个写着自己是谁的小纸条.共产党看到你,就无条件相信了你是狗蛋</li><li>Session是加入了领导最喜欢的一首诗的名字,然后和同志姓名拼起来编码成了一个字符串交给你.当共产党拿到的时候要先反向破解,然后认定你就是狗蛋,再去查找记事本上狗蛋的编制给他发了这个月的口粮.</li><li>Token是组织上经过审查认定你就是狗蛋,为了嫌麻烦不想下次再查记事本,所以把你的编制信息直接拼起来编码发给你,下次去的时候他们翻译出来你的编制直接给你发.</li></ul><p>目前对于这篇文章的内容依然有不理解之处,等待进一步修改.</p><p>参考资料:</p><ul><li><a href="https://my.oschina.net/biezhi/blog/490242#OSC_h2_3" target="_blank" rel="noopener">Http Session和Cookie - _</a></li><li><a href="http://blog.csdn.net/java_faep/article/details/78082802" target="_blank" rel="noopener">服务器端Session和客户端Session（和Cookie区别） - 曾梦想仗剑走天涯的博客 - CSDN博客</a></li><li><a href="https://www.zhihu.com/question/31079651" target="_blank" rel="noopener">https://www.zhihu.com/question/31079651</a></li><li><a href="http://blog.leapoahead.com/2015/09/06/understanding-jwt/" target="_blank" rel="noopener">http://blog.leapoahead.com/2015/09/06/understanding-jwt/</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">理解OAuth 2.0 - 阮一峰的网络日志</a></li><li><a href="https://zhuanlan.zhihu.com/p/28295641" target="_blank" rel="noopener">Web App Token 鉴权方案的设计与思考</a></li><li><a href="https://www.zhihu.com/question/39137156/answer/80228149" target="_blank" rel="noopener">app开发token、cookie的区别，账号密码加密又是如何保证安全？ - 知乎</a></li><li><a href="http://tech.colla.me/zh/show/token_session_cookie" target="_blank" rel="noopener">cookie &amp; session &amp; token的简单理解 | colla.me</a></li><li><a href="https://ninghao.net/blog/2834" target="_blank" rel="noopener">基于 Token 的身份验证 - 宁皓网</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;http无状态和鉴权解决方案-cookie、session、token、oauth2及JWT&quot;&gt;&lt;a href=&quot;#http无状态和鉴权解决方案-cookie、session、token、oauth2及JWT&quot; class=&quot;headerlink&quot; title=&quot;http无状态和鉴权解决方案:cookie、session、token、oauth2及JWT&quot;&gt;&lt;/a&gt;http无状态和鉴权解决方案:cookie、session、token、oauth2及JWT&lt;/h1&gt;&lt;p&gt;http协议本身是无状态的,但是在实际的web开发中常有一些操作需要有状态.比如想要访问一些私人访问权限的文章,或者这种操作需要明确当前用户身份.&lt;/p&gt;
&lt;p&gt;显然,最简单的方案就是每次都发送账户和密码,但是这样重复操作用用户并不友好,对服务器页增添了额外的压力.为了解决无状态带来的鉴权问题,一般有以下几种解决方案:cookie、session、token.至于标题中提及的outh2、jwt本质上也是token方案.&lt;/p&gt;
&lt;h2 id=&quot;cookie&quot;&gt;&lt;a href=&quot;#cookie&quot; class=&quot;headerlink&quot; title=&quot;cookie&quot;&gt;&lt;/a&gt;cookie&lt;/h2&gt;&lt;p&gt;Cookie是储存在客户端的一串字符,一般说来大小不超过4kb.比如我们常见的记住密码功能,或者一些基于之前输入的提醒和默认配置,就是通过cookie来实现的,cookie简单说来就是一种本地存储方法.但是这里存储的信息常用来进行鉴权操作.cookie只能保存文本信息,浏览器可以禁止cookie.cookie的期限可以被自由设定,可以是仅仅一次浏览起效,也可以长达一年.如果是短期的,那么这些信息会被存储在内存中,如果是长期则会存储在硬盘上.cookie的起效范围是路径下的所有子路径.不允许其他来源的访问.&lt;/p&gt;
&lt;p&gt;单纯的采用cookie来认证身份会带来一个比较麻烦的问题,就是伪造比较容易.因为这样处理,cookie中必然要带有身份信息,但是服务器也要解析这个身份信息,所以必然要在原理上支持双向的编码和解码,那么这个信息很容易被破解和进一步伪造.想一想,如果想要解决这个问题,我们常用的方案应该是加一个secret,而这个secret应该是放在服务器上的,服务器返回这样一个&lt;code&gt;带有secret编码的字符串&lt;/code&gt;,而在服务器端再带上这个secret反向解密,如此一来,问题不就解决了吗?确实如此,但是这不代表cookie就安全,因为这已经不叫cookie了,而是我们要讲的第二个对象:session.&lt;br&gt;
    
    </summary>
    
      <category term="http" scheme="https://vevlins.github.io/categories/http/"/>
    
    
      <category term="笔记" scheme="https://vevlins.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="http" scheme="https://vevlins.github.io/tags/http/"/>
    
      <category term="cookie" scheme="https://vevlins.github.io/tags/cookie/"/>
    
      <category term="session" scheme="https://vevlins.github.io/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>HTML5完全学习笔记四：api全解</title>
    <link href="https://vevlins.github.io/2017/12/23/HTML5%E5%AE%8C%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%EF%BC%9Aapi%E5%85%A8%E8%A7%A3/"/>
    <id>https://vevlins.github.io/2017/12/23/HTML5完全学习笔记四：api全解/</id>
    <published>2017-12-23T10:58:41.000Z</published>
    <updated>2017-12-25T12:05:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML5完全学习笔记四：api全解"><a href="#HTML5完全学习笔记四：api全解" class="headerlink" title="HTML5完全学习笔记四：api全解"></a>HTML5完全学习笔记四：api全解</h1><h2 id="地理定位"><a href="#地理定位" class="headerlink" title="地理定位"></a>地理定位</h2><p>地理位置 API 通过 navigator.geolocation 提供。默认不开启,需要请求.<br>Geolocation API 的数据来源可能是 GPS、IP 地址、RFID、WiFi、蓝牙 MAC 地址、GSM/CDMA 卡 ID 等。</p><p>方法如下:</p><ul><li>Geolocation.getCurrentPosition():获取位置返回position对象</li></ul><blockquote><p>这会异步地请求获取用户位置，并查询定位硬件来获取最新信息。当定位被确定后，定义的回调函数就会被执行。您可以选择性地提供第二个回调函数，当有错误时会被执行。第三个参数也是可选的，您可以通过该对象参数设定最长可接受的定位返回时间、等待请求的时间和是否获取高精度定位。</p></blockquote><a id="more"></a><pre><code class="javascript">var options = {  enableHighAccuracy: true,  timeout: 5000,  maximumAge: 0};function success(pos) {  var crd = pos.coords;  console.log(&#39;Your current position is:&#39;);  console.log(&#39;Latitude : &#39; + crd.latitude);  console.log(&#39;Longitude: &#39; + crd.longitude);  console.log(&#39;More or less &#39; + crd.accuracy + &#39; meters.&#39;);};function error(err) {  console.warn(&#39;ERROR(&#39; + err.code + &#39;): &#39; + err.message);};</code></pre><ul><li>Geolocation.watchPosition():位置监听器,每当改变,返回一个long类型的监听器id,用来传递给clearwatch停止监听.</li><li>Geolocation.clearWatch():取消由 watchPosition()注册的位置监听器。</li></ul><p>关于getCurrentPosition返回undefined的原因:</p><blockquote><p>This is because navigator.geolocation.getCurrentPosition is asynchronous. The getGeoLocation function returns before the anonymous callback function passed to getCurrentPosition has been executed, and since the getGeoLocation function has no return statement, it returns undefined.</p></blockquote><p>这是一个异步执行的函数,由于本身没有返回值,所以返回了undefined.</p><h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><p>H5的本地存储方案主要分为两类:webStorage和IndexedDB.其中webStorage分为localStorage和sessionStorage.indexedDB则是web SQL的替代方案.</p><h3 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h3><p>localStorage和sessionStorage的操作一致,主要区别是在保存时间上,前者可以一直保存,后者只保存在一个session内.大小限制视不同浏览器在5-20M之间.内部保存方式都是字符串方式,如果需要保存其他类型的数据需要自行转换.方法如下:</p><ul><li>保存数据：localStorage.setItem(key,value);</li><li>读取数据：localStorage.getItem(key);</li><li>删除单个数据：localStorage.removeItem(key);</li><li>删除所有数据：localStorage.clear();</li><li>得到某个索引的key：localStorage.key(index);</li></ul><h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h3><p>IndexedDB是为了能够在客户端存储大量的结构化数据，并且使用索引高效检索的API。采用异步API,其存储方式类似于Nosql.存储空间一般来说不少于250MB。支持事务和二进制存储.</p><blockquote><p>indexedDB 对象在旧版本的浏览器上是带有前缀的 (在 Gecko &lt; 16的情况下是 mozIndexedDB 属性，Chrome 中是 webkitIndexedDB ，以及IE10 的 msIndexedDB )。</p></blockquote><h3 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h3><p>HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。</p><p>manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。</p><p>manifest 文件可分为三个部分：</p><ul><li>CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存</li><li>NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存</li><li>FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</li></ul><p>一旦文件被缓存，则浏览器会继续展示已缓存的版本，即使您修改了服务器上的文件。为了确保浏览器更新缓存，您需要更新 manifest 文件。</p><h2 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h2><p>web worker 是运行在后台的 JavaScript,独立于UI进程,可以用来做一些高度消耗CPU的工作.</p><p>在外部文件中用postMessage来传送消息,在原文件用onmessage获取消息. <code>w=new Worker(&quot;demo_workers.js&quot;);</code>创建worker,<code>w.terminate();</code>终止worker.</p><h2 id="Server-Sent-Events"><a href="#Server-Sent-Events" class="headerlink" title="Server-Sent Events"></a>Server-Sent Events</h2><p>实现服务器向浏览器的推送.SSE使用的是http协议,而WebSocket 是一个独立协议.其用来传送文本信息,可以自定义发送的消息类型.SSE 要求服务器与浏览器保持连接.</p><blockquote><p>严格地说，HTTP 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息（streaming）。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。本质上，这种通信就是以流信息的方式，完成一次用时很长的下载。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 HTTP 协议，目前除了 IE/Edge，其他浏览器都支持。</p></blockquote><h3 id="前端实现"><a href="#前端实现" class="headerlink" title="前端实现"></a>前端实现</h3><p><code>var source = new EventSource(url, { withCredentials: true });</code>生成示例,可以跨域.连接一旦建立，就会触发open事件，可以在onopen属性定义回调函数。客户端收到服务器发来的数据，就会触发message事件，可以在onmessage属性的回调函数。<code>source.close();</code>关闭连接.</p><pre><code class="javascript">source.onmessage = function (event) {  var data = event.data;  // handle message};</code></pre><p>默认情况下，服务器发来的数据，总是触发浏览器EventSource实例的message事件。开发者还可以自定义 SSE 事件，这种情况下，发送回来的数据不会触发message事件。</p><h3 id="服务器端实现"><a href="#服务器端实现" class="headerlink" title="服务器端实现"></a>服务器端实现</h3><p>Content-Type必须指定 MIME 类型为event-steam.每一次发送的信息，由若干个message组成，每个message之间用\n\n分隔。每个message内部由若干行组成，每一行都是如下格式:<code>[data/event/id/retry]: value\n</code>,此外，还可以有冒号开头的行，表示注释。如果data很长，可以分成多行，最后一行用\n\n结尾，前面行都用\n结尾。数据标识符用id字段表示，相当于每一条数据的编号。event字段表示自定义的事件类型，默认是message事件。服务器可以用retry字段，指定浏览器重新发起连接的时间间隔。</p><blockquote><p>浏览器用lastEventId属性读取这个值。一旦连接断线，浏览器会发送一个 HTTP 头，里面包含一个特殊的Last-Event-ID头信息，将这个值发送回来，用来帮助服务器端重建连接。因此，这个头信息可以被视为一种同步机制。</p></blockquote><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。     </p><pre><code class="javascript">var ws = new WebSocket(&quot;wss://echo.websocket.org&quot;);ws.onopen = function(evt) {   console.log(&quot;Connection open ...&quot;);   ws.send(&quot;Hello WebSockets!&quot;);};ws.onmessage = function(evt) {  console.log( &quot;Received Message: &quot; + evt.data);  ws.close();};ws.onclose = function(evt) {  console.log(&quot;Connection closed.&quot;);};</code></pre><p>服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。</p><p>参考资料:</p><ul><li><a href="http://javascript.ruanyifeng.com/bom/indexeddb.html" target="_blank" rel="noopener">IndexedDB：浏览器端数据库 — JavaScript 标准参考教程（alpha）</a></li><li><a href="http://www.runoob.com/html/html5-webstorage.html" target="_blank" rel="noopener">HTML5 Web 存储 | 菜鸟教程</a></li><li><a href="https://www.cnblogs.com/LuckyWinty/p/5699117.html" target="_blank" rel="noopener">前端HTML5几种存储方式的总结 - 小蚊 - 博客园</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers" target="_blank" rel="noopener">Functions and classes available to Web Workers - Web APIs | MDN</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation" target="_blank" rel="noopener">Geolocation - Web API 接口 | MDN</a></li><li><a href="http://www.alloyteam.com/2015/11/deep-in-web-worker/" target="_blank" rel="noopener">【转向Javascript系列】深入理解Web Worker | AlloyTeam</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html" target="_blank" rel="noopener">Server-Sent Events 教程 - 阮一峰的网络日志</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">WebSocket 教程 - 阮一峰的网络日志</a></li><li><a href="http://websocketd.com" target="_blank" rel="noopener">websocketd</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTML5完全学习笔记四：api全解&quot;&gt;&lt;a href=&quot;#HTML5完全学习笔记四：api全解&quot; class=&quot;headerlink&quot; title=&quot;HTML5完全学习笔记四：api全解&quot;&gt;&lt;/a&gt;HTML5完全学习笔记四：api全解&lt;/h1&gt;&lt;h2 id=&quot;地理定位&quot;&gt;&lt;a href=&quot;#地理定位&quot; class=&quot;headerlink&quot; title=&quot;地理定位&quot;&gt;&lt;/a&gt;地理定位&lt;/h2&gt;&lt;p&gt;地理位置 API 通过 navigator.geolocation 提供。默认不开启,需要请求.&lt;br&gt;Geolocation API 的数据来源可能是 GPS、IP 地址、RFID、WiFi、蓝牙 MAC 地址、GSM/CDMA 卡 ID 等。&lt;/p&gt;
&lt;p&gt;方法如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Geolocation.getCurrentPosition():获取位置返回position对象&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这会异步地请求获取用户位置，并查询定位硬件来获取最新信息。当定位被确定后，定义的回调函数就会被执行。您可以选择性地提供第二个回调函数，当有错误时会被执行。第三个参数也是可选的，您可以通过该对象参数设定最长可接受的定位返回时间、等待请求的时间和是否获取高精度定位。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="html" scheme="https://vevlins.github.io/categories/html/"/>
    
    
      <category term="笔记" scheme="https://vevlins.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="教程" scheme="https://vevlins.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="html5" scheme="https://vevlins.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>HTML5完全学习笔记三：canvas全解</title>
    <link href="https://vevlins.github.io/2017/12/23/HTML5%E5%AE%8C%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89%EF%BC%9Acanvas%E5%85%A8%E8%A7%A3/"/>
    <id>https://vevlins.github.io/2017/12/23/HTML5完全学习笔记三：canvas全解/</id>
    <published>2017-12-23T10:57:41.000Z</published>
    <updated>2017-12-23T11:04:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML5完全学习笔记三：canvas全解"><a href="#HTML5完全学习笔记三：canvas全解" class="headerlink" title="HTML5完全学习笔记三：canvas全解"></a>HTML5完全学习笔记三：canvas全解</h1><p>Canvas用于通过js绘制图片和动画。最早由apple引入webkit。</p><p>Canvas元素只有width和height属性，默认情况下的值为300*150.该元素可以使用CSS来定义大小，但在绘制时图像会伸缩以适应它的框架尺寸：如果CSS的尺寸与初始画布的比例不一致，它会出现扭曲。尽量使用width和height来设定canvas的形状大小而非css。</p><h2 id="getContext"><a href="#getContext" class="headerlink" title="getContext"></a>getContext</h2><p>访问绘图上下文，检测是否支持canvas也可以通过检测getcontext。</p><pre><code>var canvas = document.getElementById(&#39;tutorial&#39;);if (canvas.getContext){  var ctx = canvas.getContext(&#39;2d&#39;);} else {}</code></pre><a id="more"></a><h2 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h2><p>Canvas只支持一种原生的图像绘制，就是矩形。其他图形的绘制都需要路径实现。</p><p>绘制矩形的方式：</p><ul><li>fillRect(x, y, width, height)//fill表示填充</li><li>strokeRect(x, y, width, height)//stroke表示边框</li><li>clearRect(x, y, width, height)//清除使之变透明</li><li>rect(x, y, width, height)//该方法执行时，笔触自动回复道默认位置//？执行时？是指绘制完之后再绘制下一个的时候吗？</li></ul><h2 id="通过路径绘图"><a href="#通过路径绘图" class="headerlink" title="通过路径绘图"></a>通过路径绘图</h2><ul><li>首先，你需要创建路径起始点。<blockquote><p>beginPath()：当前路径为空，即调用beginPath()之后，或者canvas刚建的时候，第一条路径构造命令通常被视为是moveTo（），无论最后的是什么。出于这个原因，你几乎总是要在设置路径之后专门指定你的起始位置。</p></blockquote></li><li>然后你使用画图命令去画出路径。</li><li>之后你把路径封闭。<blockquote><p>cloasepath（）：绘制一条从当前点到开始点的直线来闭合图形。如果图形是已经闭合了的，即当前点为开始点，该函数什么也不做。</p></blockquote></li><li>一旦路径生成，你就能通过描边或填充路径区域来渲染图形。<blockquote><p>当你调用fill()函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用closePath()函数。但是调用stroke()时不会自动闭合。</p></blockquote></li></ul><h3 id="移动笔触"><a href="#移动笔触" class="headerlink" title="移动笔触"></a>移动笔触</h3><p>moveTo（x，y）：用来绘制不连续的路径。</p><h3 id="绘制直线"><a href="#绘制直线" class="headerlink" title="绘制直线"></a>绘制直线</h3><p>lineTo（x，y）：绘制从当前到目的坐标的直线。</p><h3 id="圆弧"><a href="#圆弧" class="headerlink" title="圆弧"></a>圆弧</h3><p>arc(x, y, radius, startAngle, endAngle, anticlockwise)：画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。</p><p>其中的角度单位是弧度而非度数。<code>radians=(Math.PI/180)*degrees</code>。</p><h3 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h3><p>quadraticCurveTo(cp1x, cp1y, x, y)：绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。</p><p>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)：绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。</p><h2 id="path2D"><a href="#path2D" class="headerlink" title="path2D"></a>path2D</h2><p>Path2D用来缓存或记录绘画命令。简单来说，可以认为它用来存储一系列的绘画指令，用以简化重复操作。</p><pre><code class="javascript">function draw() {  var canvas = document.getElementById(&#39;canvas&#39;);  if (canvas.getContext){    var ctx = canvas.getContext(&#39;2d&#39;);    var rectangle = new Path2D();    rectangle.rect(10, 10, 50, 50);    var circle = new Path2D();    circle.moveTo(125, 35);    circle.arc(100, 35, 25, 0, 2 * Math.PI);    ctx.stroke(rectangle);    ctx.fill(circle);  }}</code></pre><h2 id="色彩"><a href="#色彩" class="headerlink" title="色彩"></a>色彩</h2><p>fillStyle = color：设置图形的填充颜色；strokeStyle = color：设置图形轮廓的颜色。</p><blockquote><p>注意: 一旦您设置了 strokeStyle 或者 fillStyle 的值，那么这个新值就会成为新绘制的图形的默认值。如果你要给每个图形上不同的颜色，你需要重新设置 fillStyle 或 strokeStyle 的值。</p><p>globalAlpha = transparencyValue；可选的范围是0.0-1.0，会设置之后所有被绘制的canvas图形的透明度。但是由于支持rgba格式的颜色，所以这个方法并不必要。</p></blockquote><h2 id="线型"><a href="#线型" class="headerlink" title="线型"></a>线型</h2><ul><li>lineWidth = value<br>设置线条宽度。</li><li>lineCap = type<br>设置线条末端样式。butt(默认)，round 和 square。<br><img src="https://developer.mozilla.org/@api/deki/files/88/=Canvas_linecap.png" alt=""></li><li>lineJoin = type<br>设定线条与线条间接合处的样式。round, bevel 和 miter(默认).<br><img src="https://developer.mozilla.org/@api/deki/files/89/=Canvas_linejoin.png" alt=""></li><li>miterLimit = value<br>限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。</li><li>getLineDash()<br>返回一个包含当前虚线样式，长度为非负偶数的数组。</li><li>setLineDash(segments)<br>设置当前虚线样式。<br>这里的参数一般情况下应该为两个，表示线长和间隔长度，其他情况时代表从左侧到右侧的每一块长度的循环单元，这里的长度块既包含线也包含间隔。</li><li>lineDashOffset = value<br>设置虚线样式的起始偏移量。</li></ul><h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><p>我们用下面的方法新建一个 canvasGradient 对象，并且赋给图形的 fillStyle 或 strokeStyle 属性。</p><p>createLinearGradient(x1, y1, x2, y2)：createLinearGradient 方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)。<br>createRadialGradient(x1, y1, r1, x2, y2, r2)：createRadialGradient 方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。</p><p>创建出 canvasGradient 对象后，我们就可以用 addColorStop 方法给它上色了。</p><p>gradient.addColorStop(position, color)：addColorStop 方法接受 2 个参数，position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。例如，0.5 表示颜色会出现在正中间。color 参数必须是一个有效的 CSS 颜色值（如 #FFFFFF rgba(0,0,0,1)，等等）。这里的相对位置就是图形化后的色标位置。</p><pre><code class="javascript">var lineargradient = ctx.createLinearGradient(0,0,150,150);lineargradient.addColorStop(0,&#39;white&#39;);lineargradient.addColorStop(1,&#39;black&#39;);</code></pre><h2 id="图案样式"><a href="#图案样式" class="headerlink" title="图案样式"></a>图案样式</h2><p>createPattern(image, type)：该方法接受两个参数。Image 可以是一个 Image 对象的引用，或者另一个 canvas 对象。Type 必须是下面的字符串值之一：repeat，repeat-x，repeat-y 和 no-repeat。<br><strong><em> 使用 Image 对象的 onload handler 来确保设置图案之前图像已经装载完毕。</em></strong></p><pre><code class="javascript">function draw() {  var ctx = document.getElementById(&#39;canvas&#39;).getContext(&#39;2d&#39;);  // 创建新 image 对象，用作图案  var img = new Image();  img.src = &#39;images/wallpaper.png&#39;;  img.onload = function(){    // 创建图案    var ptrn = ctx.createPattern(img,&#39;repeat&#39;);    ctx.fillStyle = ptrn;    ctx.fillRect(0,0,150,150);  }}</code></pre><h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><ul><li>shadowOffsetX = float<br>shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。</li><li>shadowOffsetY = float<br>shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。</li><li>shadowBlur = float<br>shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。</li><li>shadowColor = color<br>shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。</li></ul><h2 id="填充规则"><a href="#填充规则" class="headerlink" title="填充规则"></a>填充规则</h2><p>用fill、clip、ispointinpath时可以选择填充规则：nonzero（默认）/evenodd<br>（填充中间部分）</p><h2 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h2><p>fillText(text, x, y [, maxWidth]):在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的.<br>strokeText(text, x, y [, maxWidth]):在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的.</p><p>文本还可以设置样式：</p><ul><li>font = value<br>当前我们用来绘制文本的样式. 这个字符串使用和 CSS font 属性相同的语法. 默认的字体是 10px sans-serif。</li><li>textAlign = value<br>文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start。</li><li>textBaseline = value<br>基线对齐选项. 可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。</li><li>direction = value<br>文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。</li></ul><p>文本测量：measureText()：将返回一个 TextMetrics对象的宽度、所在像素，这些体现文本特性的属性。</p><h2 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h2><p>在绘制之前，要先通过dom方法来获取图片/视频的帧/canvas对象。</p><p>drawImage(image, x, y):其中 image 是 image 或者 canvas 对象，x 和 y 是其在目标 canvas 里的起始坐标。</p><pre><code class="javascript">function draw() {    var ctx = document.getElementById(&#39;canvas&#39;).getContext(&#39;2d&#39;);    var img = new Image();    img.onload = function(){      ctx.drawImage(img,0,0);      ctx.beginPath();      ctx.moveTo(30,96);      ctx.lineTo(70,66);      ctx.lineTo(103,76);      ctx.lineTo(170,15);      ctx.stroke();    }    img.src = &#39;images/backdrop.png&#39;;  }</code></pre><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p>drawImage(image, x, y, width, height)：这个方法多了2个参数：width 和 height，这两个参数用来控制 当像canvas画入时应该缩放的大小。</p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)：第一个参数和其它的是相同的，都是一个图像或者另一个 canvas 的引用。其它8个参数，前4个是定义图像源的切片位置和大小，后4个则是定义切片的目标显示位置和大小。</p><h2 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h2><p>save()restore()：save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。</p><blockquote><p>Canvas状态存储在栈中，每当save()方法被调用后，当前的状态就被推送到栈中保存。一个绘画状态包括：当前应用的变形（即移动，旋转和缩放，见下）strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin,miterLimit,shadowOffsetX, shadowOffsetY, shadowBlur,shadowColor,globalCompositeOperation 的值当前的裁切路径（clipping path）</p></blockquote><pre><code class="javascript">function draw() {  var ctx = document.getElementById(&#39;canvas&#39;).getContext(&#39;2d&#39;);  ctx.fillRect(0,0,150,150);   // 使用默认设置绘制一个矩形  ctx.save();                  // 保存默认状态  ctx.fillStyle = &#39;#09F&#39;       // 在原有配置基础上对颜色做改变  ctx.fillRect(15,15,120,120); // 使用新的设置绘制一个矩形  ctx.save();                  // 保存当前状态  ctx.fillStyle = &#39;#FFF&#39;       // 再次改变颜色配置  ctx.globalAlpha = 0.5;      ctx.fillRect(30,30,90,90);   // 使用新的配置绘制一个矩形  ctx.restore();               // 重新加载之前的颜色状态  ctx.fillRect(45,45,60,60);   // 使用上一次的配置绘制一个矩形  ctx.restore();               // 加载默认颜色配置  ctx.fillRect(60,60,30,30);   // 使用加载的配置绘制一个矩形}</code></pre><p><img src="https://mdn.mozillademos.org/files/249/Canvas_savestate.png" alt=""></p><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p>translate(x, y)：translate 方法接受两个参数。x 是左右偏移量，y 是上下偏移量，如右图所示。用来移动 canvas 和它的原点到一个不同的位置。</p><p>translate和moveto的区别是什么？</p><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>rotate(angle)：这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。旋转的中心点始终是 canvas 的原点，如果要改变它，我们需要用到 translate 方法。</p><h3 id="缩放-1"><a href="#缩放-1" class="headerlink" title="缩放"></a>缩放</h3><p>scale(x, y)：scale 方法接受两个参数。x,y 分别是横轴和纵轴的缩放因子，它们都必须是正值。值比 1.0 小表示缩小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有。</p><h3 id="变形-1"><a href="#变形-1" class="headerlink" title="变形"></a>变形</h3><p>transform(m11, m12, m21, m22, dx, dy)</p><pre><code>m11 m21 dxm12 m22 dy0     0     1</code></pre><p>用以上矩阵进行图像变换。</p><p>setTransform()：将当前的变换矩阵设置为默认的单位矩阵，然后在单位矩阵之上运用用户指定的变换。</p><p>resetTransform()：重置为单位矩阵。</p><h2 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h2><p>globalCompositeOperation：覆盖规则，当其为“source-over”，后来者居上，当其为“destination-over”则相反。</p><h2 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h2><blockquote><p>clip()方法从原始画布中剪切任意形状和尺寸。提示：一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域）。您也可以在使用 clip() 方法前通过使用 save() 方法对当前画布区域进行保存，并在以后的任意时间对其进行恢复（通过 restore() 方法）</p></blockquote><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>requestAnimationFrame(callback)</p><blockquote><p>。这个方法提供了更加平缓并更加有效率的方式来执行动画，当系统准备好了重绘条件的时候，才调用绘制动画帧。一般每秒钟回调函数执行60次，也有可能会被降低。<br>回调函数只会被传入一个参数，DOMHighResTimeStamp，指示当前被 requestAnimationFrame 序列化的函数队列被触发的时间。即使经过了许多对之前回调的计算工作时间，单个帧中的多个回调也都将被传入相同的时间戳。此数值是一个十进制数，单位毫秒，最小精度为1ms(1000μs)。</p></blockquote><h2 id="ImageData-对象"><a href="#ImageData-对象" class="headerlink" title="ImageData 对象"></a>ImageData 对象</h2><p>其包含的内容有:width、height、data:Uint8ClampedArray 类型</p><p>createImageData(width, height):创建对象,颜色为黑色.</p><p>getImageData(left, top, width, height):这个方法会返回一个ImageData对象，它代表了画布区域的对象数据.</p><p>putImageData(myImageData, dx, dy):对场景进行像素数据的写入.</p><h2 id="反锯齿"><a href="#反锯齿" class="headerlink" title="反锯齿"></a>反锯齿</h2><p>imageSmoothingEnabled属性//默认情况下启用(true)</p><p>参考资料：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes" target="_blank" rel="noopener">使用canvas来绘制图形 - Web API 接口 | MDN</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/TextMetrics" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/TextMetrics</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas" target="_blank" rel="noopener">像素操作 - Web API 接口 | MDN</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTML5完全学习笔记三：canvas全解&quot;&gt;&lt;a href=&quot;#HTML5完全学习笔记三：canvas全解&quot; class=&quot;headerlink&quot; title=&quot;HTML5完全学习笔记三：canvas全解&quot;&gt;&lt;/a&gt;HTML5完全学习笔记三：canvas全解&lt;/h1&gt;&lt;p&gt;Canvas用于通过js绘制图片和动画。最早由apple引入webkit。&lt;/p&gt;
&lt;p&gt;Canvas元素只有width和height属性，默认情况下的值为300*150.该元素可以使用CSS来定义大小，但在绘制时图像会伸缩以适应它的框架尺寸：如果CSS的尺寸与初始画布的比例不一致，它会出现扭曲。尽量使用width和height来设定canvas的形状大小而非css。&lt;/p&gt;
&lt;h2 id=&quot;getContext&quot;&gt;&lt;a href=&quot;#getContext&quot; class=&quot;headerlink&quot; title=&quot;getContext&quot;&gt;&lt;/a&gt;getContext&lt;/h2&gt;&lt;p&gt;访问绘图上下文，检测是否支持canvas也可以通过检测getcontext。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var canvas = document.getElementById(&amp;#39;tutorial&amp;#39;);

if (canvas.getContext){
  var ctx = canvas.getContext(&amp;#39;2d&amp;#39;);
} else {
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="html" scheme="https://vevlins.github.io/categories/html/"/>
    
    
      <category term="笔记" scheme="https://vevlins.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="教程" scheme="https://vevlins.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="html5" scheme="https://vevlins.github.io/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>HTML5完全学习笔记二：events全解</title>
    <link href="https://vevlins.github.io/2017/12/23/HTML5%E5%AE%8C%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%9Aevents%E5%85%A8%E8%A7%A3/"/>
    <id>https://vevlins.github.io/2017/12/23/HTML5完全学习笔记二：events全解/</id>
    <published>2017-12-23T10:56:55.000Z</published>
    <updated>2017-12-23T10:58:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML5完全学习笔记二：events全解"><a href="#HTML5完全学习笔记二：events全解" class="headerlink" title="HTML5完全学习笔记二：events全解"></a>HTML5完全学习笔记二：events全解</h1><h2 id="窗口事件"><a href="#窗口事件" class="headerlink" title="窗口事件"></a>窗口事件</h2><p>适用于body标签</p><ul><li>onafterprint<blockquote><p>注意： 目前只有 Internet Explorer 和 Firefox 浏览器支持 onafterprint 事件属性。在 IE 浏览器中, onafterprint 属性在打印对话框之前执行Javascript而不是之后。//?是否意味着在ie中onafterprint=onberforeprint</p><a id="more"></a></blockquote></li><li>onbeforeprint</li><li>onbeforeunload    <blockquote><p> 在onload之前执行，可以阻止unload的执行，在页面关闭页面或者刷新时执行</p></blockquote></li><li>onblur</li><li>onerror<blockquote><p>此外，onerror方法还提供了三个参数用来确定错误确切的信息，分别是：1）message：一个字符串，声明了出现的错误的信息(不同的浏览器中返回的消息内容略有差异)。2）url：一个字符串，声明了出现错误的文档的URL。3）line：一个数字，声明了出现错误的代码行的行号。</p></blockquote></li></ul><blockquote><p>当JavaScript运行时错误（包括语法错误）发生时，window会触发一个ErrorEvent接口的error事件，并执行window.onerror()。当一项资源（如<img>或<script>）加载失败，加载资源的元素会触发一个Event接口的error事件，并执行该元素上的onerror()处理函数。这些error事件不会向上冒泡到window，不过（至少在Firefox中）能被单一的window.addEventListener捕获。</p><ul><li>onfocus</li><li>onhaschange<br>锚改变时触发，有两个属性newURL和oldURL。</li><li>onload<br>onload 通常用于 <body> 元素，在页面完全载入后(包括图片、css文件等等。)执行脚本代码。</li><li>onmessage<br>Web Workers </li><li>onoffline</li><li>ononline<br>使用navigator.onLine 也可以检测是否在线</li><li>onpagehide</li><li>onpageshow<br>onpageshow 事件类似于 onload 事件，onload 事件在页面第一次加载时触发， onpageshow 事件在每次加载页面时触发，即 onload 事件在页面从浏览器缓存中读取时不触发。</li><li>onpopstate<br>每当处于激活状态的历史记录条目发生变化时,popstate事件就会在对应window对象上触发. 如果当前处于激活状态的历史记录条目是由history.pushState()方法创建,或者由history.replaceState()方法修改过的, 则popstate事件对象的state属性包含了这个历史记录条目的state对象的一个拷贝.调用history.pushState()或者history.replaceState()不会触发popstate事件. popstate事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮(或者在JavaScript中调用history.back()、history.forward()、history.go()方法).当网页加载时,各浏览器对popstate事件是否触发有不同的表现,Chrome 和 Safari会触发popstate事件, 而Firefox不会.</li><li>onredo</li><li>onresize</li><li>onstorage<br>web存储区域（DOM Storage）更新时触发onstorage事件。如果变更了Storage对象的属性值，或者调用了setItem()、removeItem()等方法，就会触发onstorage事件。//这里的或者是什么意思，如果调用setitem但并不更改值只是设定为和之前的值一样，是否会触发这个事件。</li><li>onundo</li><li>onunload</li></ul></blockquote><p>//有些类似于生命周期函数或者就是生命周期函数？</p><h2 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h2><p>适用于在form内部的所有元素</p><ul><li>onblur</li><li>onchange</li><li>oncontextmenu<blockquote><p>此事件会发生在没有阻止右键事件的情况下而且这不取决于此元素是否拥有了”contextmenu”属性.</p></blockquote></li><li>onfocus</li><li>onformchange</li><li>onforminput</li><li>oninput</li><li>oninvalid</li><li>onselect</li><li>onsubmit</li></ul><h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><ul><li>onkeydown</li><li>onkeypress</li><li>onkeyup</li></ul><h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><ul><li>onclick</li><li>ondbclick</li><li>ondrag</li><li>ondragend</li><li>ondragenter</li><li>ondragleave</li><li>ondragover</li><li>ondragstart</li><li>ondrop</li><li>onmousedown</li><li>onmousemove</li><li>onmouseout</li><li>onmouseover</li><li>onmouseup</li><li>onmousewheel</li><li>onscrolll</li></ul><h2 id="多媒体事件"><a href="#多媒体事件" class="headerlink" title="多媒体事件"></a>多媒体事件</h2><ul><li>onabort</li><li>oncanplay</li><li>oncanplaythrough</li><li>ondurationchange</li><li>onemptied</li><li>onended</li><li>onerror</li><li>onloadeddata</li><li>onloadedmetadata</li><li>onloadstart</li><li>onpause</li><li>onplay</li><li>onplaying</li><li>onprogress</li><li>onratechange</li><li>onreadystatechange</li><li>onseeked</li><li>onseeking</li><li>onstalled</li><li>onsuspend</li><li>ontimeupdate</li><li>onvolumechage</li><li>onwaiting</li></ul><h2 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h2><ul><li>onshow：menu显示时触发，兼容性不佳</li><li>ontoggle：打开或关闭details时触发</li></ul><p>参考资料：</p><ul><li><a href="http://www.runoob.com/tags/ref-eventattributes.html">HTML 事件 | 菜鸟教程</a></li><li><a href="https://www.cnblogs.com/arinna/archive/2011/08/08/2130629.html">JavaScript中的onerror事件 - arinna - 博客园</a></li></ul></script></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTML5完全学习笔记二：events全解&quot;&gt;&lt;a href=&quot;#HTML5完全学习笔记二：events全解&quot; class=&quot;headerlink&quot; title=&quot;HTML5完全学习笔记二：events全解&quot;&gt;&lt;/a&gt;HTML5完全学习笔记二：events全解&lt;/h1&gt;&lt;h2 id=&quot;窗口事件&quot;&gt;&lt;a href=&quot;#窗口事件&quot; class=&quot;headerlink&quot; title=&quot;窗口事件&quot;&gt;&lt;/a&gt;窗口事件&lt;/h2&gt;&lt;p&gt;适用于body标签&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;onafterprint&lt;blockquote&gt;
&lt;p&gt;注意： 目前只有 Internet Explorer 和 Firefox 浏览器支持 onafterprint 事件属性。在 IE 浏览器中, onafterprint 属性在打印对话框之前执行Javascript而不是之后。//?是否意味着在ie中onafterprint=onberforeprint&lt;/p&gt;
    
    </summary>
    
      <category term="html" scheme="https://vevlins.github.io/categories/html/"/>
    
    
      <category term="笔记" scheme="https://vevlins.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="教程" scheme="https://vevlins.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="html5" scheme="https://vevlins.github.io/tags/html5/"/>
    
  </entry>
  
</feed>
